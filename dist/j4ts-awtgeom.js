var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/* Generated from Java with JSweet 2.0.0-SNAPSHOT - http://www.jsweet.org */
/**
 * The <code>AffineTransform</code> class represents a 2D affine transform
 * that performs a linear mapping from 2D coordinates to other 2D
 * coordinates that preserves the "straightness" and
 * "parallelness" of lines.  Affine transformations can be constructed
 * using sequences of translations, scales, flips, rotations, and shears.
 * <p>
 * Such a coordinate transformation can be represented by a 3 row by
 * 3 column matrix with an implied last row of [ 0 0 1 ].  This matrix
 * transforms source coordinates {@code (x,y)} into
 * destination coordinates {@code (x',y')} by considering
 * them to be a column vector and multiplying the coordinate vector
 * by the matrix according to the following process:
 * <pre>
 * [ x']   [  m00  m01  m02  ] [ x ]   [ m00x + m01y + m02 ]
 * [ y'] = [  m10  m11  m12  ] [ y ] = [ m10x + m11y + m12 ]
 * [ 1 ]   [   0    0    1   ] [ 1 ]   [         1         ]
 * </pre>
 * <h3><a name="quadrantapproximation">Handling 90-Degree Rotations</a></h3>
 * <p>
 * In some variations of the <code>rotate</code> methods in the
 * <code>AffineTransform</code> class, a double-precision argument
 * specifies the angle of rotation in radians.
 * These methods have special handling for rotations of approximately
 * 90 degrees (including multiples such as 180, 270, and 360 degrees),
 * so that the common case of quadrant rotation is handled more
 * efficiently.
 * This special handling can cause angles very close to multiples of
 * 90 degrees to be treated as if they were exact multiples of
 * 90 degrees.
 * For small multiples of 90 degrees the range of angles treated
 * as a quadrant rotation is approximately 0.00000121 degrees wide.
 * This section explains why such special care is needed and how
 * it is implemented.
 * <p>
 * Since 90 degrees is represented as <code>PI/2</code> in radians,
 * and since PI is a transcendental (and therefore irrational) number,
 * it is not possible to exactly represent a multiple of 90 degrees as
 * an exact double precision value measured in radians.
 * As a result it is theoretically impossible to describe quadrant
 * rotations (90, 180, 270 or 360 degrees) using these values.
 * Double precision floating point values can get very close to
 * non-zero multiples of <code>PI/2</code> but never close enough
 * for the sine or cosine to be exactly 0.0, 1.0 or -1.0.
 * The implementations of <code>Math.sin()</code> and
 * <code>Math.cos()</code> correspondingly never return 0.0
 * for any case other than <code>Math.sin(0.0)</code>.
 * These same implementations do, however, return exactly 1.0 and
 * -1.0 for some range of numbers around each multiple of 90
 * degrees since the correct answer is so close to 1.0 or -1.0 that
 * the double precision significand cannot represent the difference
 * as accurately as it can for numbers that are near 0.0.
 * <p>
 * The net result of these issues is that if the
 * <code>Math.sin()</code> and <code>Math.cos()</code> methods
 * are used to directly generate the values for the matrix modifications
 * during these radian-based rotation operations then the resulting
 * transform is never strictly classifiable as a quadrant rotation
 * even for a simple case like <code>rotate(Math.PI/2.0)</code>,
 * due to minor variations in the matrix caused by the non-0.0 values
 * obtained for the sine and cosine.
 * If these transforms are not classified as quadrant rotations then
 * subsequent code which attempts to optimize further operations based
 * upon the type of the transform will be relegated to its most general
 * implementation.
 * <p>
 * Because quadrant rotations are fairly common,
 * this class should handle these cases reasonably quickly, both in
 * applying the rotations to the transform and in applying the resulting
 * transform to the coordinates.
 * To facilitate this optimal handling, the methods which take an angle
 * of rotation measured in radians attempt to detect angles that are
 * intended to be quadrant rotations and treat them as such.
 * These methods therefore treat an angle <em>theta</em> as a quadrant
 * rotation if either <code>Math.sin(<em>theta</em>)</code> or
 * <code>Math.cos(<em>theta</em>)</code> returns exactly 1.0 or -1.0.
 * As a rule of thumb, this property holds true for a range of
 * approximately 0.0000000211 radians (or 0.00000121 degrees) around
 * small multiples of <code>Math.PI/2.0</code>.
 *
 * @author Jim Graham
 * @since 1.2
 */
var AffineTransform = (function () {
    function AffineTransform(m00, m10, m01, m11, m02, m12, state) {
        var _this = this;
        if (((typeof m00 === 'number') || m00 === null) && ((typeof m10 === 'number') || m10 === null) && ((typeof m01 === 'number') || m01 === null) && ((typeof m11 === 'number') || m11 === null) && ((typeof m02 === 'number') || m02 === null) && ((typeof m12 === 'number') || m12 === null) && ((typeof state === 'number') || state === null)) {
            var __args = Array.prototype.slice.call(arguments);
            this.m00 = 0;
            this.m10 = 0;
            this.m01 = 0;
            this.m11 = 0;
            this.m02 = 0;
            this.m12 = 0;
            this.state = 0;
            this.type = 0;
            this.m00 = 0;
            this.m10 = 0;
            this.m01 = 0;
            this.m11 = 0;
            this.m02 = 0;
            this.m12 = 0;
            this.state = 0;
            this.type = 0;
            (function () {
                _this.m00 = m00;
                _this.m10 = m10;
                _this.m01 = m01;
                _this.m11 = m11;
                _this.m02 = m02;
                _this.m12 = m12;
                _this.state = state;
                _this.type = AffineTransform.TYPE_UNKNOWN;
            })();
        }
        else if (((typeof m00 === 'number') || m00 === null) && ((typeof m10 === 'number') || m10 === null) && ((typeof m01 === 'number') || m01 === null) && ((typeof m11 === 'number') || m11 === null) && ((typeof m02 === 'number') || m02 === null) && ((typeof m12 === 'number') || m12 === null) && state === undefined) {
            var __args = Array.prototype.slice.call(arguments);
            this.m00 = 0;
            this.m10 = 0;
            this.m01 = 0;
            this.m11 = 0;
            this.m02 = 0;
            this.m12 = 0;
            this.state = 0;
            this.type = 0;
            this.m00 = 0;
            this.m10 = 0;
            this.m01 = 0;
            this.m11 = 0;
            this.m02 = 0;
            this.m12 = 0;
            this.state = 0;
            this.type = 0;
            (function () {
                _this.m00 = m00;
                _this.m10 = m10;
                _this.m01 = m01;
                _this.m11 = m11;
                _this.m02 = m02;
                _this.m12 = m12;
                _this.updateState();
            })();
        }
        else if (((typeof m00 === 'number') || m00 === null) && ((typeof m10 === 'number') || m10 === null) && ((typeof m01 === 'number') || m01 === null) && ((typeof m11 === 'number') || m11 === null) && ((typeof m02 === 'number') || m02 === null) && ((typeof m12 === 'number') || m12 === null) && state === undefined) {
            var __args = Array.prototype.slice.call(arguments);
            this.m00 = 0;
            this.m10 = 0;
            this.m01 = 0;
            this.m11 = 0;
            this.m02 = 0;
            this.m12 = 0;
            this.state = 0;
            this.type = 0;
            this.m00 = 0;
            this.m10 = 0;
            this.m01 = 0;
            this.m11 = 0;
            this.m02 = 0;
            this.m12 = 0;
            this.state = 0;
            this.type = 0;
            (function () {
                _this.m00 = m00;
                _this.m10 = m10;
                _this.m01 = m01;
                _this.m11 = m11;
                _this.m02 = m02;
                _this.m12 = m12;
                _this.updateState();
            })();
        }
        else if (((m00 != null && m00 instanceof AffineTransform) || m00 === null) && m10 === undefined && m01 === undefined && m11 === undefined && m02 === undefined && m12 === undefined && state === undefined) {
            var __args = Array.prototype.slice.call(arguments);
            var Tx_1 = __args[0];
            this.m00 = 0;
            this.m10 = 0;
            this.m01 = 0;
            this.m11 = 0;
            this.m02 = 0;
            this.m12 = 0;
            this.state = 0;
            this.type = 0;
            this.m00 = 0;
            this.m10 = 0;
            this.m01 = 0;
            this.m11 = 0;
            this.m02 = 0;
            this.m12 = 0;
            this.state = 0;
            this.type = 0;
            (function () {
                _this.m00 = Tx_1.m00;
                _this.m10 = Tx_1.m10;
                _this.m01 = Tx_1.m01;
                _this.m11 = Tx_1.m11;
                _this.m02 = Tx_1.m02;
                _this.m12 = Tx_1.m12;
                _this.state = Tx_1.state;
                _this.type = Tx_1.type;
            })();
        }
        else if (((m00 != null && m00 instanceof Array && (m00.length == 0 || m00[0] == null || (typeof m00[0] === 'number'))) || m00 === null) && m10 === undefined && m01 === undefined && m11 === undefined && m02 === undefined && m12 === undefined && state === undefined) {
            var __args = Array.prototype.slice.call(arguments);
            var flatmatrix_1 = __args[0];
            this.m00 = 0;
            this.m10 = 0;
            this.m01 = 0;
            this.m11 = 0;
            this.m02 = 0;
            this.m12 = 0;
            this.state = 0;
            this.type = 0;
            this.m00 = 0;
            this.m10 = 0;
            this.m01 = 0;
            this.m11 = 0;
            this.m02 = 0;
            this.m12 = 0;
            this.state = 0;
            this.type = 0;
            (function () {
                _this.m00 = flatmatrix_1[0];
                _this.m10 = flatmatrix_1[1];
                _this.m01 = flatmatrix_1[2];
                _this.m11 = flatmatrix_1[3];
                if (flatmatrix_1.length > 5) {
                    _this.m02 = flatmatrix_1[4];
                    _this.m12 = flatmatrix_1[5];
                }
                _this.updateState();
            })();
        }
        else if (((m00 != null && m00 instanceof Array && (m00.length == 0 || m00[0] == null || (typeof m00[0] === 'number'))) || m00 === null) && m10 === undefined && m01 === undefined && m11 === undefined && m02 === undefined && m12 === undefined && state === undefined) {
            var __args = Array.prototype.slice.call(arguments);
            var flatmatrix_2 = __args[0];
            this.m00 = 0;
            this.m10 = 0;
            this.m01 = 0;
            this.m11 = 0;
            this.m02 = 0;
            this.m12 = 0;
            this.state = 0;
            this.type = 0;
            this.m00 = 0;
            this.m10 = 0;
            this.m01 = 0;
            this.m11 = 0;
            this.m02 = 0;
            this.m12 = 0;
            this.state = 0;
            this.type = 0;
            (function () {
                _this.m00 = flatmatrix_2[0];
                _this.m10 = flatmatrix_2[1];
                _this.m01 = flatmatrix_2[2];
                _this.m11 = flatmatrix_2[3];
                if (flatmatrix_2.length > 5) {
                    _this.m02 = flatmatrix_2[4];
                    _this.m12 = flatmatrix_2[5];
                }
                _this.updateState();
            })();
        }
        else if (m00 === undefined && m10 === undefined && m01 === undefined && m11 === undefined && m02 === undefined && m12 === undefined && state === undefined) {
            var __args = Array.prototype.slice.call(arguments);
            this.m00 = 0;
            this.m10 = 0;
            this.m01 = 0;
            this.m11 = 0;
            this.m02 = 0;
            this.m12 = 0;
            this.state = 0;
            this.type = 0;
            this.m00 = 0;
            this.m10 = 0;
            this.m01 = 0;
            this.m11 = 0;
            this.m02 = 0;
            this.m12 = 0;
            this.state = 0;
            this.type = 0;
            (function () {
                _this.m00 = _this.m11 = 1.0;
            })();
        }
        else
            throw new Error('invalid overload');
    }
    AffineTransform.TYPE_MASK_SCALE_$LI$ = function () { if (AffineTransform.TYPE_MASK_SCALE == null)
        AffineTransform.TYPE_MASK_SCALE = (AffineTransform.TYPE_UNIFORM_SCALE | AffineTransform.TYPE_GENERAL_SCALE); return AffineTransform.TYPE_MASK_SCALE; };
    ;
    AffineTransform.TYPE_MASK_ROTATION_$LI$ = function () { if (AffineTransform.TYPE_MASK_ROTATION == null)
        AffineTransform.TYPE_MASK_ROTATION = (AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_GENERAL_ROTATION); return AffineTransform.TYPE_MASK_ROTATION; };
    ;
    AffineTransform.HI_IDENTITY_$LI$ = function () { if (AffineTransform.HI_IDENTITY == null)
        AffineTransform.HI_IDENTITY = AffineTransform.APPLY_IDENTITY << AffineTransform.HI_SHIFT; return AffineTransform.HI_IDENTITY; };
    ;
    AffineTransform.HI_TRANSLATE_$LI$ = function () { if (AffineTransform.HI_TRANSLATE == null)
        AffineTransform.HI_TRANSLATE = AffineTransform.APPLY_TRANSLATE << AffineTransform.HI_SHIFT; return AffineTransform.HI_TRANSLATE; };
    ;
    AffineTransform.HI_SCALE_$LI$ = function () { if (AffineTransform.HI_SCALE == null)
        AffineTransform.HI_SCALE = AffineTransform.APPLY_SCALE << AffineTransform.HI_SHIFT; return AffineTransform.HI_SCALE; };
    ;
    AffineTransform.HI_SHEAR_$LI$ = function () { if (AffineTransform.HI_SHEAR == null)
        AffineTransform.HI_SHEAR = AffineTransform.APPLY_SHEAR << AffineTransform.HI_SHIFT; return AffineTransform.HI_SHEAR; };
    ;
    /**
     * Returns a transform representing a translation transformation.
     * The matrix representing the returned transform is:
     * <pre>
     * [   1    0    tx  ]
     * [   0    1    ty  ]
     * [   0    0    1   ]
     * </pre>
     * @param {number} tx the distance by which coordinates are translated in the
     * X axis direction
     * @param {number} ty the distance by which coordinates are translated in the
     * Y axis direction
     * @return {AffineTransform} an <code>AffineTransform</code> object that represents a
     * translation transformation, created with the specified vector.
     * @since 1.2
     */
    AffineTransform.getTranslateInstance = function (tx, ty) {
        var Tx = new AffineTransform();
        Tx.setToTranslation(tx, ty);
        return Tx;
    };
    /**
     * Returns a transform representing a rotation transformation.
     * The matrix representing the returned transform is:
     * <pre>
     * [   cos(theta)    -sin(theta)    0   ]
     * [   sin(theta)     cos(theta)    0   ]
     * [       0              0         1   ]
     * </pre>
     * Rotating by a positive angle theta rotates points on the positive
     * X axis toward the positive Y axis.
     * Note also the discussion of
     * <a href="#quadrantapproximation">Handling 90-Degree Rotations</a>
     * above.
     * @param {number} theta the angle of rotation measured in radians
     * @return {AffineTransform} an <code>AffineTransform</code> object that is a rotation
     * transformation, created with the specified angle of rotation.
     * @since 1.2
     */
    AffineTransform.getRotateInstance$double = function (theta) {
        var Tx = new AffineTransform();
        Tx.setToRotation$double(theta);
        return Tx;
    };
    /**
     * Returns a transform that rotates coordinates around an anchor point.
     * This operation is equivalent to translating the coordinates so
     * that the anchor point is at the origin (S1), then rotating them
     * about the new origin (S2), and finally translating so that the
     * intermediate origin is restored to the coordinates of the original
     * anchor point (S3).
     * <p>
     * This operation is equivalent to the following sequence of calls:
     * <pre>
     * AffineTransform Tx = new AffineTransform();
     * Tx.translate(anchorx, anchory);    // S3: final translation
     * Tx.rotate(theta);                  // S2: rotate around anchor
     * Tx.translate(-anchorx, -anchory);  // S1: translate anchor to origin
     * </pre>
     * The matrix representing the returned transform is:
     * <pre>
     * [   cos(theta)    -sin(theta)    x-x*cos+y*sin  ]
     * [   sin(theta)     cos(theta)    y-x*sin-y*cos  ]
     * [       0              0               1        ]
     * </pre>
     * Rotating by a positive angle theta rotates points on the positive
     * X axis toward the positive Y axis.
     * Note also the discussion of
     * <a href="#quadrantapproximation">Handling 90-Degree Rotations</a>
     * above.
     *
     * @param {number} theta the angle of rotation measured in radians
     * @param {number} anchorx the X coordinate of the rotation anchor point
     * @param {number} anchory the Y coordinate of the rotation anchor point
     * @return {AffineTransform} an <code>AffineTransform</code> object that rotates
     * coordinates around the specified point by the specified angle of
     * rotation.
     * @since 1.2
     */
    AffineTransform.getRotateInstance$double$double$double = function (theta, anchorx, anchory) {
        var Tx = new AffineTransform();
        Tx.setToRotation$double$double$double(theta, anchorx, anchory);
        return Tx;
    };
    /**
     * Returns a transform that rotates coordinates according to
     * a rotation vector.
     * All coordinates rotate about the origin by the same amount.
     * The amount of rotation is such that coordinates along the former
     * positive X axis will subsequently align with the vector pointing
     * from the origin to the specified vector coordinates.
     * If both <code>vecx</code> and <code>vecy</code> are 0.0,
     * an identity transform is returned.
     * This operation is equivalent to calling:
     * <pre>
     * AffineTransform.getRotateInstance(Math.atan2(vecy, vecx));
     * </pre>
     *
     * @param {number} vecx the X coordinate of the rotation vector
     * @param {number} vecy the Y coordinate of the rotation vector
     * @return {AffineTransform} an <code>AffineTransform</code> object that rotates
     * coordinates according to the specified rotation vector.
     * @since 1.6
     */
    AffineTransform.getRotateInstance$double$double = function (vecx, vecy) {
        var Tx = new AffineTransform();
        Tx.setToRotation$double$double(vecx, vecy);
        return Tx;
    };
    /**
     * Returns a transform that rotates coordinates around an anchor
     * point according to a rotation vector.
     * All coordinates rotate about the specified anchor coordinates
     * by the same amount.
     * The amount of rotation is such that coordinates along the former
     * positive X axis will subsequently align with the vector pointing
     * from the origin to the specified vector coordinates.
     * If both <code>vecx</code> and <code>vecy</code> are 0.0,
     * an identity transform is returned.
     * This operation is equivalent to calling:
     * <pre>
     * AffineTransform.getRotateInstance(Math.atan2(vecy, vecx),
     * anchorx, anchory);
     * </pre>
     *
     * @param {number} vecx the X coordinate of the rotation vector
     * @param {number} vecy the Y coordinate of the rotation vector
     * @param {number} anchorx the X coordinate of the rotation anchor point
     * @param {number} anchory the Y coordinate of the rotation anchor point
     * @return {AffineTransform} an <code>AffineTransform</code> object that rotates
     * coordinates around the specified point according to the
     * specified rotation vector.
     * @since 1.6
     */
    AffineTransform.getRotateInstance$double$double$double$double = function (vecx, vecy, anchorx, anchory) {
        var Tx = new AffineTransform();
        Tx.setToRotation$double$double$double$double(vecx, vecy, anchorx, anchory);
        return Tx;
    };
    /**
     * Returns a transform that rotates coordinates around an anchor
     * point according to a rotation vector.
     * All coordinates rotate about the specified anchor coordinates
     * by the same amount.
     * The amount of rotation is such that coordinates along the former
     * positive X axis will subsequently align with the vector pointing
     * from the origin to the specified vector coordinates.
     * If both <code>vecx</code> and <code>vecy</code> are 0.0,
     * an identity transform is returned.
     * This operation is equivalent to calling:
     * <pre>
     * AffineTransform.getRotateInstance(Math.atan2(vecy, vecx),
     * anchorx, anchory);
     * </pre>
     *
     * @param {number} vecx the X coordinate of the rotation vector
     * @param {number} vecy the Y coordinate of the rotation vector
     * @param {number} anchorx the X coordinate of the rotation anchor point
     * @param {number} anchory the Y coordinate of the rotation anchor point
     * @return {AffineTransform} an <code>AffineTransform</code> object that rotates
     * coordinates around the specified point according to the
     * specified rotation vector.
     * @since 1.6
     */
    AffineTransform.getRotateInstance = function (vecx, vecy, anchorx, anchory) {
        if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && ((typeof anchorx === 'number') || anchorx === null) && ((typeof anchory === 'number') || anchory === null)) {
            return AffineTransform.getRotateInstance$double$double$double$double(vecx, vecy, anchorx, anchory);
        }
        else if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && ((typeof anchorx === 'number') || anchorx === null) && anchory === undefined) {
            return AffineTransform.getRotateInstance$double$double$double(vecx, vecy, anchorx);
        }
        else if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && anchorx === undefined && anchory === undefined) {
            return AffineTransform.getRotateInstance$double$double(vecx, vecy);
        }
        else if (((typeof vecx === 'number') || vecx === null) && vecy === undefined && anchorx === undefined && anchory === undefined) {
            return AffineTransform.getRotateInstance$double(vecx);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Returns a transform that rotates coordinates by the specified
     * number of quadrants.
     * This operation is equivalent to calling:
     * <pre>
     * AffineTransform.getRotateInstance(numquadrants * Math.PI / 2.0);
     * </pre>
     * Rotating by a positive number of quadrants rotates points on
     * the positive X axis toward the positive Y axis.
     * @param {number} numquadrants the number of 90 degree arcs to rotate by
     * @return {AffineTransform} an <code>AffineTransform</code> object that rotates
     * coordinates by the specified number of quadrants.
     * @since 1.6
     */
    AffineTransform.getQuadrantRotateInstance$int = function (numquadrants) {
        var Tx = new AffineTransform();
        Tx.setToQuadrantRotation$int(numquadrants);
        return Tx;
    };
    /**
     * Returns a transform that rotates coordinates by the specified
     * number of quadrants around the specified anchor point.
     * This operation is equivalent to calling:
     * <pre>
     * AffineTransform.getRotateInstance(numquadrants * Math.PI / 2.0,
     * anchorx, anchory);
     * </pre>
     * Rotating by a positive number of quadrants rotates points on
     * the positive X axis toward the positive Y axis.
     *
     * @param {number} numquadrants the number of 90 degree arcs to rotate by
     * @param {number} anchorx the X coordinate of the rotation anchor point
     * @param {number} anchory the Y coordinate of the rotation anchor point
     * @return {AffineTransform} an <code>AffineTransform</code> object that rotates
     * coordinates by the specified number of quadrants around the
     * specified anchor point.
     * @since 1.6
     */
    AffineTransform.getQuadrantRotateInstance$int$double$double = function (numquadrants, anchorx, anchory) {
        var Tx = new AffineTransform();
        Tx.setToQuadrantRotation$int$double$double(numquadrants, anchorx, anchory);
        return Tx;
    };
    /**
     * Returns a transform that rotates coordinates by the specified
     * number of quadrants around the specified anchor point.
     * This operation is equivalent to calling:
     * <pre>
     * AffineTransform.getRotateInstance(numquadrants * Math.PI / 2.0,
     * anchorx, anchory);
     * </pre>
     * Rotating by a positive number of quadrants rotates points on
     * the positive X axis toward the positive Y axis.
     *
     * @param {number} numquadrants the number of 90 degree arcs to rotate by
     * @param {number} anchorx the X coordinate of the rotation anchor point
     * @param {number} anchory the Y coordinate of the rotation anchor point
     * @return {AffineTransform} an <code>AffineTransform</code> object that rotates
     * coordinates by the specified number of quadrants around the
     * specified anchor point.
     * @since 1.6
     */
    AffineTransform.getQuadrantRotateInstance = function (numquadrants, anchorx, anchory) {
        if (((typeof numquadrants === 'number') || numquadrants === null) && ((typeof anchorx === 'number') || anchorx === null) && ((typeof anchory === 'number') || anchory === null)) {
            return AffineTransform.getQuadrantRotateInstance$int$double$double(numquadrants, anchorx, anchory);
        }
        else if (((typeof numquadrants === 'number') || numquadrants === null) && anchorx === undefined && anchory === undefined) {
            return AffineTransform.getQuadrantRotateInstance$int(numquadrants);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Returns a transform representing a scaling transformation.
     * The matrix representing the returned transform is:
     * <pre>
     * [   sx   0    0   ]
     * [   0    sy   0   ]
     * [   0    0    1   ]
     * </pre>
     * @param {number} sx the factor by which coordinates are scaled along the
     * X axis direction
     * @param {number} sy the factor by which coordinates are scaled along the
     * Y axis direction
     * @return {AffineTransform} an <code>AffineTransform</code> object that scales
     * coordinates by the specified factors.
     * @since 1.2
     */
    AffineTransform.getScaleInstance = function (sx, sy) {
        var Tx = new AffineTransform();
        Tx.setToScale(sx, sy);
        return Tx;
    };
    /**
     * Returns a transform representing a shearing transformation.
     * The matrix representing the returned transform is:
     * <pre>
     * [   1   shx   0   ]
     * [  shy   1    0   ]
     * [   0    0    1   ]
     * </pre>
     * @param {number} shx the multiplier by which coordinates are shifted in the
     * direction of the positive X axis as a factor of their Y coordinate
     * @param {number} shy the multiplier by which coordinates are shifted in the
     * direction of the positive Y axis as a factor of their X coordinate
     * @return {AffineTransform} an <code>AffineTransform</code> object that shears
     * coordinates by the specified multipliers.
     * @since 1.2
     */
    AffineTransform.getShearInstance = function (shx, shy) {
        var Tx = new AffineTransform();
        Tx.setToShear(shx, shy);
        return Tx;
    };
    /**
     * Retrieves the flag bits describing the conversion properties of
     * this transform.
     * The return value is either one of the constants TYPE_IDENTITY
     * or TYPE_GENERAL_TRANSFORM, or a combination of the
     * appropriate flag bits.
     * A valid combination of flag bits is an exclusive OR operation
     * that can combine
     * the TYPE_TRANSLATION flag bit
     * in addition to either of the
     * TYPE_UNIFORM_SCALE or TYPE_GENERAL_SCALE flag bits
     * as well as either of the
     * TYPE_QUADRANT_ROTATION or TYPE_GENERAL_ROTATION flag bits.
     * @return {number} the OR combination of any of the indicated flags that
     * apply to this transform
     * @see #TYPE_IDENTITY
     * @see #TYPE_TRANSLATION
     * @see #TYPE_UNIFORM_SCALE
     * @see #TYPE_GENERAL_SCALE
     * @see #TYPE_QUADRANT_ROTATION
     * @see #TYPE_GENERAL_ROTATION
     * @see #TYPE_GENERAL_TRANSFORM
     * @since 1.2
     */
    AffineTransform.prototype.getType = function () {
        if (this.type === AffineTransform.TYPE_UNKNOWN) {
            this.calculateType();
        }
        return this.type;
    };
    /**
     * This is the utility function to calculate the flag bits when
     * they have not been cached.
     * @see #getType
     * @private
     */
    AffineTransform.prototype.calculateType = function () {
        var ret = AffineTransform.TYPE_IDENTITY;
        var sgn0;
        var sgn1;
        var M0;
        var M1;
        var M2;
        var M3;
        this.updateState();
        switch ((this.state)) {
            default:
                this.stateError();
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                ret = AffineTransform.TYPE_TRANSLATION;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                if ((M0 = this.m00) * (M2 = this.m01) + (M3 = this.m10) * (M1 = this.m11) !== 0) {
                    this.type = AffineTransform.TYPE_GENERAL_TRANSFORM;
                    return;
                }
                sgn0 = (M0 >= 0.0);
                sgn1 = (M1 >= 0.0);
                if (sgn0 === sgn1) {
                    if (M0 !== M1 || M2 !== -M3) {
                        ret |= (AffineTransform.TYPE_GENERAL_ROTATION | AffineTransform.TYPE_GENERAL_SCALE);
                    }
                    else if (M0 * M1 - M2 * M3 !== 1.0) {
                        ret |= (AffineTransform.TYPE_GENERAL_ROTATION | AffineTransform.TYPE_UNIFORM_SCALE);
                    }
                    else {
                        ret |= AffineTransform.TYPE_GENERAL_ROTATION;
                    }
                }
                else {
                    if (M0 !== -M1 || M2 !== M3) {
                        ret |= (AffineTransform.TYPE_GENERAL_ROTATION | AffineTransform.TYPE_FLIP | AffineTransform.TYPE_GENERAL_SCALE);
                    }
                    else if (M0 * M1 - M2 * M3 !== 1.0) {
                        ret |= (AffineTransform.TYPE_GENERAL_ROTATION | AffineTransform.TYPE_FLIP | AffineTransform.TYPE_UNIFORM_SCALE);
                    }
                    else {
                        ret |= (AffineTransform.TYPE_GENERAL_ROTATION | AffineTransform.TYPE_FLIP);
                    }
                }
                break;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                ret = AffineTransform.TYPE_TRANSLATION;
            case (AffineTransform.APPLY_SHEAR):
                sgn0 = ((M0 = this.m01) >= 0.0);
                sgn1 = ((M1 = this.m10) >= 0.0);
                if (sgn0 !== sgn1) {
                    if (M0 !== -M1) {
                        ret |= (AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_GENERAL_SCALE);
                    }
                    else if (M0 !== 1.0 && M0 !== -1.0) {
                        ret |= (AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_UNIFORM_SCALE);
                    }
                    else {
                        ret |= AffineTransform.TYPE_QUADRANT_ROTATION;
                    }
                }
                else {
                    if (M0 === M1) {
                        ret |= (AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_FLIP | AffineTransform.TYPE_UNIFORM_SCALE);
                    }
                    else {
                        ret |= (AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_FLIP | AffineTransform.TYPE_GENERAL_SCALE);
                    }
                }
                break;
            case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                ret = AffineTransform.TYPE_TRANSLATION;
            case (AffineTransform.APPLY_SCALE):
                sgn0 = ((M0 = this.m00) >= 0.0);
                sgn1 = ((M1 = this.m11) >= 0.0);
                if (sgn0 === sgn1) {
                    if (sgn0) {
                        if (M0 === M1) {
                            ret |= AffineTransform.TYPE_UNIFORM_SCALE;
                        }
                        else {
                            ret |= AffineTransform.TYPE_GENERAL_SCALE;
                        }
                    }
                    else {
                        if (M0 !== M1) {
                            ret |= (AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_GENERAL_SCALE);
                        }
                        else if (M0 !== -1.0) {
                            ret |= (AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_UNIFORM_SCALE);
                        }
                        else {
                            ret |= AffineTransform.TYPE_QUADRANT_ROTATION;
                        }
                    }
                }
                else {
                    if (M0 === -M1) {
                        if (M0 === 1.0 || M0 === -1.0) {
                            ret |= AffineTransform.TYPE_FLIP;
                        }
                        else {
                            ret |= (AffineTransform.TYPE_FLIP | AffineTransform.TYPE_UNIFORM_SCALE);
                        }
                    }
                    else {
                        ret |= (AffineTransform.TYPE_FLIP | AffineTransform.TYPE_GENERAL_SCALE);
                    }
                }
                break;
            case (AffineTransform.APPLY_TRANSLATE):
                ret = AffineTransform.TYPE_TRANSLATION;
                break;
            case (AffineTransform.APPLY_IDENTITY):
                break;
        }
        this.type = ret;
    };
    /**
     * Returns the determinant of the matrix representation of the transform.
     * The determinant is useful both to determine if the transform can
     * be inverted and to get a single value representing the
     * combined X and Y scaling of the transform.
     * <p>
     * If the determinant is non-zero, then this transform is
     * invertible and the various methods that depend on the inverse
     * transform do not need to throw a
     * {@link NoninvertibleTransformException}.
     * If the determinant is zero then this transform can not be
     * inverted since the transform maps all input coordinates onto
     * a line or a point.
     * If the determinant is near enough to zero then inverse transform
     * operations might not carry enough precision to produce meaningful
     * results.
     * <p>
     * If this transform represents a uniform scale, as indicated by
     * the <code>getType</code> method then the determinant also
     * represents the square of the uniform scale factor by which all of
     * the points are expanded from or contracted towards the origin.
     * If this transform represents a non-uniform scale or more general
     * transform then the determinant is not likely to represent a
     * value useful for any purpose other than determining if inverse
     * transforms are possible.
     * <p>
     * Mathematically, the determinant is calculated using the formula:
     * <pre>
     * |  m00  m01  m02  |
     * |  m10  m11  m12  |  =  m00 * m11 - m01 * m10
     * |   0    0    1   |
     * </pre>
     *
     * @return {number} the determinant of the matrix used to transform the
     * coordinates.
     * @see #getType
     * @see #createInverse
     * @see #inverseTransform
     * @see #TYPE_UNIFORM_SCALE
     * @since 1.2
     */
    AffineTransform.prototype.getDeterminant = function () {
        switch ((this.state)) {
            default:
                this.stateError();
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                return this.m00 * this.m11 - this.m01 * this.m10;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.APPLY_SHEAR):
                return -(this.m01 * this.m10);
            case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.APPLY_SCALE):
                return this.m00 * this.m11;
            case (AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.APPLY_IDENTITY):
                return 1.0;
        }
    };
    /**
     * Manually recalculates the state of the transform when the matrix
     * changes too much to predict the effects on the state.
     * The following table specifies what the various settings of the
     * state field say about the values of the corresponding matrix
     * element fields.
     * Note that the rules governing the SCALE fields are slightly
     * different depending on whether the SHEAR flag is also set.
     * <pre>
     * SCALE            SHEAR          TRANSLATE
     * m00/m11          m01/m10          m02/m12
     *
     * IDENTITY             1.0              0.0              0.0
     * TRANSLATE (TR)       1.0              0.0          not both 0.0
     * SCALE (SC)       not both 1.0         0.0              0.0
     * TR | SC          not both 1.0         0.0          not both 0.0
     * SHEAR (SH)           0.0          not both 0.0         0.0
     * TR | SH              0.0          not both 0.0     not both 0.0
     * SC | SH          not both 0.0     not both 0.0         0.0
     * TR | SC | SH     not both 0.0     not both 0.0     not both 0.0
     * </pre>
     */
    AffineTransform.prototype.updateState = function () {
        if (this.m01 === 0.0 && this.m10 === 0.0) {
            if (this.m00 === 1.0 && this.m11 === 1.0) {
                if (this.m02 === 0.0 && this.m12 === 0.0) {
                    this.state = AffineTransform.APPLY_IDENTITY;
                    this.type = AffineTransform.TYPE_IDENTITY;
                }
                else {
                    this.state = AffineTransform.APPLY_TRANSLATE;
                    this.type = AffineTransform.TYPE_TRANSLATION;
                }
            }
            else {
                if (this.m02 === 0.0 && this.m12 === 0.0) {
                    this.state = AffineTransform.APPLY_SCALE;
                    this.type = AffineTransform.TYPE_UNKNOWN;
                }
                else {
                    this.state = (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE);
                    this.type = AffineTransform.TYPE_UNKNOWN;
                }
            }
        }
        else {
            if (this.m00 === 0.0 && this.m11 === 0.0) {
                if (this.m02 === 0.0 && this.m12 === 0.0) {
                    this.state = AffineTransform.APPLY_SHEAR;
                    this.type = AffineTransform.TYPE_UNKNOWN;
                }
                else {
                    this.state = (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE);
                    this.type = AffineTransform.TYPE_UNKNOWN;
                }
            }
            else {
                if (this.m02 === 0.0 && this.m12 === 0.0) {
                    this.state = (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE);
                    this.type = AffineTransform.TYPE_UNKNOWN;
                }
                else {
                    this.state = (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE);
                    this.type = AffineTransform.TYPE_UNKNOWN;
                }
            }
        }
    };
    AffineTransform.prototype.stateError = function () {
        throw Object.defineProperty(new Error("missing case in transform state switch"), '__class', { configurable: true, value: 'java.lang.InternalError' });
    };
    /**
     * Retrieves the 6 specifiable values in the 3x3 affine transformation
     * matrix and places them into an array of double precisions values.
     * The values are stored in the array as
     * {&nbsp;m00&nbsp;m10&nbsp;m01&nbsp;m11&nbsp;m02&nbsp;m12&nbsp;}.
     * An array of 4 doubles can also be specified, in which case only the
     * first four elements representing the non-transform
     * parts of the array are retrieved and the values are stored into
     * the array as {&nbsp;m00&nbsp;m10&nbsp;m01&nbsp;m11&nbsp;}
     * @param {Array} flatmatrix the double array used to store the returned
     * values.
     * @see #getScaleX
     * @see #getScaleY
     * @see #getShearX
     * @see #getShearY
     * @see #getTranslateX
     * @see #getTranslateY
     * @since 1.2
     */
    AffineTransform.prototype.getMatrix = function (flatmatrix) {
        flatmatrix[0] = this.m00;
        flatmatrix[1] = this.m10;
        flatmatrix[2] = this.m01;
        flatmatrix[3] = this.m11;
        if (flatmatrix.length > 5) {
            flatmatrix[4] = this.m02;
            flatmatrix[5] = this.m12;
        }
    };
    /**
     * Returns the X coordinate scaling element (m00) of the 3x3
     * affine transformation matrix.
     * @return {number} a double value that is the X coordinate of the scaling
     * element of the affine transformation matrix.
     * @see #getMatrix
     * @since 1.2
     */
    AffineTransform.prototype.getScaleX = function () {
        return this.m00;
    };
    /**
     * Returns the Y coordinate scaling element (m11) of the 3x3
     * affine transformation matrix.
     * @return {number} a double value that is the Y coordinate of the scaling
     * element of the affine transformation matrix.
     * @see #getMatrix
     * @since 1.2
     */
    AffineTransform.prototype.getScaleY = function () {
        return this.m11;
    };
    /**
     * Returns the X coordinate shearing element (m01) of the 3x3
     * affine transformation matrix.
     * @return {number} a double value that is the X coordinate of the shearing
     * element of the affine transformation matrix.
     * @see #getMatrix
     * @since 1.2
     */
    AffineTransform.prototype.getShearX = function () {
        return this.m01;
    };
    /**
     * Returns the Y coordinate shearing element (m10) of the 3x3
     * affine transformation matrix.
     * @return {number} a double value that is the Y coordinate of the shearing
     * element of the affine transformation matrix.
     * @see #getMatrix
     * @since 1.2
     */
    AffineTransform.prototype.getShearY = function () {
        return this.m10;
    };
    /**
     * Returns the X coordinate of the translation element (m02) of the
     * 3x3 affine transformation matrix.
     * @return {number} a double value that is the X coordinate of the translation
     * element of the affine transformation matrix.
     * @see #getMatrix
     * @since 1.2
     */
    AffineTransform.prototype.getTranslateX = function () {
        return this.m02;
    };
    /**
     * Returns the Y coordinate of the translation element (m12) of the
     * 3x3 affine transformation matrix.
     * @return {number} a double value that is the Y coordinate of the translation
     * element of the affine transformation matrix.
     * @see #getMatrix
     * @since 1.2
     */
    AffineTransform.prototype.getTranslateY = function () {
        return this.m12;
    };
    /**
     * Concatenates this transform with a translation transformation.
     * This is equivalent to calling concatenate(T), where T is an
     * <code>AffineTransform</code> represented by the following matrix:
     * <pre>
     * [   1    0    tx  ]
     * [   0    1    ty  ]
     * [   0    0    1   ]
     * </pre>
     * @param {number} tx the distance by which coordinates are translated in the
     * X axis direction
     * @param {number} ty the distance by which coordinates are translated in the
     * Y axis direction
     * @since 1.2
     */
    AffineTransform.prototype.translate = function (tx, ty) {
        switch ((this.state)) {
            default:
                this.stateError();
                return;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                this.m02 = tx * this.m00 + ty * this.m01 + this.m02;
                this.m12 = tx * this.m10 + ty * this.m11 + this.m12;
                if (this.m02 === 0.0 && this.m12 === 0.0) {
                    this.state = AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE;
                    if (this.type !== AffineTransform.TYPE_UNKNOWN) {
                        this.type -= AffineTransform.TYPE_TRANSLATION;
                    }
                }
                return;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                this.m02 = tx * this.m00 + ty * this.m01;
                this.m12 = tx * this.m10 + ty * this.m11;
                if (this.m02 !== 0.0 || this.m12 !== 0.0) {
                    this.state = AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE;
                    this.type |= AffineTransform.TYPE_TRANSLATION;
                }
                return;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                this.m02 = ty * this.m01 + this.m02;
                this.m12 = tx * this.m10 + this.m12;
                if (this.m02 === 0.0 && this.m12 === 0.0) {
                    this.state = AffineTransform.APPLY_SHEAR;
                    if (this.type !== AffineTransform.TYPE_UNKNOWN) {
                        this.type -= AffineTransform.TYPE_TRANSLATION;
                    }
                }
                return;
            case (AffineTransform.APPLY_SHEAR):
                this.m02 = ty * this.m01;
                this.m12 = tx * this.m10;
                if (this.m02 !== 0.0 || this.m12 !== 0.0) {
                    this.state = AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE;
                    this.type |= AffineTransform.TYPE_TRANSLATION;
                }
                return;
            case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                this.m02 = tx * this.m00 + this.m02;
                this.m12 = ty * this.m11 + this.m12;
                if (this.m02 === 0.0 && this.m12 === 0.0) {
                    this.state = AffineTransform.APPLY_SCALE;
                    if (this.type !== AffineTransform.TYPE_UNKNOWN) {
                        this.type -= AffineTransform.TYPE_TRANSLATION;
                    }
                }
                return;
            case (AffineTransform.APPLY_SCALE):
                this.m02 = tx * this.m00;
                this.m12 = ty * this.m11;
                if (this.m02 !== 0.0 || this.m12 !== 0.0) {
                    this.state = AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE;
                    this.type |= AffineTransform.TYPE_TRANSLATION;
                }
                return;
            case (AffineTransform.APPLY_TRANSLATE):
                this.m02 = tx + this.m02;
                this.m12 = ty + this.m12;
                if (this.m02 === 0.0 && this.m12 === 0.0) {
                    this.state = AffineTransform.APPLY_IDENTITY;
                    this.type = AffineTransform.TYPE_IDENTITY;
                }
                return;
            case (AffineTransform.APPLY_IDENTITY):
                this.m02 = tx;
                this.m12 = ty;
                if (tx !== 0.0 || ty !== 0.0) {
                    this.state = AffineTransform.APPLY_TRANSLATE;
                    this.type = AffineTransform.TYPE_TRANSLATION;
                }
                return;
        }
    };
    AffineTransform.rot90conversion_$LI$ = function () { if (AffineTransform.rot90conversion == null)
        AffineTransform.rot90conversion = [AffineTransform.APPLY_SHEAR, AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE, AffineTransform.APPLY_SHEAR, AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE, AffineTransform.APPLY_SCALE, AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE, AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE, AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE]; return AffineTransform.rot90conversion; };
    ;
    AffineTransform.prototype.rotate90 = function () {
        var M0 = this.m00;
        this.m00 = this.m01;
        this.m01 = -M0;
        M0 = this.m10;
        this.m10 = this.m11;
        this.m11 = -M0;
        var state = AffineTransform.rot90conversion_$LI$()[this.state];
        if ((state & (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE)) === AffineTransform.APPLY_SCALE && this.m00 === 1.0 && this.m11 === 1.0) {
            state -= AffineTransform.APPLY_SCALE;
        }
        this.state = state;
        this.type = AffineTransform.TYPE_UNKNOWN;
    };
    AffineTransform.prototype.rotate180 = function () {
        this.m00 = -this.m00;
        this.m11 = -this.m11;
        var state = this.state;
        if ((state & (AffineTransform.APPLY_SHEAR)) !== 0) {
            this.m01 = -this.m01;
            this.m10 = -this.m10;
        }
        else {
            if (this.m00 === 1.0 && this.m11 === 1.0) {
                this.state = state & ~AffineTransform.APPLY_SCALE;
            }
            else {
                this.state = state | AffineTransform.APPLY_SCALE;
            }
        }
        this.type = AffineTransform.TYPE_UNKNOWN;
    };
    AffineTransform.prototype.rotate270 = function () {
        var M0 = this.m00;
        this.m00 = -this.m01;
        this.m01 = M0;
        M0 = this.m10;
        this.m10 = -this.m11;
        this.m11 = M0;
        var state = AffineTransform.rot90conversion_$LI$()[this.state];
        if ((state & (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE)) === AffineTransform.APPLY_SCALE && this.m00 === 1.0 && this.m11 === 1.0) {
            state -= AffineTransform.APPLY_SCALE;
        }
        this.state = state;
        this.type = AffineTransform.TYPE_UNKNOWN;
    };
    /**
     * Concatenates this transform with a rotation transformation.
     * This is equivalent to calling concatenate(R), where R is an
     * <code>AffineTransform</code> represented by the following matrix:
     * <pre>
     * [   cos(theta)    -sin(theta)    0   ]
     * [   sin(theta)     cos(theta)    0   ]
     * [       0              0         1   ]
     * </pre>
     * Rotating by a positive angle theta rotates points on the positive
     * X axis toward the positive Y axis.
     * Note also the discussion of
     * <a href="#quadrantapproximation">Handling 90-Degree Rotations</a>
     * above.
     * @param {number} theta the angle of rotation measured in radians
     * @since 1.2
     */
    AffineTransform.prototype.rotate$double = function (theta) {
        var sin = Math.sin(theta);
        if (sin === 1.0) {
            this.rotate90();
        }
        else if (sin === -1.0) {
            this.rotate270();
        }
        else {
            var cos = Math.cos(theta);
            if (cos === -1.0) {
                this.rotate180();
            }
            else if (cos !== 1.0) {
                var M0 = void 0;
                var M1 = void 0;
                M0 = this.m00;
                M1 = this.m01;
                this.m00 = cos * M0 + sin * M1;
                this.m01 = -sin * M0 + cos * M1;
                M0 = this.m10;
                M1 = this.m11;
                this.m10 = cos * M0 + sin * M1;
                this.m11 = -sin * M0 + cos * M1;
                this.updateState();
            }
        }
    };
    /**
     * Concatenates this transform with a transform that rotates
     * coordinates around an anchor point.
     * This operation is equivalent to translating the coordinates so
     * that the anchor point is at the origin (S1), then rotating them
     * about the new origin (S2), and finally translating so that the
     * intermediate origin is restored to the coordinates of the original
     * anchor point (S3).
     * <p>
     * This operation is equivalent to the following sequence of calls:
     * <pre>
     * translate(anchorx, anchory);      // S3: final translation
     * rotate(theta);                    // S2: rotate around anchor
     * translate(-anchorx, -anchory);    // S1: translate anchor to origin
     * </pre>
     * Rotating by a positive angle theta rotates points on the positive
     * X axis toward the positive Y axis.
     * Note also the discussion of
     * <a href="#quadrantapproximation">Handling 90-Degree Rotations</a>
     * above.
     *
     * @param {number} theta the angle of rotation measured in radians
     * @param {number} anchorx the X coordinate of the rotation anchor point
     * @param {number} anchory the Y coordinate of the rotation anchor point
     * @since 1.2
     */
    AffineTransform.prototype.rotate$double$double$double = function (theta, anchorx, anchory) {
        this.translate(anchorx, anchory);
        this.rotate$double(theta);
        this.translate(-anchorx, -anchory);
    };
    /**
     * Concatenates this transform with a transform that rotates
     * coordinates according to a rotation vector.
     * All coordinates rotate about the origin by the same amount.
     * The amount of rotation is such that coordinates along the former
     * positive X axis will subsequently align with the vector pointing
     * from the origin to the specified vector coordinates.
     * If both <code>vecx</code> and <code>vecy</code> are 0.0,
     * no additional rotation is added to this transform.
     * This operation is equivalent to calling:
     * <pre>
     * rotate(Math.atan2(vecy, vecx));
     * </pre>
     *
     * @param {number} vecx the X coordinate of the rotation vector
     * @param {number} vecy the Y coordinate of the rotation vector
     * @since 1.6
     */
    AffineTransform.prototype.rotate$double$double = function (vecx, vecy) {
        if (vecy === 0.0) {
            if (vecx < 0.0) {
                this.rotate180();
            }
        }
        else if (vecx === 0.0) {
            if (vecy > 0.0) {
                this.rotate90();
            }
            else {
                this.rotate270();
            }
        }
        else {
            var len = Math.sqrt(vecx * vecx + vecy * vecy);
            var sin = vecy / len;
            var cos = vecx / len;
            var M0 = void 0;
            var M1 = void 0;
            M0 = this.m00;
            M1 = this.m01;
            this.m00 = cos * M0 + sin * M1;
            this.m01 = -sin * M0 + cos * M1;
            M0 = this.m10;
            M1 = this.m11;
            this.m10 = cos * M0 + sin * M1;
            this.m11 = -sin * M0 + cos * M1;
            this.updateState();
        }
    };
    /**
     * Concatenates this transform with a transform that rotates
     * coordinates around an anchor point according to a rotation
     * vector.
     * All coordinates rotate about the specified anchor coordinates
     * by the same amount.
     * The amount of rotation is such that coordinates along the former
     * positive X axis will subsequently align with the vector pointing
     * from the origin to the specified vector coordinates.
     * If both <code>vecx</code> and <code>vecy</code> are 0.0,
     * the transform is not modified in any way.
     * This method is equivalent to calling:
     * <pre>
     * rotate(Math.atan2(vecy, vecx), anchorx, anchory);
     * </pre>
     *
     * @param {number} vecx the X coordinate of the rotation vector
     * @param {number} vecy the Y coordinate of the rotation vector
     * @param {number} anchorx the X coordinate of the rotation anchor point
     * @param {number} anchory the Y coordinate of the rotation anchor point
     * @since 1.6
     */
    AffineTransform.prototype.rotate$double$double$double$double = function (vecx, vecy, anchorx, anchory) {
        this.translate(anchorx, anchory);
        this.rotate$double$double(vecx, vecy);
        this.translate(-anchorx, -anchory);
    };
    /**
     * Concatenates this transform with a transform that rotates
     * coordinates around an anchor point according to a rotation
     * vector.
     * All coordinates rotate about the specified anchor coordinates
     * by the same amount.
     * The amount of rotation is such that coordinates along the former
     * positive X axis will subsequently align with the vector pointing
     * from the origin to the specified vector coordinates.
     * If both <code>vecx</code> and <code>vecy</code> are 0.0,
     * the transform is not modified in any way.
     * This method is equivalent to calling:
     * <pre>
     * rotate(Math.atan2(vecy, vecx), anchorx, anchory);
     * </pre>
     *
     * @param {number} vecx the X coordinate of the rotation vector
     * @param {number} vecy the Y coordinate of the rotation vector
     * @param {number} anchorx the X coordinate of the rotation anchor point
     * @param {number} anchory the Y coordinate of the rotation anchor point
     * @since 1.6
     */
    AffineTransform.prototype.rotate = function (vecx, vecy, anchorx, anchory) {
        if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && ((typeof anchorx === 'number') || anchorx === null) && ((typeof anchory === 'number') || anchory === null)) {
            return this.rotate$double$double$double$double(vecx, vecy, anchorx, anchory);
        }
        else if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && ((typeof anchorx === 'number') || anchorx === null) && anchory === undefined) {
            return this.rotate$double$double$double(vecx, vecy, anchorx);
        }
        else if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && anchorx === undefined && anchory === undefined) {
            return this.rotate$double$double(vecx, vecy);
        }
        else if (((typeof vecx === 'number') || vecx === null) && vecy === undefined && anchorx === undefined && anchory === undefined) {
            return this.rotate$double(vecx);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Concatenates this transform with a transform that rotates
     * coordinates by the specified number of quadrants.
     * This is equivalent to calling:
     * <pre>
     * rotate(numquadrants * Math.PI / 2.0);
     * </pre>
     * Rotating by a positive number of quadrants rotates points on
     * the positive X axis toward the positive Y axis.
     * @param {number} numquadrants the number of 90 degree arcs to rotate by
     * @since 1.6
     */
    AffineTransform.prototype.quadrantRotate$int = function (numquadrants) {
        switch ((numquadrants & 3)) {
            case 0:
                break;
            case 1:
                this.rotate90();
                break;
            case 2:
                this.rotate180();
                break;
            case 3:
                this.rotate270();
                break;
        }
    };
    /**
     * Concatenates this transform with a transform that rotates
     * coordinates by the specified number of quadrants around
     * the specified anchor point.
     * This method is equivalent to calling:
     * <pre>
     * rotate(numquadrants * Math.PI / 2.0, anchorx, anchory);
     * </pre>
     * Rotating by a positive number of quadrants rotates points on
     * the positive X axis toward the positive Y axis.
     *
     * @param {number} numquadrants the number of 90 degree arcs to rotate by
     * @param {number} anchorx the X coordinate of the rotation anchor point
     * @param {number} anchory the Y coordinate of the rotation anchor point
     * @since 1.6
     */
    AffineTransform.prototype.quadrantRotate$int$double$double = function (numquadrants, anchorx, anchory) {
        switch ((numquadrants & 3)) {
            case 0:
                return;
            case 1:
                this.m02 += anchorx * (this.m00 - this.m01) + anchory * (this.m01 + this.m00);
                this.m12 += anchorx * (this.m10 - this.m11) + anchory * (this.m11 + this.m10);
                this.rotate90();
                break;
            case 2:
                this.m02 += anchorx * (this.m00 + this.m00) + anchory * (this.m01 + this.m01);
                this.m12 += anchorx * (this.m10 + this.m10) + anchory * (this.m11 + this.m11);
                this.rotate180();
                break;
            case 3:
                this.m02 += anchorx * (this.m00 + this.m01) + anchory * (this.m01 - this.m00);
                this.m12 += anchorx * (this.m10 + this.m11) + anchory * (this.m11 - this.m10);
                this.rotate270();
                break;
        }
        if (this.m02 === 0.0 && this.m12 === 0.0) {
            this.state &= ~AffineTransform.APPLY_TRANSLATE;
        }
        else {
            this.state |= AffineTransform.APPLY_TRANSLATE;
        }
    };
    /**
     * Concatenates this transform with a transform that rotates
     * coordinates by the specified number of quadrants around
     * the specified anchor point.
     * This method is equivalent to calling:
     * <pre>
     * rotate(numquadrants * Math.PI / 2.0, anchorx, anchory);
     * </pre>
     * Rotating by a positive number of quadrants rotates points on
     * the positive X axis toward the positive Y axis.
     *
     * @param {number} numquadrants the number of 90 degree arcs to rotate by
     * @param {number} anchorx the X coordinate of the rotation anchor point
     * @param {number} anchory the Y coordinate of the rotation anchor point
     * @since 1.6
     */
    AffineTransform.prototype.quadrantRotate = function (numquadrants, anchorx, anchory) {
        if (((typeof numquadrants === 'number') || numquadrants === null) && ((typeof anchorx === 'number') || anchorx === null) && ((typeof anchory === 'number') || anchory === null)) {
            return this.quadrantRotate$int$double$double(numquadrants, anchorx, anchory);
        }
        else if (((typeof numquadrants === 'number') || numquadrants === null) && anchorx === undefined && anchory === undefined) {
            return this.quadrantRotate$int(numquadrants);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Concatenates this transform with a scaling transformation.
     * This is equivalent to calling concatenate(S), where S is an
     * <code>AffineTransform</code> represented by the following matrix:
     * <pre>
     * [   sx   0    0   ]
     * [   0    sy   0   ]
     * [   0    0    1   ]
     * </pre>
     * @param {number} sx the factor by which coordinates are scaled along the
     * X axis direction
     * @param {number} sy the factor by which coordinates are scaled along the
     * Y axis direction
     * @since 1.2
     */
    AffineTransform.prototype.scale = function (sx, sy) {
        var state = this.state;
        switch ((state)) {
            default:
                this.stateError();
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                this.m00 *= sx;
                this.m11 *= sy;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.APPLY_SHEAR):
                this.m01 *= sy;
                this.m10 *= sx;
                if (this.m01 === 0 && this.m10 === 0) {
                    state &= AffineTransform.APPLY_TRANSLATE;
                    if (this.m00 === 1.0 && this.m11 === 1.0) {
                        this.type = (state === AffineTransform.APPLY_IDENTITY ? AffineTransform.TYPE_IDENTITY : AffineTransform.TYPE_TRANSLATION);
                    }
                    else {
                        state |= AffineTransform.APPLY_SCALE;
                        this.type = AffineTransform.TYPE_UNKNOWN;
                    }
                    this.state = state;
                }
                return;
            case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.APPLY_SCALE):
                this.m00 *= sx;
                this.m11 *= sy;
                if (this.m00 === 1.0 && this.m11 === 1.0) {
                    this.state = (state &= AffineTransform.APPLY_TRANSLATE);
                    this.type = (state === AffineTransform.APPLY_IDENTITY ? AffineTransform.TYPE_IDENTITY : AffineTransform.TYPE_TRANSLATION);
                }
                else {
                    this.type = AffineTransform.TYPE_UNKNOWN;
                }
                return;
            case (AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.APPLY_IDENTITY):
                this.m00 = sx;
                this.m11 = sy;
                if (sx !== 1.0 || sy !== 1.0) {
                    this.state = state | AffineTransform.APPLY_SCALE;
                    this.type = AffineTransform.TYPE_UNKNOWN;
                }
                return;
        }
    };
    /**
     * Concatenates this transform with a shearing transformation.
     * This is equivalent to calling concatenate(SH), where SH is an
     * <code>AffineTransform</code> represented by the following matrix:
     * <pre>
     * [   1   shx   0   ]
     * [  shy   1    0   ]
     * [   0    0    1   ]
     * </pre>
     * @param {number} shx the multiplier by which coordinates are shifted in the
     * direction of the positive X axis as a factor of their Y coordinate
     * @param {number} shy the multiplier by which coordinates are shifted in the
     * direction of the positive Y axis as a factor of their X coordinate
     * @since 1.2
     */
    AffineTransform.prototype.shear = function (shx, shy) {
        var state = this.state;
        switch ((state)) {
            default:
                this.stateError();
                return;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                var M0 = void 0;
                var M1 = void 0;
                M0 = this.m00;
                M1 = this.m01;
                this.m00 = M0 + M1 * shy;
                this.m01 = M0 * shx + M1;
                M0 = this.m10;
                M1 = this.m11;
                this.m10 = M0 + M1 * shy;
                this.m11 = M0 * shx + M1;
                this.updateState();
                return;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.APPLY_SHEAR):
                this.m00 = this.m01 * shy;
                this.m11 = this.m10 * shx;
                if (this.m00 !== 0.0 || this.m11 !== 0.0) {
                    this.state = state | AffineTransform.APPLY_SCALE;
                }
                this.type = AffineTransform.TYPE_UNKNOWN;
                return;
            case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.APPLY_SCALE):
                this.m01 = this.m00 * shx;
                this.m10 = this.m11 * shy;
                if (this.m01 !== 0.0 || this.m10 !== 0.0) {
                    this.state = state | AffineTransform.APPLY_SHEAR;
                }
                this.type = AffineTransform.TYPE_UNKNOWN;
                return;
            case (AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.APPLY_IDENTITY):
                this.m01 = shx;
                this.m10 = shy;
                if (this.m01 !== 0.0 || this.m10 !== 0.0) {
                    this.state = state | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_SHEAR;
                    this.type = AffineTransform.TYPE_UNKNOWN;
                }
                return;
        }
    };
    /**
     * Resets this transform to the Identity transform.
     * @since 1.2
     */
    AffineTransform.prototype.setToIdentity = function () {
        this.m00 = this.m11 = 1.0;
        this.m10 = this.m01 = this.m02 = this.m12 = 0.0;
        this.state = AffineTransform.APPLY_IDENTITY;
        this.type = AffineTransform.TYPE_IDENTITY;
    };
    /**
     * Sets this transform to a translation transformation.
     * The matrix representing this transform becomes:
     * <pre>
     * [   1    0    tx  ]
     * [   0    1    ty  ]
     * [   0    0    1   ]
     * </pre>
     * @param {number} tx the distance by which coordinates are translated in the
     * X axis direction
     * @param {number} ty the distance by which coordinates are translated in the
     * Y axis direction
     * @since 1.2
     */
    AffineTransform.prototype.setToTranslation = function (tx, ty) {
        this.m00 = 1.0;
        this.m10 = 0.0;
        this.m01 = 0.0;
        this.m11 = 1.0;
        this.m02 = tx;
        this.m12 = ty;
        if (tx !== 0.0 || ty !== 0.0) {
            this.state = AffineTransform.APPLY_TRANSLATE;
            this.type = AffineTransform.TYPE_TRANSLATION;
        }
        else {
            this.state = AffineTransform.APPLY_IDENTITY;
            this.type = AffineTransform.TYPE_IDENTITY;
        }
    };
    /**
     * Sets this transform to a rotation transformation.
     * The matrix representing this transform becomes:
     * <pre>
     * [   cos(theta)    -sin(theta)    0   ]
     * [   sin(theta)     cos(theta)    0   ]
     * [       0              0         1   ]
     * </pre>
     * Rotating by a positive angle theta rotates points on the positive
     * X axis toward the positive Y axis.
     * Note also the discussion of
     * <a href="#quadrantapproximation">Handling 90-Degree Rotations</a>
     * above.
     * @param {number} theta the angle of rotation measured in radians
     * @since 1.2
     */
    AffineTransform.prototype.setToRotation$double = function (theta) {
        var sin = Math.sin(theta);
        var cos;
        if (sin === 1.0 || sin === -1.0) {
            cos = 0.0;
            this.state = AffineTransform.APPLY_SHEAR;
            this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
        }
        else {
            cos = Math.cos(theta);
            if (cos === -1.0) {
                sin = 0.0;
                this.state = AffineTransform.APPLY_SCALE;
                this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
            }
            else if (cos === 1.0) {
                sin = 0.0;
                this.state = AffineTransform.APPLY_IDENTITY;
                this.type = AffineTransform.TYPE_IDENTITY;
            }
            else {
                this.state = AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE;
                this.type = AffineTransform.TYPE_GENERAL_ROTATION;
            }
        }
        this.m00 = cos;
        this.m10 = sin;
        this.m01 = -sin;
        this.m11 = cos;
        this.m02 = 0.0;
        this.m12 = 0.0;
    };
    /**
     * Sets this transform to a translated rotation transformation.
     * This operation is equivalent to translating the coordinates so
     * that the anchor point is at the origin (S1), then rotating them
     * about the new origin (S2), and finally translating so that the
     * intermediate origin is restored to the coordinates of the original
     * anchor point (S3).
     * <p>
     * This operation is equivalent to the following sequence of calls:
     * <pre>
     * setToTranslation(anchorx, anchory); // S3: final translation
     * rotate(theta);                      // S2: rotate around anchor
     * translate(-anchorx, -anchory);      // S1: translate anchor to origin
     * </pre>
     * The matrix representing this transform becomes:
     * <pre>
     * [   cos(theta)    -sin(theta)    x-x*cos+y*sin  ]
     * [   sin(theta)     cos(theta)    y-x*sin-y*cos  ]
     * [       0              0               1        ]
     * </pre>
     * Rotating by a positive angle theta rotates points on the positive
     * X axis toward the positive Y axis.
     * Note also the discussion of
     * <a href="#quadrantapproximation">Handling 90-Degree Rotations</a>
     * above.
     *
     * @param {number} theta the angle of rotation measured in radians
     * @param {number} anchorx the X coordinate of the rotation anchor point
     * @param {number} anchory the Y coordinate of the rotation anchor point
     * @since 1.2
     */
    AffineTransform.prototype.setToRotation$double$double$double = function (theta, anchorx, anchory) {
        this.setToRotation$double(theta);
        var sin = this.m10;
        var oneMinusCos = 1.0 - this.m00;
        this.m02 = anchorx * oneMinusCos + anchory * sin;
        this.m12 = anchory * oneMinusCos - anchorx * sin;
        if (this.m02 !== 0.0 || this.m12 !== 0.0) {
            this.state |= AffineTransform.APPLY_TRANSLATE;
            this.type |= AffineTransform.TYPE_TRANSLATION;
        }
    };
    /**
     * Sets this transform to a rotation transformation that rotates
     * coordinates according to a rotation vector.
     * All coordinates rotate about the origin by the same amount.
     * The amount of rotation is such that coordinates along the former
     * positive X axis will subsequently align with the vector pointing
     * from the origin to the specified vector coordinates.
     * If both <code>vecx</code> and <code>vecy</code> are 0.0,
     * the transform is set to an identity transform.
     * This operation is equivalent to calling:
     * <pre>
     * setToRotation(Math.atan2(vecy, vecx));
     * </pre>
     *
     * @param {number} vecx the X coordinate of the rotation vector
     * @param {number} vecy the Y coordinate of the rotation vector
     * @since 1.6
     */
    AffineTransform.prototype.setToRotation$double$double = function (vecx, vecy) {
        var sin;
        var cos;
        if (vecy === 0) {
            sin = 0.0;
            if (vecx < 0.0) {
                cos = -1.0;
                this.state = AffineTransform.APPLY_SCALE;
                this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
            }
            else {
                cos = 1.0;
                this.state = AffineTransform.APPLY_IDENTITY;
                this.type = AffineTransform.TYPE_IDENTITY;
            }
        }
        else if (vecx === 0) {
            cos = 0.0;
            sin = (vecy > 0.0) ? 1.0 : -1.0;
            this.state = AffineTransform.APPLY_SHEAR;
            this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
        }
        else {
            var len = Math.sqrt(vecx * vecx + vecy * vecy);
            cos = vecx / len;
            sin = vecy / len;
            this.state = AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE;
            this.type = AffineTransform.TYPE_GENERAL_ROTATION;
        }
        this.m00 = cos;
        this.m10 = sin;
        this.m01 = -sin;
        this.m11 = cos;
        this.m02 = 0.0;
        this.m12 = 0.0;
    };
    /**
     * Sets this transform to a rotation transformation that rotates
     * coordinates around an anchor point according to a rotation
     * vector.
     * All coordinates rotate about the specified anchor coordinates
     * by the same amount.
     * The amount of rotation is such that coordinates along the former
     * positive X axis will subsequently align with the vector pointing
     * from the origin to the specified vector coordinates.
     * If both <code>vecx</code> and <code>vecy</code> are 0.0,
     * the transform is set to an identity transform.
     * This operation is equivalent to calling:
     * <pre>
     * setToTranslation(Math.atan2(vecy, vecx), anchorx, anchory);
     * </pre>
     *
     * @param {number} vecx the X coordinate of the rotation vector
     * @param {number} vecy the Y coordinate of the rotation vector
     * @param {number} anchorx the X coordinate of the rotation anchor point
     * @param {number} anchory the Y coordinate of the rotation anchor point
     * @since 1.6
     */
    AffineTransform.prototype.setToRotation$double$double$double$double = function (vecx, vecy, anchorx, anchory) {
        this.setToRotation$double$double(vecx, vecy);
        var sin = this.m10;
        var oneMinusCos = 1.0 - this.m00;
        this.m02 = anchorx * oneMinusCos + anchory * sin;
        this.m12 = anchory * oneMinusCos - anchorx * sin;
        if (this.m02 !== 0.0 || this.m12 !== 0.0) {
            this.state |= AffineTransform.APPLY_TRANSLATE;
            this.type |= AffineTransform.TYPE_TRANSLATION;
        }
    };
    /**
     * Sets this transform to a rotation transformation that rotates
     * coordinates around an anchor point according to a rotation
     * vector.
     * All coordinates rotate about the specified anchor coordinates
     * by the same amount.
     * The amount of rotation is such that coordinates along the former
     * positive X axis will subsequently align with the vector pointing
     * from the origin to the specified vector coordinates.
     * If both <code>vecx</code> and <code>vecy</code> are 0.0,
     * the transform is set to an identity transform.
     * This operation is equivalent to calling:
     * <pre>
     * setToTranslation(Math.atan2(vecy, vecx), anchorx, anchory);
     * </pre>
     *
     * @param {number} vecx the X coordinate of the rotation vector
     * @param {number} vecy the Y coordinate of the rotation vector
     * @param {number} anchorx the X coordinate of the rotation anchor point
     * @param {number} anchory the Y coordinate of the rotation anchor point
     * @since 1.6
     */
    AffineTransform.prototype.setToRotation = function (vecx, vecy, anchorx, anchory) {
        if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && ((typeof anchorx === 'number') || anchorx === null) && ((typeof anchory === 'number') || anchory === null)) {
            return this.setToRotation$double$double$double$double(vecx, vecy, anchorx, anchory);
        }
        else if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && ((typeof anchorx === 'number') || anchorx === null) && anchory === undefined) {
            return this.setToRotation$double$double$double(vecx, vecy, anchorx);
        }
        else if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && anchorx === undefined && anchory === undefined) {
            return this.setToRotation$double$double(vecx, vecy);
        }
        else if (((typeof vecx === 'number') || vecx === null) && vecy === undefined && anchorx === undefined && anchory === undefined) {
            return this.setToRotation$double(vecx);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Sets this transform to a rotation transformation that rotates
     * coordinates by the specified number of quadrants.
     * This operation is equivalent to calling:
     * <pre>
     * setToRotation(numquadrants * Math.PI / 2.0);
     * </pre>
     * Rotating by a positive number of quadrants rotates points on
     * the positive X axis toward the positive Y axis.
     * @param {number} numquadrants the number of 90 degree arcs to rotate by
     * @since 1.6
     */
    AffineTransform.prototype.setToQuadrantRotation$int = function (numquadrants) {
        switch ((numquadrants & 3)) {
            case 0:
                this.m00 = 1.0;
                this.m10 = 0.0;
                this.m01 = 0.0;
                this.m11 = 1.0;
                this.m02 = 0.0;
                this.m12 = 0.0;
                this.state = AffineTransform.APPLY_IDENTITY;
                this.type = AffineTransform.TYPE_IDENTITY;
                break;
            case 1:
                this.m00 = 0.0;
                this.m10 = 1.0;
                this.m01 = -1.0;
                this.m11 = 0.0;
                this.m02 = 0.0;
                this.m12 = 0.0;
                this.state = AffineTransform.APPLY_SHEAR;
                this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                break;
            case 2:
                this.m00 = -1.0;
                this.m10 = 0.0;
                this.m01 = 0.0;
                this.m11 = -1.0;
                this.m02 = 0.0;
                this.m12 = 0.0;
                this.state = AffineTransform.APPLY_SCALE;
                this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                break;
            case 3:
                this.m00 = 0.0;
                this.m10 = -1.0;
                this.m01 = 1.0;
                this.m11 = 0.0;
                this.m02 = 0.0;
                this.m12 = 0.0;
                this.state = AffineTransform.APPLY_SHEAR;
                this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                break;
        }
    };
    /**
     * Sets this transform to a translated rotation transformation
     * that rotates coordinates by the specified number of quadrants
     * around the specified anchor point.
     * This operation is equivalent to calling:
     * <pre>
     * setToRotation(numquadrants * Math.PI / 2.0, anchorx, anchory);
     * </pre>
     * Rotating by a positive number of quadrants rotates points on
     * the positive X axis toward the positive Y axis.
     *
     * @param {number} numquadrants the number of 90 degree arcs to rotate by
     * @param {number} anchorx the X coordinate of the rotation anchor point
     * @param {number} anchory the Y coordinate of the rotation anchor point
     * @since 1.6
     */
    AffineTransform.prototype.setToQuadrantRotation$int$double$double = function (numquadrants, anchorx, anchory) {
        switch ((numquadrants & 3)) {
            case 0:
                this.m00 = 1.0;
                this.m10 = 0.0;
                this.m01 = 0.0;
                this.m11 = 1.0;
                this.m02 = 0.0;
                this.m12 = 0.0;
                this.state = AffineTransform.APPLY_IDENTITY;
                this.type = AffineTransform.TYPE_IDENTITY;
                break;
            case 1:
                this.m00 = 0.0;
                this.m10 = 1.0;
                this.m01 = -1.0;
                this.m11 = 0.0;
                this.m02 = anchorx + anchory;
                this.m12 = anchory - anchorx;
                if (this.m02 === 0.0 && this.m12 === 0.0) {
                    this.state = AffineTransform.APPLY_SHEAR;
                    this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                }
                else {
                    this.state = AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE;
                    this.type = AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_TRANSLATION;
                }
                break;
            case 2:
                this.m00 = -1.0;
                this.m10 = 0.0;
                this.m01 = 0.0;
                this.m11 = -1.0;
                this.m02 = anchorx + anchorx;
                this.m12 = anchory + anchory;
                if (this.m02 === 0.0 && this.m12 === 0.0) {
                    this.state = AffineTransform.APPLY_SCALE;
                    this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                }
                else {
                    this.state = AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE;
                    this.type = AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_TRANSLATION;
                }
                break;
            case 3:
                this.m00 = 0.0;
                this.m10 = -1.0;
                this.m01 = 1.0;
                this.m11 = 0.0;
                this.m02 = anchorx - anchory;
                this.m12 = anchory + anchorx;
                if (this.m02 === 0.0 && this.m12 === 0.0) {
                    this.state = AffineTransform.APPLY_SHEAR;
                    this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                }
                else {
                    this.state = AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE;
                    this.type = AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_TRANSLATION;
                }
                break;
        }
    };
    /**
     * Sets this transform to a translated rotation transformation
     * that rotates coordinates by the specified number of quadrants
     * around the specified anchor point.
     * This operation is equivalent to calling:
     * <pre>
     * setToRotation(numquadrants * Math.PI / 2.0, anchorx, anchory);
     * </pre>
     * Rotating by a positive number of quadrants rotates points on
     * the positive X axis toward the positive Y axis.
     *
     * @param {number} numquadrants the number of 90 degree arcs to rotate by
     * @param {number} anchorx the X coordinate of the rotation anchor point
     * @param {number} anchory the Y coordinate of the rotation anchor point
     * @since 1.6
     */
    AffineTransform.prototype.setToQuadrantRotation = function (numquadrants, anchorx, anchory) {
        if (((typeof numquadrants === 'number') || numquadrants === null) && ((typeof anchorx === 'number') || anchorx === null) && ((typeof anchory === 'number') || anchory === null)) {
            return this.setToQuadrantRotation$int$double$double(numquadrants, anchorx, anchory);
        }
        else if (((typeof numquadrants === 'number') || numquadrants === null) && anchorx === undefined && anchory === undefined) {
            return this.setToQuadrantRotation$int(numquadrants);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Sets this transform to a scaling transformation.
     * The matrix representing this transform becomes:
     * <pre>
     * [   sx   0    0   ]
     * [   0    sy   0   ]
     * [   0    0    1   ]
     * </pre>
     * @param {number} sx the factor by which coordinates are scaled along the
     * X axis direction
     * @param {number} sy the factor by which coordinates are scaled along the
     * Y axis direction
     * @since 1.2
     */
    AffineTransform.prototype.setToScale = function (sx, sy) {
        this.m00 = sx;
        this.m10 = 0.0;
        this.m01 = 0.0;
        this.m11 = sy;
        this.m02 = 0.0;
        this.m12 = 0.0;
        if (sx !== 1.0 || sy !== 1.0) {
            this.state = AffineTransform.APPLY_SCALE;
            this.type = AffineTransform.TYPE_UNKNOWN;
        }
        else {
            this.state = AffineTransform.APPLY_IDENTITY;
            this.type = AffineTransform.TYPE_IDENTITY;
        }
    };
    /**
     * Sets this transform to a shearing transformation.
     * The matrix representing this transform becomes:
     * <pre>
     * [   1   shx   0   ]
     * [  shy   1    0   ]
     * [   0    0    1   ]
     * </pre>
     * @param {number} shx the multiplier by which coordinates are shifted in the
     * direction of the positive X axis as a factor of their Y coordinate
     * @param {number} shy the multiplier by which coordinates are shifted in the
     * direction of the positive Y axis as a factor of their X coordinate
     * @since 1.2
     */
    AffineTransform.prototype.setToShear = function (shx, shy) {
        this.m00 = 1.0;
        this.m01 = shx;
        this.m10 = shy;
        this.m11 = 1.0;
        this.m02 = 0.0;
        this.m12 = 0.0;
        if (shx !== 0.0 || shy !== 0.0) {
            this.state = (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE);
            this.type = AffineTransform.TYPE_UNKNOWN;
        }
        else {
            this.state = AffineTransform.APPLY_IDENTITY;
            this.type = AffineTransform.TYPE_IDENTITY;
        }
    };
    /**
     * Sets this transform to a copy of the transform in the specified
     * <code>AffineTransform</code> object.
     * @param {AffineTransform} Tx the <code>AffineTransform</code> object from which to
     * copy the transform
     * @since 1.2
     */
    AffineTransform.prototype.setTransform$java_awt_geom_AffineTransform = function (Tx) {
        this.m00 = Tx.m00;
        this.m10 = Tx.m10;
        this.m01 = Tx.m01;
        this.m11 = Tx.m11;
        this.m02 = Tx.m02;
        this.m12 = Tx.m12;
        this.state = Tx.state;
        this.type = Tx.type;
    };
    /**
     * Sets this transform to the matrix specified by the 6
     * double precision values.
     *
     * @param {number} m00 the X coordinate scaling element of the 3x3 matrix
     * @param {number} m10 the Y coordinate shearing element of the 3x3 matrix
     * @param {number} m01 the X coordinate shearing element of the 3x3 matrix
     * @param {number} m11 the Y coordinate scaling element of the 3x3 matrix
     * @param {number} m02 the X coordinate translation element of the 3x3 matrix
     * @param {number} m12 the Y coordinate translation element of the 3x3 matrix
     * @since 1.2
     */
    AffineTransform.prototype.setTransform$double$double$double$double$double$double = function (m00, m10, m01, m11, m02, m12) {
        this.m00 = m00;
        this.m10 = m10;
        this.m01 = m01;
        this.m11 = m11;
        this.m02 = m02;
        this.m12 = m12;
        this.updateState();
    };
    /**
     * Sets this transform to the matrix specified by the 6
     * double precision values.
     *
     * @param {number} m00 the X coordinate scaling element of the 3x3 matrix
     * @param {number} m10 the Y coordinate shearing element of the 3x3 matrix
     * @param {number} m01 the X coordinate shearing element of the 3x3 matrix
     * @param {number} m11 the Y coordinate scaling element of the 3x3 matrix
     * @param {number} m02 the X coordinate translation element of the 3x3 matrix
     * @param {number} m12 the Y coordinate translation element of the 3x3 matrix
     * @since 1.2
     */
    AffineTransform.prototype.setTransform = function (m00, m10, m01, m11, m02, m12) {
        if (((typeof m00 === 'number') || m00 === null) && ((typeof m10 === 'number') || m10 === null) && ((typeof m01 === 'number') || m01 === null) && ((typeof m11 === 'number') || m11 === null) && ((typeof m02 === 'number') || m02 === null) && ((typeof m12 === 'number') || m12 === null)) {
            return this.setTransform$double$double$double$double$double$double(m00, m10, m01, m11, m02, m12);
        }
        else if (((m00 != null && m00 instanceof AffineTransform) || m00 === null) && m10 === undefined && m01 === undefined && m11 === undefined && m02 === undefined && m12 === undefined) {
            return this.setTransform$java_awt_geom_AffineTransform(m00);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Concatenates an <code>AffineTransform</code> <code>Tx</code> to
     * this <code>AffineTransform</code> Cx in the most commonly useful
     * way to provide a new user space
     * that is mapped to the former user space by <code>Tx</code>.
     * Cx is updated to perform the combined transformation.
     * Transforming a point p by the updated transform Cx' is
     * equivalent to first transforming p by <code>Tx</code> and then
     * transforming the result by the original transform Cx like this:
     * Cx'(p) = Cx(Tx(p))
     * In matrix notation, if this transform Cx is
     * represented by the matrix [this] and <code>Tx</code> is represented
     * by the matrix [Tx] then this method does the following:
     * <pre>
     * [this] = [this] x [Tx]
     * </pre>
     * @param {AffineTransform} Tx the <code>AffineTransform</code> object to be
     * concatenated with this <code>AffineTransform</code> object.
     * @see #preConcatenate
     * @since 1.2
     */
    AffineTransform.prototype.concatenate = function (Tx) {
        var M0;
        var M1;
        var T00;
        var T01;
        var T10;
        var T11;
        var T02;
        var T12;
        var mystate = this.state;
        var txstate = Tx.state;
        switch (((txstate << AffineTransform.HI_SHIFT) | mystate)) {
            case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_IDENTITY):
            case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SCALE):
            case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR):
            case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
            case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                return;
            case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.HI_SCALE_$LI$() | AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_IDENTITY):
                this.m01 = Tx.m01;
                this.m10 = Tx.m10;
            case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_IDENTITY):
                this.m00 = Tx.m00;
                this.m11 = Tx.m11;
            case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_IDENTITY):
                this.m02 = Tx.m02;
                this.m12 = Tx.m12;
                this.state = txstate;
                this.type = Tx.type;
                return;
            case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_IDENTITY):
                this.m01 = Tx.m01;
                this.m10 = Tx.m10;
            case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_IDENTITY):
                this.m00 = Tx.m00;
                this.m11 = Tx.m11;
                this.state = txstate;
                this.type = Tx.type;
                return;
            case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_IDENTITY):
                this.m02 = Tx.m02;
                this.m12 = Tx.m12;
            case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_IDENTITY):
                this.m01 = Tx.m01;
                this.m10 = Tx.m10;
                this.m00 = this.m11 = 0.0;
                this.state = txstate;
                this.type = Tx.type;
                return;
            case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
            case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR):
            case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SCALE):
            case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_TRANSLATE):
                this.translate(Tx.m02, Tx.m12);
                return;
            case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
            case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR):
            case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SCALE):
            case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_TRANSLATE):
                this.scale(Tx.m00, Tx.m11);
                return;
            case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                T01 = Tx.m01;
                T10 = Tx.m10;
                M0 = this.m00;
                this.m00 = this.m01 * T10;
                this.m01 = M0 * T01;
                M0 = this.m10;
                this.m10 = this.m11 * T10;
                this.m11 = M0 * T01;
                this.type = AffineTransform.TYPE_UNKNOWN;
                return;
            case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR):
                this.m00 = this.m01 * Tx.m10;
                this.m01 = 0.0;
                this.m11 = this.m10 * Tx.m01;
                this.m10 = 0.0;
                this.state = mystate ^ (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE);
                this.type = AffineTransform.TYPE_UNKNOWN;
                return;
            case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SCALE):
                this.m01 = this.m00 * Tx.m01;
                this.m00 = 0.0;
                this.m10 = this.m11 * Tx.m10;
                this.m11 = 0.0;
                this.state = mystate ^ (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE);
                this.type = AffineTransform.TYPE_UNKNOWN;
                return;
            case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_TRANSLATE):
                this.m00 = 0.0;
                this.m01 = Tx.m01;
                this.m10 = Tx.m10;
                this.m11 = 0.0;
                this.state = AffineTransform.APPLY_TRANSLATE | AffineTransform.APPLY_SHEAR;
                this.type = AffineTransform.TYPE_UNKNOWN;
                return;
        }
        T00 = Tx.m00;
        T01 = Tx.m01;
        T02 = Tx.m02;
        T10 = Tx.m10;
        T11 = Tx.m11;
        T12 = Tx.m12;
        switch ((mystate)) {
            default:
                this.stateError();
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                this.state = mystate | txstate;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                M0 = this.m00;
                M1 = this.m01;
                this.m00 = T00 * M0 + T10 * M1;
                this.m01 = T01 * M0 + T11 * M1;
                this.m02 += T02 * M0 + T12 * M1;
                M0 = this.m10;
                M1 = this.m11;
                this.m10 = T00 * M0 + T10 * M1;
                this.m11 = T01 * M0 + T11 * M1;
                this.m12 += T02 * M0 + T12 * M1;
                this.type = AffineTransform.TYPE_UNKNOWN;
                return;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.APPLY_SHEAR):
                M0 = this.m01;
                this.m00 = T10 * M0;
                this.m01 = T11 * M0;
                this.m02 += T12 * M0;
                M0 = this.m10;
                this.m10 = T00 * M0;
                this.m11 = T01 * M0;
                this.m12 += T02 * M0;
                break;
            case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.APPLY_SCALE):
                M0 = this.m00;
                this.m00 = T00 * M0;
                this.m01 = T01 * M0;
                this.m02 += T02 * M0;
                M0 = this.m11;
                this.m10 = T10 * M0;
                this.m11 = T11 * M0;
                this.m12 += T12 * M0;
                break;
            case (AffineTransform.APPLY_TRANSLATE):
                this.m00 = T00;
                this.m01 = T01;
                this.m02 += T02;
                this.m10 = T10;
                this.m11 = T11;
                this.m12 += T12;
                this.state = txstate | AffineTransform.APPLY_TRANSLATE;
                this.type = AffineTransform.TYPE_UNKNOWN;
                return;
        }
        this.updateState();
    };
    /**
     * Concatenates an <code>AffineTransform</code> <code>Tx</code> to
     * this <code>AffineTransform</code> Cx
     * in a less commonly used way such that <code>Tx</code> modifies the
     * coordinate transformation relative to the absolute pixel
     * space rather than relative to the existing user space.
     * Cx is updated to perform the combined transformation.
     * Transforming a point p by the updated transform Cx' is
     * equivalent to first transforming p by the original transform
     * Cx and then transforming the result by
     * <code>Tx</code> like this:
     * Cx'(p) = Tx(Cx(p))
     * In matrix notation, if this transform Cx
     * is represented by the matrix [this] and <code>Tx</code> is
     * represented by the matrix [Tx] then this method does the
     * following:
     * <pre>
     * [this] = [Tx] x [this]
     * </pre>
     * @param {AffineTransform} Tx the <code>AffineTransform</code> object to be
     * concatenated with this <code>AffineTransform</code> object.
     * @see #concatenate
     * @since 1.2
     */
    AffineTransform.prototype.preConcatenate = function (Tx) {
        var M0;
        var M1;
        var T00;
        var T01;
        var T10;
        var T11;
        var T02;
        var T12;
        var mystate = this.state;
        var txstate = Tx.state;
        switch (((txstate << AffineTransform.HI_SHIFT) | mystate)) {
            case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_IDENTITY):
            case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SCALE):
            case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR):
            case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
            case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                return;
            case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_IDENTITY):
            case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SCALE):
            case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR):
            case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                this.m02 = Tx.m02;
                this.m12 = Tx.m12;
                this.state = mystate | AffineTransform.APPLY_TRANSLATE;
                this.type |= AffineTransform.TYPE_TRANSLATION;
                return;
            case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                this.m02 = this.m02 + Tx.m02;
                this.m12 = this.m12 + Tx.m12;
                return;
            case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_IDENTITY):
                this.state = mystate | AffineTransform.APPLY_SCALE;
            case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
            case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR):
            case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SCALE):
                T00 = Tx.m00;
                T11 = Tx.m11;
                if ((mystate & AffineTransform.APPLY_SHEAR) !== 0) {
                    this.m01 = this.m01 * T00;
                    this.m10 = this.m10 * T11;
                    if ((mystate & AffineTransform.APPLY_SCALE) !== 0) {
                        this.m00 = this.m00 * T00;
                        this.m11 = this.m11 * T11;
                    }
                }
                else {
                    this.m00 = this.m00 * T00;
                    this.m11 = this.m11 * T11;
                }
                if ((mystate & AffineTransform.APPLY_TRANSLATE) !== 0) {
                    this.m02 = this.m02 * T00;
                    this.m12 = this.m12 * T11;
                }
                this.type = AffineTransform.TYPE_UNKNOWN;
                return;
            case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR):
                mystate = mystate | AffineTransform.APPLY_SCALE;
            case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_IDENTITY):
            case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SCALE):
                this.state = mystate ^ AffineTransform.APPLY_SHEAR;
            case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                T01 = Tx.m01;
                T10 = Tx.m10;
                M0 = this.m00;
                this.m00 = this.m10 * T01;
                this.m10 = M0 * T10;
                M0 = this.m01;
                this.m01 = this.m11 * T01;
                this.m11 = M0 * T10;
                M0 = this.m02;
                this.m02 = this.m12 * T01;
                this.m12 = M0 * T10;
                this.type = AffineTransform.TYPE_UNKNOWN;
                return;
        }
        T00 = Tx.m00;
        T01 = Tx.m01;
        T02 = Tx.m02;
        T10 = Tx.m10;
        T11 = Tx.m11;
        T12 = Tx.m12;
        switch ((mystate)) {
            default:
                this.stateError();
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                M0 = this.m02;
                M1 = this.m12;
                T02 += M0 * T00 + M1 * T01;
                T12 += M0 * T10 + M1 * T11;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                this.m02 = T02;
                this.m12 = T12;
                M0 = this.m00;
                M1 = this.m10;
                this.m00 = M0 * T00 + M1 * T01;
                this.m10 = M0 * T10 + M1 * T11;
                M0 = this.m01;
                M1 = this.m11;
                this.m01 = M0 * T00 + M1 * T01;
                this.m11 = M0 * T10 + M1 * T11;
                break;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                M0 = this.m02;
                M1 = this.m12;
                T02 += M0 * T00 + M1 * T01;
                T12 += M0 * T10 + M1 * T11;
            case (AffineTransform.APPLY_SHEAR):
                this.m02 = T02;
                this.m12 = T12;
                M0 = this.m10;
                this.m00 = M0 * T01;
                this.m10 = M0 * T11;
                M0 = this.m01;
                this.m01 = M0 * T00;
                this.m11 = M0 * T10;
                break;
            case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                M0 = this.m02;
                M1 = this.m12;
                T02 += M0 * T00 + M1 * T01;
                T12 += M0 * T10 + M1 * T11;
            case (AffineTransform.APPLY_SCALE):
                this.m02 = T02;
                this.m12 = T12;
                M0 = this.m00;
                this.m00 = M0 * T00;
                this.m10 = M0 * T10;
                M0 = this.m11;
                this.m01 = M0 * T01;
                this.m11 = M0 * T11;
                break;
            case (AffineTransform.APPLY_TRANSLATE):
                M0 = this.m02;
                M1 = this.m12;
                T02 += M0 * T00 + M1 * T01;
                T12 += M0 * T10 + M1 * T11;
            case (AffineTransform.APPLY_IDENTITY):
                this.m02 = T02;
                this.m12 = T12;
                this.m00 = T00;
                this.m10 = T10;
                this.m01 = T01;
                this.m11 = T11;
                this.state = mystate | txstate;
                this.type = AffineTransform.TYPE_UNKNOWN;
                return;
        }
        this.updateState();
    };
    /**
     * Returns an <code>AffineTransform</code> object representing the
     * inverse transformation.
     * The inverse transform Tx' of this transform Tx
     * maps coordinates transformed by Tx back
     * to their original coordinates.
     * In other words, Tx'(Tx(p)) = p = Tx(Tx'(p)).
     * <p>
     * If this transform maps all coordinates onto a point or a line
     * then it will not have an inverse, since coordinates that do
     * not lie on the destination point or line will not have an inverse
     * mapping.
     * The <code>getDeterminant</code> method can be used to determine if this
     * transform has no inverse, in which case an exception will be
     * thrown if the <code>createInverse</code> method is called.
     * @return {AffineTransform} a new <code>AffineTransform</code> object representing the
     * inverse transformation.
     * @see #getDeterminant
     * @exception NoninvertibleTransformException
     * if the matrix cannot be inverted.
     * @since 1.2
     */
    AffineTransform.prototype.createInverse = function () {
        var det;
        switch ((this.state)) {
            default:
                this.stateError();
                return null;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                det = this.m00 * this.m11 - this.m01 * this.m10;
                if (Math.abs(det) <= Number.MIN_VALUE) {
                    throw Object.defineProperty(new Error("Determinant is " + det), '__class', { configurable: true, value: 'java.awt.geom.NoninvertibleTransformException' });
                }
                return new AffineTransform(this.m11 / det, -this.m10 / det, -this.m01 / det, this.m00 / det, (this.m01 * this.m12 - this.m11 * this.m02) / det, (this.m10 * this.m02 - this.m00 * this.m12) / det, (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE));
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                det = this.m00 * this.m11 - this.m01 * this.m10;
                if (Math.abs(det) <= Number.MIN_VALUE) {
                    throw Object.defineProperty(new Error("Determinant is " + det), '__class', { configurable: true, value: 'java.awt.geom.NoninvertibleTransformException' });
                }
                return new AffineTransform(this.m11 / det, -this.m10 / det, -this.m01 / det, this.m00 / det, 0.0, 0.0, (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE));
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                if (this.m01 === 0.0 || this.m10 === 0.0) {
                    throw Object.defineProperty(new Error("Determinant is 0"), '__class', { configurable: true, value: 'java.awt.geom.NoninvertibleTransformException' });
                }
                return new AffineTransform(0.0, 1.0 / this.m01, 1.0 / this.m10, 0.0, -this.m12 / this.m10, -this.m02 / this.m01, (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE));
            case (AffineTransform.APPLY_SHEAR):
                if (this.m01 === 0.0 || this.m10 === 0.0) {
                    throw Object.defineProperty(new Error("Determinant is 0"), '__class', { configurable: true, value: 'java.awt.geom.NoninvertibleTransformException' });
                }
                return new AffineTransform(0.0, 1.0 / this.m01, 1.0 / this.m10, 0.0, 0.0, 0.0, (AffineTransform.APPLY_SHEAR));
            case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                if (this.m00 === 0.0 || this.m11 === 0.0) {
                    throw Object.defineProperty(new Error("Determinant is 0"), '__class', { configurable: true, value: 'java.awt.geom.NoninvertibleTransformException' });
                }
                return new AffineTransform(1.0 / this.m00, 0.0, 0.0, 1.0 / this.m11, -this.m02 / this.m00, -this.m12 / this.m11, (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE));
            case (AffineTransform.APPLY_SCALE):
                if (this.m00 === 0.0 || this.m11 === 0.0) {
                    throw Object.defineProperty(new Error("Determinant is 0"), '__class', { configurable: true, value: 'java.awt.geom.NoninvertibleTransformException' });
                }
                return new AffineTransform(1.0 / this.m00, 0.0, 0.0, 1.0 / this.m11, 0.0, 0.0, (AffineTransform.APPLY_SCALE));
            case (AffineTransform.APPLY_TRANSLATE):
                return new AffineTransform(1.0, 0.0, 0.0, 1.0, -this.m02, -this.m12, (AffineTransform.APPLY_TRANSLATE));
            case (AffineTransform.APPLY_IDENTITY):
                return new AffineTransform();
        }
    };
    /**
     * Sets this transform to the inverse of itself.
     * The inverse transform Tx' of this transform Tx
     * maps coordinates transformed by Tx back
     * to their original coordinates.
     * In other words, Tx'(Tx(p)) = p = Tx(Tx'(p)).
     * <p>
     * If this transform maps all coordinates onto a point or a line
     * then it will not have an inverse, since coordinates that do
     * not lie on the destination point or line will not have an inverse
     * mapping.
     * The <code>getDeterminant</code> method can be used to determine if this
     * transform has no inverse, in which case an exception will be
     * thrown if the <code>invert</code> method is called.
     * @see #getDeterminant
     * @exception NoninvertibleTransformException
     * if the matrix cannot be inverted.
     * @since 1.6
     */
    AffineTransform.prototype.invert = function () {
        var M00;
        var M01;
        var M02;
        var M10;
        var M11;
        var M12;
        var det;
        switch ((this.state)) {
            default:
                this.stateError();
                return;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                M00 = this.m00;
                M01 = this.m01;
                M02 = this.m02;
                M10 = this.m10;
                M11 = this.m11;
                M12 = this.m12;
                det = M00 * M11 - M01 * M10;
                if (Math.abs(det) <= Number.MIN_VALUE) {
                    throw Object.defineProperty(new Error("Determinant is " + det), '__class', { configurable: true, value: 'java.awt.geom.NoninvertibleTransformException' });
                }
                this.m00 = M11 / det;
                this.m10 = -M10 / det;
                this.m01 = -M01 / det;
                this.m11 = M00 / det;
                this.m02 = (M01 * M12 - M11 * M02) / det;
                this.m12 = (M10 * M02 - M00 * M12) / det;
                break;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                M00 = this.m00;
                M01 = this.m01;
                M10 = this.m10;
                M11 = this.m11;
                det = M00 * M11 - M01 * M10;
                if (Math.abs(det) <= Number.MIN_VALUE) {
                    throw Object.defineProperty(new Error("Determinant is " + det), '__class', { configurable: true, value: 'java.awt.geom.NoninvertibleTransformException' });
                }
                this.m00 = M11 / det;
                this.m10 = -M10 / det;
                this.m01 = -M01 / det;
                this.m11 = M00 / det;
                break;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                M01 = this.m01;
                M02 = this.m02;
                M10 = this.m10;
                M12 = this.m12;
                if (M01 === 0.0 || M10 === 0.0) {
                    throw Object.defineProperty(new Error("Determinant is 0"), '__class', { configurable: true, value: 'java.awt.geom.NoninvertibleTransformException' });
                }
                this.m10 = 1.0 / M01;
                this.m01 = 1.0 / M10;
                this.m02 = -M12 / M10;
                this.m12 = -M02 / M01;
                break;
            case (AffineTransform.APPLY_SHEAR):
                M01 = this.m01;
                M10 = this.m10;
                if (M01 === 0.0 || M10 === 0.0) {
                    throw Object.defineProperty(new Error("Determinant is 0"), '__class', { configurable: true, value: 'java.awt.geom.NoninvertibleTransformException' });
                }
                this.m10 = 1.0 / M01;
                this.m01 = 1.0 / M10;
                break;
            case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                M00 = this.m00;
                M02 = this.m02;
                M11 = this.m11;
                M12 = this.m12;
                if (M00 === 0.0 || M11 === 0.0) {
                    throw Object.defineProperty(new Error("Determinant is 0"), '__class', { configurable: true, value: 'java.awt.geom.NoninvertibleTransformException' });
                }
                this.m00 = 1.0 / M00;
                this.m11 = 1.0 / M11;
                this.m02 = -M02 / M00;
                this.m12 = -M12 / M11;
                break;
            case (AffineTransform.APPLY_SCALE):
                M00 = this.m00;
                M11 = this.m11;
                if (M00 === 0.0 || M11 === 0.0) {
                    throw Object.defineProperty(new Error("Determinant is 0"), '__class', { configurable: true, value: 'java.awt.geom.NoninvertibleTransformException' });
                }
                this.m00 = 1.0 / M00;
                this.m11 = 1.0 / M11;
                break;
            case (AffineTransform.APPLY_TRANSLATE):
                this.m02 = -this.m02;
                this.m12 = -this.m12;
                break;
            case (AffineTransform.APPLY_IDENTITY):
                break;
        }
    };
    /**
     * Transforms the specified <code>ptSrc</code> and stores the result
     * in <code>ptDst</code>.
     * If <code>ptDst</code> is <code>null</code>, a new {@link Point2D}
     * object is allocated and then the result of the transformation is
     * stored in this object.
     * In either case, <code>ptDst</code>, which contains the
     * transformed point, is returned for convenience.
     * If <code>ptSrc</code> and <code>ptDst</code> are the same
     * object, the input point is correctly overwritten with
     * the transformed point.
     * @param {Point2D} ptSrc the specified <code>Point2D</code> to be transformed
     * @param {Point2D} ptDst the specified <code>Point2D</code> that stores the
     * result of transforming <code>ptSrc</code>
     * @return {Point2D} the <code>ptDst</code> after transforming
     * <code>ptSrc</code> and storing the result in <code>ptDst</code>.
     * @since 1.2
     */
    AffineTransform.prototype.transform$java_awt_geom_Point2D$java_awt_geom_Point2D = function (ptSrc, ptDst) {
        if (ptDst == null) {
            if (ptSrc != null && ptSrc instanceof Point2D.Double) {
                ptDst = new Point2D.Double();
            }
            else {
                ptDst = new Point2D.Float();
            }
        }
        var x = ptSrc.getX();
        var y = ptSrc.getY();
        switch ((this.state)) {
            default:
                this.stateError();
                return null;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                ptDst.setLocation$double$double(x * this.m00 + y * this.m01 + this.m02, x * this.m10 + y * this.m11 + this.m12);
                return ptDst;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                ptDst.setLocation$double$double(x * this.m00 + y * this.m01, x * this.m10 + y * this.m11);
                return ptDst;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                ptDst.setLocation$double$double(y * this.m01 + this.m02, x * this.m10 + this.m12);
                return ptDst;
            case (AffineTransform.APPLY_SHEAR):
                ptDst.setLocation$double$double(y * this.m01, x * this.m10);
                return ptDst;
            case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                ptDst.setLocation$double$double(x * this.m00 + this.m02, y * this.m11 + this.m12);
                return ptDst;
            case (AffineTransform.APPLY_SCALE):
                ptDst.setLocation$double$double(x * this.m00, y * this.m11);
                return ptDst;
            case (AffineTransform.APPLY_TRANSLATE):
                ptDst.setLocation$double$double(x + this.m02, y + this.m12);
                return ptDst;
            case (AffineTransform.APPLY_IDENTITY):
                ptDst.setLocation$double$double(x, y);
                return ptDst;
        }
    };
    /**
     * Transforms an array of point objects by this transform.
     * If any element of the <code>ptDst</code> array is
     * <code>null</code>, a new <code>Point2D</code> object is allocated
     * and stored into that element before storing the results of the
     * transformation.
     * <p>
     * Note that this method does not take any precautions to
     * avoid problems caused by storing results into <code>Point2D</code>
     * objects that will be used as the source for calculations
     * further down the source array.
     * This method does guarantee that if a specified <code>Point2D</code>
     * object is both the source and destination for the same single point
     * transform operation then the results will not be stored until
     * the calculations are complete to avoid storing the results on
     * top of the operands.
     * If, however, the destination <code>Point2D</code> object for one
     * operation is the same object as the source <code>Point2D</code>
     * object for another operation further down the source array then
     * the original coordinates in that point are overwritten before
     * they can be converted.
     * @param {Array} ptSrc the array containing the source point objects
     * @param {Array} ptDst the array into which the transform point objects are
     * returned
     * @param {number} srcOff the offset to the first point object to be
     * transformed in the source array
     * @param {number} dstOff the offset to the location of the first
     * transformed point object that is stored in the destination array
     * @param {number} numPts the number of point objects to be transformed
     * @since 1.2
     */
    AffineTransform.prototype.transform$java_awt_geom_Point2D_A$int$java_awt_geom_Point2D_A$int$int = function (ptSrc, srcOff, ptDst, dstOff, numPts) {
        var state = this.state;
        while ((--numPts >= 0)) {
            var src = ptSrc[srcOff++];
            var x = src.getX();
            var y = src.getY();
            var dst = ptDst[dstOff++];
            if (dst == null) {
                if (src != null && src instanceof Point2D.Double) {
                    dst = new Point2D.Double();
                }
                else {
                    dst = new Point2D.Float();
                }
                ptDst[dstOff - 1] = dst;
            }
            switch ((state)) {
                default:
                    this.stateError();
                    return;
                case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                    dst.setLocation$double$double(x * this.m00 + y * this.m01 + this.m02, x * this.m10 + y * this.m11 + this.m12);
                    break;
                case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                    dst.setLocation$double$double(x * this.m00 + y * this.m01, x * this.m10 + y * this.m11);
                    break;
                case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                    dst.setLocation$double$double(y * this.m01 + this.m02, x * this.m10 + this.m12);
                    break;
                case (AffineTransform.APPLY_SHEAR):
                    dst.setLocation$double$double(y * this.m01, x * this.m10);
                    break;
                case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                    dst.setLocation$double$double(x * this.m00 + this.m02, y * this.m11 + this.m12);
                    break;
                case (AffineTransform.APPLY_SCALE):
                    dst.setLocation$double$double(x * this.m00, y * this.m11);
                    break;
                case (AffineTransform.APPLY_TRANSLATE):
                    dst.setLocation$double$double(x + this.m02, y + this.m12);
                    break;
                case (AffineTransform.APPLY_IDENTITY):
                    dst.setLocation$double$double(x, y);
                    break;
            }
        }
        ;
    };
    /**
     * Transforms an array of point objects by this transform.
     * If any element of the <code>ptDst</code> array is
     * <code>null</code>, a new <code>Point2D</code> object is allocated
     * and stored into that element before storing the results of the
     * transformation.
     * <p>
     * Note that this method does not take any precautions to
     * avoid problems caused by storing results into <code>Point2D</code>
     * objects that will be used as the source for calculations
     * further down the source array.
     * This method does guarantee that if a specified <code>Point2D</code>
     * object is both the source and destination for the same single point
     * transform operation then the results will not be stored until
     * the calculations are complete to avoid storing the results on
     * top of the operands.
     * If, however, the destination <code>Point2D</code> object for one
     * operation is the same object as the source <code>Point2D</code>
     * object for another operation further down the source array then
     * the original coordinates in that point are overwritten before
     * they can be converted.
     * @param {Array} ptSrc the array containing the source point objects
     * @param {Array} ptDst the array into which the transform point objects are
     * returned
     * @param {number} srcOff the offset to the first point object to be
     * transformed in the source array
     * @param {number} dstOff the offset to the location of the first
     * transformed point object that is stored in the destination array
     * @param {number} numPts the number of point objects to be transformed
     * @since 1.2
     */
    AffineTransform.prototype.transform = function (ptSrc, srcOff, ptDst, dstOff, numPts) {
        if (((ptSrc != null && ptSrc instanceof Array && (ptSrc.length == 0 || ptSrc[0] == null || (ptSrc[0] != null && ptSrc[0] instanceof Point2D))) || ptSrc === null) && ((typeof srcOff === 'number') || srcOff === null) && ((ptDst != null && ptDst instanceof Array && (ptDst.length == 0 || ptDst[0] == null || (ptDst[0] != null && ptDst[0] instanceof Point2D))) || ptDst === null) && ((typeof dstOff === 'number') || dstOff === null) && ((typeof numPts === 'number') || numPts === null)) {
            return this.transform$java_awt_geom_Point2D_A$int$java_awt_geom_Point2D_A$int$int(ptSrc, srcOff, ptDst, dstOff, numPts);
        }
        else if (((ptSrc != null && ptSrc instanceof Array && (ptSrc.length == 0 || ptSrc[0] == null || (typeof ptSrc[0] === 'number'))) || ptSrc === null) && ((typeof srcOff === 'number') || srcOff === null) && ((ptDst != null && ptDst instanceof Array && (ptDst.length == 0 || ptDst[0] == null || (typeof ptDst[0] === 'number'))) || ptDst === null) && ((typeof dstOff === 'number') || dstOff === null) && ((typeof numPts === 'number') || numPts === null)) {
            return this.transform$float_A$int$float_A$int$int(ptSrc, srcOff, ptDst, dstOff, numPts);
        }
        else if (((ptSrc != null && ptSrc instanceof Array && (ptSrc.length == 0 || ptSrc[0] == null || (typeof ptSrc[0] === 'number'))) || ptSrc === null) && ((typeof srcOff === 'number') || srcOff === null) && ((ptDst != null && ptDst instanceof Array && (ptDst.length == 0 || ptDst[0] == null || (typeof ptDst[0] === 'number'))) || ptDst === null) && ((typeof dstOff === 'number') || dstOff === null) && ((typeof numPts === 'number') || numPts === null)) {
            return this.transform$double_A$int$double_A$int$int(ptSrc, srcOff, ptDst, dstOff, numPts);
        }
        else if (((ptSrc != null && ptSrc instanceof Array && (ptSrc.length == 0 || ptSrc[0] == null || (typeof ptSrc[0] === 'number'))) || ptSrc === null) && ((typeof srcOff === 'number') || srcOff === null) && ((ptDst != null && ptDst instanceof Array && (ptDst.length == 0 || ptDst[0] == null || (typeof ptDst[0] === 'number'))) || ptDst === null) && ((typeof dstOff === 'number') || dstOff === null) && ((typeof numPts === 'number') || numPts === null)) {
            return this.transform$float_A$int$double_A$int$int(ptSrc, srcOff, ptDst, dstOff, numPts);
        }
        else if (((ptSrc != null && ptSrc instanceof Array && (ptSrc.length == 0 || ptSrc[0] == null || (typeof ptSrc[0] === 'number'))) || ptSrc === null) && ((typeof srcOff === 'number') || srcOff === null) && ((ptDst != null && ptDst instanceof Array && (ptDst.length == 0 || ptDst[0] == null || (typeof ptDst[0] === 'number'))) || ptDst === null) && ((typeof dstOff === 'number') || dstOff === null) && ((typeof numPts === 'number') || numPts === null)) {
            return this.transform$double_A$int$float_A$int$int(ptSrc, srcOff, ptDst, dstOff, numPts);
        }
        else if (((ptSrc != null && ptSrc instanceof Point2D) || ptSrc === null) && ((srcOff != null && srcOff instanceof Point2D) || srcOff === null) && ptDst === undefined && dstOff === undefined && numPts === undefined) {
            return this.transform$java_awt_geom_Point2D$java_awt_geom_Point2D(ptSrc, srcOff);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Transforms an array of floating point coordinates by this transform.
     * The two coordinate array sections can be exactly the same or
     * can be overlapping sections of the same array without affecting the
     * validity of the results.
     * This method ensures that no source coordinates are overwritten by a
     * previous operation before they can be transformed.
     * The coordinates are stored in the arrays starting at the specified
     * offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.
     * @param {Array} srcPts the array containing the source point coordinates.
     * Each point is stored as a pair of x,&nbsp;y coordinates.
     * @param {Array} dstPts the array into which the transformed point coordinates
     * are returned.  Each point is stored as a pair of x,&nbsp;y
     * coordinates.
     * @param {number} srcOff the offset to the first point to be transformed
     * in the source array
     * @param {number} dstOff the offset to the location of the first
     * transformed point that is stored in the destination array
     * @param {number} numPts the number of points to be transformed
     * @since 1.2
     */
    AffineTransform.prototype.transform$float_A$int$float_A$int$int = function (srcPts, srcOff, dstPts, dstOff, numPts) {
        var M00;
        var M01;
        var M02;
        var M10;
        var M11;
        var M12;
        if (dstPts === srcPts && dstOff > srcOff && dstOff < srcOff + numPts * 2) {
            Helper.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
            srcOff = dstOff;
        }
        switch ((this.state)) {
            default:
                this.stateError();
                return;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                M00 = this.m00;
                M01 = this.m01;
                M02 = this.m02;
                M10 = this.m10;
                M11 = this.m11;
                M12 = this.m12;
                while ((--numPts >= 0)) {
                    var x = srcPts[srcOff++];
                    var y = srcPts[srcOff++];
                    dstPts[dstOff++] = (M00 * x + M01 * y + M02);
                    dstPts[dstOff++] = (M10 * x + M11 * y + M12);
                }
                ;
                return;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                M00 = this.m00;
                M01 = this.m01;
                M10 = this.m10;
                M11 = this.m11;
                while ((--numPts >= 0)) {
                    var x = srcPts[srcOff++];
                    var y = srcPts[srcOff++];
                    dstPts[dstOff++] = (M00 * x + M01 * y);
                    dstPts[dstOff++] = (M10 * x + M11 * y);
                }
                ;
                return;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                M01 = this.m01;
                M02 = this.m02;
                M10 = this.m10;
                M12 = this.m12;
                while ((--numPts >= 0)) {
                    var x = srcPts[srcOff++];
                    dstPts[dstOff++] = (M01 * srcPts[srcOff++] + M02);
                    dstPts[dstOff++] = (M10 * x + M12);
                }
                ;
                return;
            case (AffineTransform.APPLY_SHEAR):
                M01 = this.m01;
                M10 = this.m10;
                while ((--numPts >= 0)) {
                    var x = srcPts[srcOff++];
                    dstPts[dstOff++] = (M01 * srcPts[srcOff++]);
                    dstPts[dstOff++] = (M10 * x);
                }
                ;
                return;
            case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                M00 = this.m00;
                M02 = this.m02;
                M11 = this.m11;
                M12 = this.m12;
                while ((--numPts >= 0)) {
                    dstPts[dstOff++] = (M00 * srcPts[srcOff++] + M02);
                    dstPts[dstOff++] = (M11 * srcPts[srcOff++] + M12);
                }
                ;
                return;
            case (AffineTransform.APPLY_SCALE):
                M00 = this.m00;
                M11 = this.m11;
                while ((--numPts >= 0)) {
                    dstPts[dstOff++] = (M00 * srcPts[srcOff++]);
                    dstPts[dstOff++] = (M11 * srcPts[srcOff++]);
                }
                ;
                return;
            case (AffineTransform.APPLY_TRANSLATE):
                M02 = this.m02;
                M12 = this.m12;
                while ((--numPts >= 0)) {
                    dstPts[dstOff++] = (srcPts[srcOff++] + M02);
                    dstPts[dstOff++] = (srcPts[srcOff++] + M12);
                }
                ;
                return;
            case (AffineTransform.APPLY_IDENTITY):
                if (srcPts !== dstPts || srcOff !== dstOff) {
                    Helper.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
                }
                return;
        }
    };
    /**
     * Transforms an array of double precision coordinates by this transform.
     * The two coordinate array sections can be exactly the same or
     * can be overlapping sections of the same array without affecting the
     * validity of the results.
     * This method ensures that no source coordinates are
     * overwritten by a previous operation before they can be transformed.
     * The coordinates are stored in the arrays starting at the indicated
     * offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.
     * @param {Array} srcPts the array containing the source point coordinates.
     * Each point is stored as a pair of x,&nbsp;y coordinates.
     * @param {Array} dstPts the array into which the transformed point
     * coordinates are returned.  Each point is stored as a pair of
     * x,&nbsp;y coordinates.
     * @param {number} srcOff the offset to the first point to be transformed
     * in the source array
     * @param {number} dstOff the offset to the location of the first
     * transformed point that is stored in the destination array
     * @param {number} numPts the number of point objects to be transformed
     * @since 1.2
     */
    AffineTransform.prototype.transform$double_A$int$double_A$int$int = function (srcPts, srcOff, dstPts, dstOff, numPts) {
        var M00;
        var M01;
        var M02;
        var M10;
        var M11;
        var M12;
        if (dstPts === srcPts && dstOff > srcOff && dstOff < srcOff + numPts * 2) {
            Helper.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
            srcOff = dstOff;
        }
        switch ((this.state)) {
            default:
                this.stateError();
                return;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                M00 = this.m00;
                M01 = this.m01;
                M02 = this.m02;
                M10 = this.m10;
                M11 = this.m11;
                M12 = this.m12;
                while ((--numPts >= 0)) {
                    var x = srcPts[srcOff++];
                    var y = srcPts[srcOff++];
                    dstPts[dstOff++] = M00 * x + M01 * y + M02;
                    dstPts[dstOff++] = M10 * x + M11 * y + M12;
                }
                ;
                return;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                M00 = this.m00;
                M01 = this.m01;
                M10 = this.m10;
                M11 = this.m11;
                while ((--numPts >= 0)) {
                    var x = srcPts[srcOff++];
                    var y = srcPts[srcOff++];
                    dstPts[dstOff++] = M00 * x + M01 * y;
                    dstPts[dstOff++] = M10 * x + M11 * y;
                }
                ;
                return;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                M01 = this.m01;
                M02 = this.m02;
                M10 = this.m10;
                M12 = this.m12;
                while ((--numPts >= 0)) {
                    var x = srcPts[srcOff++];
                    dstPts[dstOff++] = M01 * srcPts[srcOff++] + M02;
                    dstPts[dstOff++] = M10 * x + M12;
                }
                ;
                return;
            case (AffineTransform.APPLY_SHEAR):
                M01 = this.m01;
                M10 = this.m10;
                while ((--numPts >= 0)) {
                    var x = srcPts[srcOff++];
                    dstPts[dstOff++] = M01 * srcPts[srcOff++];
                    dstPts[dstOff++] = M10 * x;
                }
                ;
                return;
            case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                M00 = this.m00;
                M02 = this.m02;
                M11 = this.m11;
                M12 = this.m12;
                while ((--numPts >= 0)) {
                    dstPts[dstOff++] = M00 * srcPts[srcOff++] + M02;
                    dstPts[dstOff++] = M11 * srcPts[srcOff++] + M12;
                }
                ;
                return;
            case (AffineTransform.APPLY_SCALE):
                M00 = this.m00;
                M11 = this.m11;
                while ((--numPts >= 0)) {
                    dstPts[dstOff++] = M00 * srcPts[srcOff++];
                    dstPts[dstOff++] = M11 * srcPts[srcOff++];
                }
                ;
                return;
            case (AffineTransform.APPLY_TRANSLATE):
                M02 = this.m02;
                M12 = this.m12;
                while ((--numPts >= 0)) {
                    dstPts[dstOff++] = srcPts[srcOff++] + M02;
                    dstPts[dstOff++] = srcPts[srcOff++] + M12;
                }
                ;
                return;
            case (AffineTransform.APPLY_IDENTITY):
                if (srcPts !== dstPts || srcOff !== dstOff) {
                    Helper.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
                }
                return;
        }
    };
    /**
     * Transforms an array of floating point coordinates by this transform
     * and stores the results into an array of doubles.
     * The coordinates are stored in the arrays starting at the specified
     * offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.
     * @param {Array} srcPts the array containing the source point coordinates.
     * Each point is stored as a pair of x,&nbsp;y coordinates.
     * @param {Array} dstPts the array into which the transformed point coordinates
     * are returned.  Each point is stored as a pair of x,&nbsp;y
     * coordinates.
     * @param {number} srcOff the offset to the first point to be transformed
     * in the source array
     * @param {number} dstOff the offset to the location of the first
     * transformed point that is stored in the destination array
     * @param {number} numPts the number of points to be transformed
     * @since 1.2
     */
    AffineTransform.prototype.transform$float_A$int$double_A$int$int = function (srcPts, srcOff, dstPts, dstOff, numPts) {
        var M00;
        var M01;
        var M02;
        var M10;
        var M11;
        var M12;
        switch ((this.state)) {
            default:
                this.stateError();
                return;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                M00 = this.m00;
                M01 = this.m01;
                M02 = this.m02;
                M10 = this.m10;
                M11 = this.m11;
                M12 = this.m12;
                while ((--numPts >= 0)) {
                    var x = srcPts[srcOff++];
                    var y = srcPts[srcOff++];
                    dstPts[dstOff++] = M00 * x + M01 * y + M02;
                    dstPts[dstOff++] = M10 * x + M11 * y + M12;
                }
                ;
                return;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                M00 = this.m00;
                M01 = this.m01;
                M10 = this.m10;
                M11 = this.m11;
                while ((--numPts >= 0)) {
                    var x = srcPts[srcOff++];
                    var y = srcPts[srcOff++];
                    dstPts[dstOff++] = M00 * x + M01 * y;
                    dstPts[dstOff++] = M10 * x + M11 * y;
                }
                ;
                return;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                M01 = this.m01;
                M02 = this.m02;
                M10 = this.m10;
                M12 = this.m12;
                while ((--numPts >= 0)) {
                    var x = srcPts[srcOff++];
                    dstPts[dstOff++] = M01 * srcPts[srcOff++] + M02;
                    dstPts[dstOff++] = M10 * x + M12;
                }
                ;
                return;
            case (AffineTransform.APPLY_SHEAR):
                M01 = this.m01;
                M10 = this.m10;
                while ((--numPts >= 0)) {
                    var x = srcPts[srcOff++];
                    dstPts[dstOff++] = M01 * srcPts[srcOff++];
                    dstPts[dstOff++] = M10 * x;
                }
                ;
                return;
            case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                M00 = this.m00;
                M02 = this.m02;
                M11 = this.m11;
                M12 = this.m12;
                while ((--numPts >= 0)) {
                    dstPts[dstOff++] = M00 * srcPts[srcOff++] + M02;
                    dstPts[dstOff++] = M11 * srcPts[srcOff++] + M12;
                }
                ;
                return;
            case (AffineTransform.APPLY_SCALE):
                M00 = this.m00;
                M11 = this.m11;
                while ((--numPts >= 0)) {
                    dstPts[dstOff++] = M00 * srcPts[srcOff++];
                    dstPts[dstOff++] = M11 * srcPts[srcOff++];
                }
                ;
                return;
            case (AffineTransform.APPLY_TRANSLATE):
                M02 = this.m02;
                M12 = this.m12;
                while ((--numPts >= 0)) {
                    dstPts[dstOff++] = srcPts[srcOff++] + M02;
                    dstPts[dstOff++] = srcPts[srcOff++] + M12;
                }
                ;
                return;
            case (AffineTransform.APPLY_IDENTITY):
                while ((--numPts >= 0)) {
                    dstPts[dstOff++] = srcPts[srcOff++];
                    dstPts[dstOff++] = srcPts[srcOff++];
                }
                ;
                return;
        }
    };
    /**
     * Transforms an array of double precision coordinates by this transform
     * and stores the results into an array of floats.
     * The coordinates are stored in the arrays starting at the specified
     * offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.
     * @param {Array} srcPts the array containing the source point coordinates.
     * Each point is stored as a pair of x,&nbsp;y coordinates.
     * @param {Array} dstPts the array into which the transformed point
     * coordinates are returned.  Each point is stored as a pair of
     * x,&nbsp;y coordinates.
     * @param {number} srcOff the offset to the first point to be transformed
     * in the source array
     * @param {number} dstOff the offset to the location of the first
     * transformed point that is stored in the destination array
     * @param {number} numPts the number of point objects to be transformed
     * @since 1.2
     */
    AffineTransform.prototype.transform$double_A$int$float_A$int$int = function (srcPts, srcOff, dstPts, dstOff, numPts) {
        var M00;
        var M01;
        var M02;
        var M10;
        var M11;
        var M12;
        switch ((this.state)) {
            default:
                this.stateError();
                return;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                M00 = this.m00;
                M01 = this.m01;
                M02 = this.m02;
                M10 = this.m10;
                M11 = this.m11;
                M12 = this.m12;
                while ((--numPts >= 0)) {
                    var x = srcPts[srcOff++];
                    var y = srcPts[srcOff++];
                    dstPts[dstOff++] = (M00 * x + M01 * y + M02);
                    dstPts[dstOff++] = (M10 * x + M11 * y + M12);
                }
                ;
                return;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                M00 = this.m00;
                M01 = this.m01;
                M10 = this.m10;
                M11 = this.m11;
                while ((--numPts >= 0)) {
                    var x = srcPts[srcOff++];
                    var y = srcPts[srcOff++];
                    dstPts[dstOff++] = (M00 * x + M01 * y);
                    dstPts[dstOff++] = (M10 * x + M11 * y);
                }
                ;
                return;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                M01 = this.m01;
                M02 = this.m02;
                M10 = this.m10;
                M12 = this.m12;
                while ((--numPts >= 0)) {
                    var x = srcPts[srcOff++];
                    dstPts[dstOff++] = (M01 * srcPts[srcOff++] + M02);
                    dstPts[dstOff++] = (M10 * x + M12);
                }
                ;
                return;
            case (AffineTransform.APPLY_SHEAR):
                M01 = this.m01;
                M10 = this.m10;
                while ((--numPts >= 0)) {
                    var x = srcPts[srcOff++];
                    dstPts[dstOff++] = (M01 * srcPts[srcOff++]);
                    dstPts[dstOff++] = (M10 * x);
                }
                ;
                return;
            case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                M00 = this.m00;
                M02 = this.m02;
                M11 = this.m11;
                M12 = this.m12;
                while ((--numPts >= 0)) {
                    dstPts[dstOff++] = (M00 * srcPts[srcOff++] + M02);
                    dstPts[dstOff++] = (M11 * srcPts[srcOff++] + M12);
                }
                ;
                return;
            case (AffineTransform.APPLY_SCALE):
                M00 = this.m00;
                M11 = this.m11;
                while ((--numPts >= 0)) {
                    dstPts[dstOff++] = (M00 * srcPts[srcOff++]);
                    dstPts[dstOff++] = (M11 * srcPts[srcOff++]);
                }
                ;
                return;
            case (AffineTransform.APPLY_TRANSLATE):
                M02 = this.m02;
                M12 = this.m12;
                while ((--numPts >= 0)) {
                    dstPts[dstOff++] = (srcPts[srcOff++] + M02);
                    dstPts[dstOff++] = (srcPts[srcOff++] + M12);
                }
                ;
                return;
            case (AffineTransform.APPLY_IDENTITY):
                while ((--numPts >= 0)) {
                    dstPts[dstOff++] = (srcPts[srcOff++]);
                    dstPts[dstOff++] = (srcPts[srcOff++]);
                }
                ;
                return;
        }
    };
    /**
     * Inverse transforms the specified <code>ptSrc</code> and stores the
     * result in <code>ptDst</code>.
     * If <code>ptDst</code> is <code>null</code>, a new
     * <code>Point2D</code> object is allocated and then the result of the
     * transform is stored in this object.
     * In either case, <code>ptDst</code>, which contains the transformed
     * point, is returned for convenience.
     * If <code>ptSrc</code> and <code>ptDst</code> are the same
     * object, the input point is correctly overwritten with the
     * transformed point.
     * @param {Point2D} ptSrc the point to be inverse transformed
     * @param {Point2D} ptDst the resulting transformed point
     * @return {Point2D} <code>ptDst</code>, which contains the result of the
     * inverse transform.
     * @exception NoninvertibleTransformException  if the matrix cannot be
     * inverted.
     * @since 1.2
     */
    AffineTransform.prototype.inverseTransform$java_awt_geom_Point2D$java_awt_geom_Point2D = function (ptSrc, ptDst) {
        if (ptDst == null) {
            if (ptSrc != null && ptSrc instanceof Point2D.Double) {
                ptDst = new Point2D.Double();
            }
            else {
                ptDst = new Point2D.Float();
            }
        }
        var x = ptSrc.getX();
        var y = ptSrc.getY();
        switch ((this.state)) {
            default:
                this.stateError();
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                x -= this.m02;
                y -= this.m12;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                var det = this.m00 * this.m11 - this.m01 * this.m10;
                if (Math.abs(det) <= Number.MIN_VALUE) {
                    throw Object.defineProperty(new Error("Determinant is " + det), '__class', { configurable: true, value: 'java.awt.geom.NoninvertibleTransformException' });
                }
                ptDst.setLocation$double$double((x * this.m11 - y * this.m01) / det, (y * this.m00 - x * this.m10) / det);
                return ptDst;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                x -= this.m02;
                y -= this.m12;
            case (AffineTransform.APPLY_SHEAR):
                if (this.m01 === 0.0 || this.m10 === 0.0) {
                    throw Object.defineProperty(new Error("Determinant is 0"), '__class', { configurable: true, value: 'java.awt.geom.NoninvertibleTransformException' });
                }
                ptDst.setLocation$double$double(y / this.m10, x / this.m01);
                return ptDst;
            case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                x -= this.m02;
                y -= this.m12;
            case (AffineTransform.APPLY_SCALE):
                if (this.m00 === 0.0 || this.m11 === 0.0) {
                    throw Object.defineProperty(new Error("Determinant is 0"), '__class', { configurable: true, value: 'java.awt.geom.NoninvertibleTransformException' });
                }
                ptDst.setLocation$double$double(x / this.m00, y / this.m11);
                return ptDst;
            case (AffineTransform.APPLY_TRANSLATE):
                ptDst.setLocation$double$double(x - this.m02, y - this.m12);
                return ptDst;
            case (AffineTransform.APPLY_IDENTITY):
                ptDst.setLocation$double$double(x, y);
                return ptDst;
        }
    };
    /**
     * Inverse transforms an array of double precision coordinates by
     * this transform.
     * The two coordinate array sections can be exactly the same or
     * can be overlapping sections of the same array without affecting the
     * validity of the results.
     * This method ensures that no source coordinates are
     * overwritten by a previous operation before they can be transformed.
     * The coordinates are stored in the arrays starting at the specified
     * offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.
     * @param {Array} srcPts the array containing the source point coordinates.
     * Each point is stored as a pair of x,&nbsp;y coordinates.
     * @param {Array} dstPts the array into which the transformed point
     * coordinates are returned.  Each point is stored as a pair of
     * x,&nbsp;y coordinates.
     * @param {number} srcOff the offset to the first point to be transformed
     * in the source array
     * @param {number} dstOff the offset to the location of the first
     * transformed point that is stored in the destination array
     * @param {number} numPts the number of point objects to be transformed
     * @exception NoninvertibleTransformException  if the matrix cannot be
     * inverted.
     * @since 1.2
     */
    AffineTransform.prototype.inverseTransform$double_A$int$double_A$int$int = function (srcPts, srcOff, dstPts, dstOff, numPts) {
        var M00;
        var M01;
        var M02;
        var M10;
        var M11;
        var M12;
        var det;
        if (dstPts === srcPts && dstOff > srcOff && dstOff < srcOff + numPts * 2) {
            Helper.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
            srcOff = dstOff;
        }
        switch ((this.state)) {
            default:
                this.stateError();
                return;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                M00 = this.m00;
                M01 = this.m01;
                M02 = this.m02;
                M10 = this.m10;
                M11 = this.m11;
                M12 = this.m12;
                det = M00 * M11 - M01 * M10;
                if (Math.abs(det) <= Number.MIN_VALUE) {
                    throw Object.defineProperty(new Error("Determinant is " + det), '__class', { configurable: true, value: 'java.awt.geom.NoninvertibleTransformException' });
                }
                while ((--numPts >= 0)) {
                    var x = srcPts[srcOff++] - M02;
                    var y = srcPts[srcOff++] - M12;
                    dstPts[dstOff++] = (x * M11 - y * M01) / det;
                    dstPts[dstOff++] = (y * M00 - x * M10) / det;
                }
                ;
                return;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                M00 = this.m00;
                M01 = this.m01;
                M10 = this.m10;
                M11 = this.m11;
                det = M00 * M11 - M01 * M10;
                if (Math.abs(det) <= Number.MIN_VALUE) {
                    throw Object.defineProperty(new Error("Determinant is " + det), '__class', { configurable: true, value: 'java.awt.geom.NoninvertibleTransformException' });
                }
                while ((--numPts >= 0)) {
                    var x = srcPts[srcOff++];
                    var y = srcPts[srcOff++];
                    dstPts[dstOff++] = (x * M11 - y * M01) / det;
                    dstPts[dstOff++] = (y * M00 - x * M10) / det;
                }
                ;
                return;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                M01 = this.m01;
                M02 = this.m02;
                M10 = this.m10;
                M12 = this.m12;
                if (M01 === 0.0 || M10 === 0.0) {
                    throw Object.defineProperty(new Error("Determinant is 0"), '__class', { configurable: true, value: 'java.awt.geom.NoninvertibleTransformException' });
                }
                while ((--numPts >= 0)) {
                    var x = srcPts[srcOff++] - M02;
                    dstPts[dstOff++] = (srcPts[srcOff++] - M12) / M10;
                    dstPts[dstOff++] = x / M01;
                }
                ;
                return;
            case (AffineTransform.APPLY_SHEAR):
                M01 = this.m01;
                M10 = this.m10;
                if (M01 === 0.0 || M10 === 0.0) {
                    throw Object.defineProperty(new Error("Determinant is 0"), '__class', { configurable: true, value: 'java.awt.geom.NoninvertibleTransformException' });
                }
                while ((--numPts >= 0)) {
                    var x = srcPts[srcOff++];
                    dstPts[dstOff++] = srcPts[srcOff++] / M10;
                    dstPts[dstOff++] = x / M01;
                }
                ;
                return;
            case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                M00 = this.m00;
                M02 = this.m02;
                M11 = this.m11;
                M12 = this.m12;
                if (M00 === 0.0 || M11 === 0.0) {
                    throw Object.defineProperty(new Error("Determinant is 0"), '__class', { configurable: true, value: 'java.awt.geom.NoninvertibleTransformException' });
                }
                while ((--numPts >= 0)) {
                    dstPts[dstOff++] = (srcPts[srcOff++] - M02) / M00;
                    dstPts[dstOff++] = (srcPts[srcOff++] - M12) / M11;
                }
                ;
                return;
            case (AffineTransform.APPLY_SCALE):
                M00 = this.m00;
                M11 = this.m11;
                if (M00 === 0.0 || M11 === 0.0) {
                    throw Object.defineProperty(new Error("Determinant is 0"), '__class', { configurable: true, value: 'java.awt.geom.NoninvertibleTransformException' });
                }
                while ((--numPts >= 0)) {
                    dstPts[dstOff++] = srcPts[srcOff++] / M00;
                    dstPts[dstOff++] = srcPts[srcOff++] / M11;
                }
                ;
                return;
            case (AffineTransform.APPLY_TRANSLATE):
                M02 = this.m02;
                M12 = this.m12;
                while ((--numPts >= 0)) {
                    dstPts[dstOff++] = srcPts[srcOff++] - M02;
                    dstPts[dstOff++] = srcPts[srcOff++] - M12;
                }
                ;
                return;
            case (AffineTransform.APPLY_IDENTITY):
                if (srcPts !== dstPts || srcOff !== dstOff) {
                    Helper.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
                }
                return;
        }
    };
    /**
     * Inverse transforms an array of double precision coordinates by
     * this transform.
     * The two coordinate array sections can be exactly the same or
     * can be overlapping sections of the same array without affecting the
     * validity of the results.
     * This method ensures that no source coordinates are
     * overwritten by a previous operation before they can be transformed.
     * The coordinates are stored in the arrays starting at the specified
     * offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.
     * @param {Array} srcPts the array containing the source point coordinates.
     * Each point is stored as a pair of x,&nbsp;y coordinates.
     * @param {Array} dstPts the array into which the transformed point
     * coordinates are returned.  Each point is stored as a pair of
     * x,&nbsp;y coordinates.
     * @param {number} srcOff the offset to the first point to be transformed
     * in the source array
     * @param {number} dstOff the offset to the location of the first
     * transformed point that is stored in the destination array
     * @param {number} numPts the number of point objects to be transformed
     * @exception NoninvertibleTransformException  if the matrix cannot be
     * inverted.
     * @since 1.2
     */
    AffineTransform.prototype.inverseTransform = function (srcPts, srcOff, dstPts, dstOff, numPts) {
        if (((srcPts != null && srcPts instanceof Array && (srcPts.length == 0 || srcPts[0] == null || (typeof srcPts[0] === 'number'))) || srcPts === null) && ((typeof srcOff === 'number') || srcOff === null) && ((dstPts != null && dstPts instanceof Array && (dstPts.length == 0 || dstPts[0] == null || (typeof dstPts[0] === 'number'))) || dstPts === null) && ((typeof dstOff === 'number') || dstOff === null) && ((typeof numPts === 'number') || numPts === null)) {
            return this.inverseTransform$double_A$int$double_A$int$int(srcPts, srcOff, dstPts, dstOff, numPts);
        }
        else if (((srcPts != null && srcPts instanceof Point2D) || srcPts === null) && ((srcOff != null && srcOff instanceof Point2D) || srcOff === null) && dstPts === undefined && dstOff === undefined && numPts === undefined) {
            return this.inverseTransform$java_awt_geom_Point2D$java_awt_geom_Point2D(srcPts, srcOff);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Transforms the relative distance vector specified by
     * <code>ptSrc</code> and stores the result in <code>ptDst</code>.
     * A relative distance vector is transformed without applying the
     * translation components of the affine transformation matrix
     * using the following equations:
     * <pre>
     * [  x' ]   [  m00  m01 (m02) ] [  x  ]   [ m00x + m01y ]
     * [  y' ] = [  m10  m11 (m12) ] [  y  ] = [ m10x + m11y ]
     * [ (1) ]   [  (0)  (0) ( 1 ) ] [ (1) ]   [     (1)     ]
     * </pre>
     * If <code>ptDst</code> is <code>null</code>, a new
     * <code>Point2D</code> object is allocated and then the result of the
     * transform is stored in this object.
     * In either case, <code>ptDst</code>, which contains the
     * transformed point, is returned for convenience.
     * If <code>ptSrc</code> and <code>ptDst</code> are the same object,
     * the input point is correctly overwritten with the transformed
     * point.
     * @param {Point2D} ptSrc the distance vector to be delta transformed
     * @param {Point2D} ptDst the resulting transformed distance vector
     * @return {Point2D} <code>ptDst</code>, which contains the result of the
     * transformation.
     * @since 1.2
     */
    AffineTransform.prototype.deltaTransform$java_awt_geom_Point2D$java_awt_geom_Point2D = function (ptSrc, ptDst) {
        if (ptDst == null) {
            if (ptSrc != null && ptSrc instanceof Point2D.Double) {
                ptDst = new Point2D.Double();
            }
            else {
                ptDst = new Point2D.Float();
            }
        }
        var x = ptSrc.getX();
        var y = ptSrc.getY();
        switch ((this.state)) {
            default:
                this.stateError();
                return null;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                ptDst.setLocation$double$double(x * this.m00 + y * this.m01, x * this.m10 + y * this.m11);
                return ptDst;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.APPLY_SHEAR):
                ptDst.setLocation$double$double(y * this.m01, x * this.m10);
                return ptDst;
            case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.APPLY_SCALE):
                ptDst.setLocation$double$double(x * this.m00, y * this.m11);
                return ptDst;
            case (AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.APPLY_IDENTITY):
                ptDst.setLocation$double$double(x, y);
                return ptDst;
        }
    };
    /**
     * Transforms an array of relative distance vectors by this
     * transform.
     * A relative distance vector is transformed without applying the
     * translation components of the affine transformation matrix
     * using the following equations:
     * <pre>
     * [  x' ]   [  m00  m01 (m02) ] [  x  ]   [ m00x + m01y ]
     * [  y' ] = [  m10  m11 (m12) ] [  y  ] = [ m10x + m11y ]
     * [ (1) ]   [  (0)  (0) ( 1 ) ] [ (1) ]   [     (1)     ]
     * </pre>
     * The two coordinate array sections can be exactly the same or
     * can be overlapping sections of the same array without affecting the
     * validity of the results.
     * This method ensures that no source coordinates are
     * overwritten by a previous operation before they can be transformed.
     * The coordinates are stored in the arrays starting at the indicated
     * offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.
     * @param {Array} srcPts the array containing the source distance vectors.
     * Each vector is stored as a pair of relative x,&nbsp;y coordinates.
     * @param {Array} dstPts the array into which the transformed distance vectors
     * are returned.  Each vector is stored as a pair of relative
     * x,&nbsp;y coordinates.
     * @param {number} srcOff the offset to the first vector to be transformed
     * in the source array
     * @param {number} dstOff the offset to the location of the first
     * transformed vector that is stored in the destination array
     * @param {number} numPts the number of vector coordinate pairs to be
     * transformed
     * @since 1.2
     */
    AffineTransform.prototype.deltaTransform$double_A$int$double_A$int$int = function (srcPts, srcOff, dstPts, dstOff, numPts) {
        var M00;
        var M01;
        var M10;
        var M11;
        if (dstPts === srcPts && dstOff > srcOff && dstOff < srcOff + numPts * 2) {
            Helper.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
            srcOff = dstOff;
        }
        switch ((this.state)) {
            default:
                this.stateError();
                return;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                M00 = this.m00;
                M01 = this.m01;
                M10 = this.m10;
                M11 = this.m11;
                while ((--numPts >= 0)) {
                    var x = srcPts[srcOff++];
                    var y = srcPts[srcOff++];
                    dstPts[dstOff++] = x * M00 + y * M01;
                    dstPts[dstOff++] = x * M10 + y * M11;
                }
                ;
                return;
            case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.APPLY_SHEAR):
                M01 = this.m01;
                M10 = this.m10;
                while ((--numPts >= 0)) {
                    var x = srcPts[srcOff++];
                    dstPts[dstOff++] = srcPts[srcOff++] * M01;
                    dstPts[dstOff++] = x * M10;
                }
                ;
                return;
            case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.APPLY_SCALE):
                M00 = this.m00;
                M11 = this.m11;
                while ((--numPts >= 0)) {
                    dstPts[dstOff++] = srcPts[srcOff++] * M00;
                    dstPts[dstOff++] = srcPts[srcOff++] * M11;
                }
                ;
                return;
            case (AffineTransform.APPLY_TRANSLATE):
            case (AffineTransform.APPLY_IDENTITY):
                if (srcPts !== dstPts || srcOff !== dstOff) {
                    Helper.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
                }
                return;
        }
    };
    /**
     * Transforms an array of relative distance vectors by this
     * transform.
     * A relative distance vector is transformed without applying the
     * translation components of the affine transformation matrix
     * using the following equations:
     * <pre>
     * [  x' ]   [  m00  m01 (m02) ] [  x  ]   [ m00x + m01y ]
     * [  y' ] = [  m10  m11 (m12) ] [  y  ] = [ m10x + m11y ]
     * [ (1) ]   [  (0)  (0) ( 1 ) ] [ (1) ]   [     (1)     ]
     * </pre>
     * The two coordinate array sections can be exactly the same or
     * can be overlapping sections of the same array without affecting the
     * validity of the results.
     * This method ensures that no source coordinates are
     * overwritten by a previous operation before they can be transformed.
     * The coordinates are stored in the arrays starting at the indicated
     * offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.
     * @param {Array} srcPts the array containing the source distance vectors.
     * Each vector is stored as a pair of relative x,&nbsp;y coordinates.
     * @param {Array} dstPts the array into which the transformed distance vectors
     * are returned.  Each vector is stored as a pair of relative
     * x,&nbsp;y coordinates.
     * @param {number} srcOff the offset to the first vector to be transformed
     * in the source array
     * @param {number} dstOff the offset to the location of the first
     * transformed vector that is stored in the destination array
     * @param {number} numPts the number of vector coordinate pairs to be
     * transformed
     * @since 1.2
     */
    AffineTransform.prototype.deltaTransform = function (srcPts, srcOff, dstPts, dstOff, numPts) {
        if (((srcPts != null && srcPts instanceof Array && (srcPts.length == 0 || srcPts[0] == null || (typeof srcPts[0] === 'number'))) || srcPts === null) && ((typeof srcOff === 'number') || srcOff === null) && ((dstPts != null && dstPts instanceof Array && (dstPts.length == 0 || dstPts[0] == null || (typeof dstPts[0] === 'number'))) || dstPts === null) && ((typeof dstOff === 'number') || dstOff === null) && ((typeof numPts === 'number') || numPts === null)) {
            return this.deltaTransform$double_A$int$double_A$int$int(srcPts, srcOff, dstPts, dstOff, numPts);
        }
        else if (((srcPts != null && srcPts instanceof Point2D) || srcPts === null) && ((srcOff != null && srcOff instanceof Point2D) || srcOff === null) && dstPts === undefined && dstOff === undefined && numPts === undefined) {
            return this.deltaTransform$java_awt_geom_Point2D$java_awt_geom_Point2D(srcPts, srcOff);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Returns a new {@link Shape} object defined by the geometry of the
     * specified <code>Shape</code> after it has been transformed by
     * this transform.
     * @param {java.awt.Shape} pSrc the specified <code>Shape</code> object to be
     * transformed by this transform.
     * @return {java.awt.Shape} a new <code>Shape</code> object that defines the geometry
     * of the transformed <code>Shape</code>, or null if {@code pSrc} is null.
     * @since 1.2
     */
    AffineTransform.prototype.createTransformedShape = function (pSrc) {
        if (pSrc == null) {
            return null;
        }
        return new Path2D.Double(pSrc, this);
    };
    AffineTransform._matround = function (matval) {
        return (function (d) { if (d === Number.NaN) {
            return d;
        }
        else if (Number.POSITIVE_INFINITY === d || Number.NEGATIVE_INFINITY === d) {
            return d;
        }
        else if (d == 0) {
            return d;
        }
        else {
            return Math.round(d);
        } })(matval * 1.0E15) / 1.0E15;
    };
    /**
     * Returns a <code>String</code> that represents the value of this
     * {@link Object}.
     * @return {string} a <code>String</code> representing the value of this
     * <code>Object</code>.
     * @since 1.2
     */
    AffineTransform.prototype.toString = function () {
        return ("AffineTransform[[" + AffineTransform._matround(this.m00) + ", " + AffineTransform._matround(this.m01) + ", " + AffineTransform._matround(this.m02) + "], [" + AffineTransform._matround(this.m10) + ", " + AffineTransform._matround(this.m11) + ", " + AffineTransform._matround(this.m12) + "]]");
    };
    /**
     * Returns <code>true</code> if this <code>AffineTransform</code> is
     * an identity transform.
     * @return {boolean} <code>true</code> if this <code>AffineTransform</code> is
     * an identity transform; <code>false</code> otherwise.
     * @since 1.2
     */
    AffineTransform.prototype.isIdentity = function () {
        return (this.state === AffineTransform.APPLY_IDENTITY || (this.getType() === AffineTransform.TYPE_IDENTITY));
    };
    /**
     * Returns a copy of this <code>AffineTransform</code> object.
     * @return {*} an <code>Object</code> that is a copy of this
     * <code>AffineTransform</code> object.
     * @since 1.2
     */
    AffineTransform.prototype.clone = function () {
        try {
            return (function (o) { var clone = Object.create(o); for (var p in o) {
                if (o.hasOwnProperty(p))
                    clone[p] = o[p];
            } return clone; })(this);
        }
        catch (e) {
            throw Object.defineProperty(new Error(e.message), '__class', { configurable: true, value: 'java.lang.InternalError' });
        }
        ;
    };
    /**
     * Returns <code>true</code> if this <code>AffineTransform</code>
     * represents the same affine coordinate transform as the specified
     * argument.
     * @param {*} obj the <code>Object</code> to test for equality with this
     * <code>AffineTransform</code>
     * @return {boolean} <code>true</code> if <code>obj</code> equals this
     * <code>AffineTransform</code> object; <code>false</code> otherwise.
     * @since 1.2
     */
    AffineTransform.prototype.equals = function (obj) {
        if (!(obj != null && obj instanceof AffineTransform)) {
            return false;
        }
        var a = obj;
        return ((this.m00 === a.m00) && (this.m01 === a.m01) && (this.m02 === a.m02) && (this.m10 === a.m10) && (this.m11 === a.m11) && (this.m12 === a.m12));
    };
    return AffineTransform;
}());
AffineTransform.TYPE_UNKNOWN = -1;
/**
 * This constant indicates that the transform defined by this object
 * is an identity transform.
 * An identity transform is one in which the output coordinates are
 * always the same as the input coordinates.
 * If this transform is anything other than the identity transform,
 * the type will either be the constant GENERAL_TRANSFORM or a
 * combination of the appropriate flag bits for the various coordinate
 * conversions that this transform performs.
 * @see #TYPE_TRANSLATION
 * @see #TYPE_UNIFORM_SCALE
 * @see #TYPE_GENERAL_SCALE
 * @see #TYPE_FLIP
 * @see #TYPE_QUADRANT_ROTATION
 * @see #TYPE_GENERAL_ROTATION
 * @see #TYPE_GENERAL_TRANSFORM
 * @see #getType
 * @since 1.2
 */
AffineTransform.TYPE_IDENTITY = 0;
/**
 * This flag bit indicates that the transform defined by this object
 * performs a translation in addition to the conversions indicated
 * by other flag bits.
 * A translation moves the coordinates by a constant amount in x
 * and y without changing the length or angle of vectors.
 * @see #TYPE_IDENTITY
 * @see #TYPE_UNIFORM_SCALE
 * @see #TYPE_GENERAL_SCALE
 * @see #TYPE_FLIP
 * @see #TYPE_QUADRANT_ROTATION
 * @see #TYPE_GENERAL_ROTATION
 * @see #TYPE_GENERAL_TRANSFORM
 * @see #getType
 * @since 1.2
 */
AffineTransform.TYPE_TRANSLATION = 1;
/**
 * This flag bit indicates that the transform defined by this object
 * performs a uniform scale in addition to the conversions indicated
 * by other flag bits.
 * A uniform scale multiplies the length of vectors by the same amount
 * in both the x and y directions without changing the angle between
 * vectors.
 * This flag bit is mutually exclusive with the TYPE_GENERAL_SCALE flag.
 * @see #TYPE_IDENTITY
 * @see #TYPE_TRANSLATION
 * @see #TYPE_GENERAL_SCALE
 * @see #TYPE_FLIP
 * @see #TYPE_QUADRANT_ROTATION
 * @see #TYPE_GENERAL_ROTATION
 * @see #TYPE_GENERAL_TRANSFORM
 * @see #getType
 * @since 1.2
 */
AffineTransform.TYPE_UNIFORM_SCALE = 2;
/**
 * This flag bit indicates that the transform defined by this object
 * performs a general scale in addition to the conversions indicated
 * by other flag bits.
 * A general scale multiplies the length of vectors by different
 * amounts in the x and y directions without changing the angle
 * between perpendicular vectors.
 * This flag bit is mutually exclusive with the TYPE_UNIFORM_SCALE flag.
 * @see #TYPE_IDENTITY
 * @see #TYPE_TRANSLATION
 * @see #TYPE_UNIFORM_SCALE
 * @see #TYPE_FLIP
 * @see #TYPE_QUADRANT_ROTATION
 * @see #TYPE_GENERAL_ROTATION
 * @see #TYPE_GENERAL_TRANSFORM
 * @see #getType
 * @since 1.2
 */
AffineTransform.TYPE_GENERAL_SCALE = 4;
/**
 * This flag bit indicates that the transform defined by this object
 * performs a mirror image flip about some axis which changes the
 * normally right handed coordinate system into a left handed
 * system in addition to the conversions indicated by other flag bits.
 * A right handed coordinate system is one where the positive X
 * axis rotates counterclockwise to overlay the positive Y axis
 * similar to the direction that the fingers on your right hand
 * curl when you stare end on at your thumb.
 * A left handed coordinate system is one where the positive X
 * axis rotates clockwise to overlay the positive Y axis similar
 * to the direction that the fingers on your left hand curl.
 * There is no mathematical way to determine the angle of the
 * original flipping or mirroring transformation since all angles
 * of flip are identical given an appropriate adjusting rotation.
 * @see #TYPE_IDENTITY
 * @see #TYPE_TRANSLATION
 * @see #TYPE_UNIFORM_SCALE
 * @see #TYPE_GENERAL_SCALE
 * @see #TYPE_QUADRANT_ROTATION
 * @see #TYPE_GENERAL_ROTATION
 * @see #TYPE_GENERAL_TRANSFORM
 * @see #getType
 * @since 1.2
 */
AffineTransform.TYPE_FLIP = 64;
/**
 * This flag bit indicates that the transform defined by this object
 * performs a quadrant rotation by some multiple of 90 degrees in
 * addition to the conversions indicated by other flag bits.
 * A rotation changes the angles of vectors by the same amount
 * regardless of the original direction of the vector and without
 * changing the length of the vector.
 * This flag bit is mutually exclusive with the TYPE_GENERAL_ROTATION flag.
 * @see #TYPE_IDENTITY
 * @see #TYPE_TRANSLATION
 * @see #TYPE_UNIFORM_SCALE
 * @see #TYPE_GENERAL_SCALE
 * @see #TYPE_FLIP
 * @see #TYPE_GENERAL_ROTATION
 * @see #TYPE_GENERAL_TRANSFORM
 * @see #getType
 * @since 1.2
 */
AffineTransform.TYPE_QUADRANT_ROTATION = 8;
/**
 * This flag bit indicates that the transform defined by this object
 * performs a rotation by an arbitrary angle in addition to the
 * conversions indicated by other flag bits.
 * A rotation changes the angles of vectors by the same amount
 * regardless of the original direction of the vector and without
 * changing the length of the vector.
 * This flag bit is mutually exclusive with the
 * TYPE_QUADRANT_ROTATION flag.
 * @see #TYPE_IDENTITY
 * @see #TYPE_TRANSLATION
 * @see #TYPE_UNIFORM_SCALE
 * @see #TYPE_GENERAL_SCALE
 * @see #TYPE_FLIP
 * @see #TYPE_QUADRANT_ROTATION
 * @see #TYPE_GENERAL_TRANSFORM
 * @see #getType
 * @since 1.2
 */
AffineTransform.TYPE_GENERAL_ROTATION = 16;
/**
 * This constant indicates that the transform defined by this object
 * performs an arbitrary conversion of the input coordinates.
 * If this transform can be classified by any of the above constants,
 * the type will either be the constant TYPE_IDENTITY or a
 * combination of the appropriate flag bits for the various coordinate
 * conversions that this transform performs.
 * @see #TYPE_IDENTITY
 * @see #TYPE_TRANSLATION
 * @see #TYPE_UNIFORM_SCALE
 * @see #TYPE_GENERAL_SCALE
 * @see #TYPE_FLIP
 * @see #TYPE_QUADRANT_ROTATION
 * @see #TYPE_GENERAL_ROTATION
 * @see #getType
 * @since 1.2
 */
AffineTransform.TYPE_GENERAL_TRANSFORM = 32;
/**
 * This constant is used for the internal state variable to indicate
 * that no calculations need to be performed and that the source
 * coordinates only need to be copied to their destinations to
 * complete the transformation equation of this transform.
 * @see #APPLY_TRANSLATE
 * @see #APPLY_SCALE
 * @see #APPLY_SHEAR
 * @see #state
 */
AffineTransform.APPLY_IDENTITY = 0;
/**
 * This constant is used for the internal state variable to indicate
 * that the translation components of the matrix (m02 and m12) need
 * to be added to complete the transformation equation of this transform.
 * @see #APPLY_IDENTITY
 * @see #APPLY_SCALE
 * @see #APPLY_SHEAR
 * @see #state
 */
AffineTransform.APPLY_TRANSLATE = 1;
/**
 * This constant is used for the internal state variable to indicate
 * that the scaling components of the matrix (m00 and m11) need
 * to be factored in to complete the transformation equation of
 * this transform.  If the APPLY_SHEAR bit is also set then it
 * indicates that the scaling components are not both 0.0.  If the
 * APPLY_SHEAR bit is not also set then it indicates that the
 * scaling components are not both 1.0.  If neither the APPLY_SHEAR
 * nor the APPLY_SCALE bits are set then the scaling components
 * are both 1.0, which means that the x and y components contribute
 * to the transformed coordinate, but they are not multiplied by
 * any scaling factor.
 * @see #APPLY_IDENTITY
 * @see #APPLY_TRANSLATE
 * @see #APPLY_SHEAR
 * @see #state
 */
AffineTransform.APPLY_SCALE = 2;
/**
 * This constant is used for the internal state variable to indicate
 * that the shearing components of the matrix (m01 and m10) need
 * to be factored in to complete the transformation equation of this
 * transform.  The presence of this bit in the state variable changes
 * the interpretation of the APPLY_SCALE bit as indicated in its
 * documentation.
 * @see #APPLY_IDENTITY
 * @see #APPLY_TRANSLATE
 * @see #APPLY_SCALE
 * @see #state
 */
AffineTransform.APPLY_SHEAR = 4;
AffineTransform.HI_SHIFT = 3;
AffineTransform.serialVersionUID = 1330973210523860834;
AffineTransform["__class"] = "AffineTransform";
AffineTransform["__interfaces"] = ["java.lang.Cloneable", "java.io.Serializable"];
/**
 * A utility class to iterate over the path segments of an arc through the
 * PathIterator interface.
 *
 * @author Jim Graham
 */
var ArcIterator = (function () {
    function ArcIterator(a, at) {
        this.x = 0;
        this.y = 0;
        this.w = 0;
        this.h = 0;
        this.angStRad = 0;
        this.increment = 0;
        this.cv = 0;
        this.affine = null;
        this.index = 0;
        this.arcSegs = 0;
        this.lineSegs = 0;
        this.w = a.getWidth() / 2;
        this.h = a.getHeight() / 2;
        this.x = a.getX() + this.w;
        this.y = a.getY() + this.h;
        this.angStRad = -(function (x) { return x * Math.PI / 180; })(a.getAngleStart());
        this.affine = at;
        var ext = -a.getAngleExtent();
        if (ext >= 360.0 || ext <= -360) {
            this.arcSegs = 4;
            this.increment = Math.PI / 2;
            this.cv = 0.5522847498307933;
            if (ext < 0) {
                this.increment = -this.increment;
                this.cv = -this.cv;
            }
        }
        else {
            this.arcSegs = (Math.ceil(Math.abs(ext) / 90.0) | 0);
            this.increment = (function (x) { return x * Math.PI / 180; })(ext / this.arcSegs);
            this.cv = ArcIterator.btan(this.increment);
            if (this.cv === 0) {
                this.arcSegs = 0;
            }
        }
        switch ((a.getArcType())) {
            case Arc2D.OPEN:
                this.lineSegs = 0;
                break;
            case Arc2D.CHORD:
                this.lineSegs = 1;
                break;
            case Arc2D.PIE:
                this.lineSegs = 2;
                break;
        }
        if (this.w < 0 || this.h < 0) {
            this.arcSegs = this.lineSegs = -1;
        }
    }
    /**
     * Return the winding rule for determining the insideness of the path.
     *
     * @see #WIND_EVEN_ODD
     * @see #WIND_NON_ZERO
     * @return {number}
     */
    ArcIterator.prototype.getWindingRule = function () {
        return PathIterator.WIND_NON_ZERO;
    };
    /**
     * Tests if there are more points to read.
     *
     * @return {boolean} true if there are more points to read
     */
    ArcIterator.prototype.isDone = function () {
        return this.index > this.arcSegs + this.lineSegs;
    };
    /**
     * Moves the iterator to the next segment of the path forwards along the
     * primary direction of traversal as long as there are more points in that
     * direction.
     */
    ArcIterator.prototype.next = function () {
        this.index++;
    };
    ArcIterator.btan = function (increment) {
        increment /= 2.0;
        return 4.0 / 3.0 * Math.sin(increment) / (1.0 + Math.cos(increment));
    };
    /**
     * Returns the coordinates and type of the current path segment in the
     * iteration. The return value is the path segment type: SEG_MOVETO,
     * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
     * length 6 must be passed in and may be used to store the coordinates of
     * the point(s). Each point is stored as a pair of float x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
     * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
     * not return any points.
     *
     * @see #SEG_MOVETO
     * @see #SEG_LINETO
     * @see #SEG_QUADTO
     * @see #SEG_CUBICTO
     * @see #SEG_CLOSE
     * @param {Array} coords
     * @return {number}
     */
    ArcIterator.prototype.currentSegment$float_A = function (coords) {
        if (this.isDone()) {
            throw Object.defineProperty(new Error("arc iterator out of bounds"), '__class', { configurable: true, value: 'java.util.NoSuchElementException' });
        }
        var angle = this.angStRad;
        if (this.index === 0) {
            coords[0] = (this.x + Math.cos(angle) * this.w);
            coords[1] = (this.y + Math.sin(angle) * this.h);
            if (this.affine != null) {
                this.affine.transform$float_A$int$float_A$int$int(coords, 0, coords, 0, 1);
            }
            return PathIterator.SEG_MOVETO;
        }
        if (this.index > this.arcSegs) {
            if (this.index === this.arcSegs + this.lineSegs) {
                return PathIterator.SEG_CLOSE;
            }
            coords[0] = this.x;
            coords[1] = this.y;
            if (this.affine != null) {
                this.affine.transform$float_A$int$float_A$int$int(coords, 0, coords, 0, 1);
            }
            return PathIterator.SEG_LINETO;
        }
        angle += this.increment * (this.index - 1);
        var relx = Math.cos(angle);
        var rely = Math.sin(angle);
        coords[0] = (this.x + (relx - this.cv * rely) * this.w);
        coords[1] = (this.y + (rely + this.cv * relx) * this.h);
        angle += this.increment;
        relx = Math.cos(angle);
        rely = Math.sin(angle);
        coords[2] = (this.x + (relx + this.cv * rely) * this.w);
        coords[3] = (this.y + (rely - this.cv * relx) * this.h);
        coords[4] = (this.x + relx * this.w);
        coords[5] = (this.y + rely * this.h);
        if (this.affine != null) {
            this.affine.transform$float_A$int$float_A$int$int(coords, 0, coords, 0, 3);
        }
        return PathIterator.SEG_CUBICTO;
    };
    /**
     * Returns the coordinates and type of the current path segment in the
     * iteration. The return value is the path segment type: SEG_MOVETO,
     * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
     * length 6 must be passed in and may be used to store the coordinates of
     * the point(s). Each point is stored as a pair of float x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
     * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
     * not return any points.
     *
     * @see #SEG_MOVETO
     * @see #SEG_LINETO
     * @see #SEG_QUADTO
     * @see #SEG_CUBICTO
     * @see #SEG_CLOSE
     * @param {Array} coords
     * @return {number}
     */
    ArcIterator.prototype.currentSegment = function (coords) {
        if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
            return this.currentSegment$float_A(coords);
        }
        else if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
            return this.currentSegment$double_A(coords);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Returns the coordinates and type of the current path segment in the
     * iteration. The return value is the path segment type: SEG_MOVETO,
     * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A double array of
     * length 6 must be passed in and may be used to store the coordinates of
     * the point(s). Each point is stored as a pair of double x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
     * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
     * not return any points.
     *
     * @see #SEG_MOVETO
     * @see #SEG_LINETO
     * @see #SEG_QUADTO
     * @see #SEG_CUBICTO
     * @see #SEG_CLOSE
     * @param {Array} coords
     * @return {number}
     */
    ArcIterator.prototype.currentSegment$double_A = function (coords) {
        if (this.isDone()) {
            throw Object.defineProperty(new Error("arc iterator out of bounds"), '__class', { configurable: true, value: 'java.util.NoSuchElementException' });
        }
        var angle = this.angStRad;
        if (this.index === 0) {
            coords[0] = this.x + Math.cos(angle) * this.w;
            coords[1] = this.y + Math.sin(angle) * this.h;
            if (this.affine != null) {
                this.affine.transform$double_A$int$double_A$int$int(coords, 0, coords, 0, 1);
            }
            return PathIterator.SEG_MOVETO;
        }
        if (this.index > this.arcSegs) {
            if (this.index === this.arcSegs + this.lineSegs) {
                return PathIterator.SEG_CLOSE;
            }
            coords[0] = this.x;
            coords[1] = this.y;
            if (this.affine != null) {
                this.affine.transform$double_A$int$double_A$int$int(coords, 0, coords, 0, 1);
            }
            return PathIterator.SEG_LINETO;
        }
        angle += this.increment * (this.index - 1);
        var relx = Math.cos(angle);
        var rely = Math.sin(angle);
        coords[0] = this.x + (relx - this.cv * rely) * this.w;
        coords[1] = this.y + (rely + this.cv * relx) * this.h;
        angle += this.increment;
        relx = Math.cos(angle);
        rely = Math.sin(angle);
        coords[2] = this.x + (relx + this.cv * rely) * this.w;
        coords[3] = this.y + (rely - this.cv * relx) * this.h;
        coords[4] = this.x + relx * this.w;
        coords[5] = this.y + rely * this.h;
        if (this.affine != null) {
            this.affine.transform$double_A$int$double_A$int$int(coords, 0, coords, 0, 3);
        }
        return PathIterator.SEG_CUBICTO;
    };
    return ArcIterator;
}());
ArcIterator["__class"] = "ArcIterator";
ArcIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
/**
 * The <code>Area</code> class creates an area geometry from the specified
 * {@link Shape} object. The geometry is explicitly closed, if the
 * <code>Shape</code> is not already closed. The fill rule (even-odd or
 * winding) specified by the geometry of the <code>Shape</code> is used to
 * determine the resulting enclosed area.
 *
 * @param {java.awt.Shape} s
 * the <code>Shape</code> from which the area is constructed
 * @throws NullPointerException
 * if <code>s</code> is null
 * @since 1.2
 * @class
 */
var Area = (function () {
    function Area(s) {
        var _this = this;
        if (((s != null && (s["__interfaces"] != null && s["__interfaces"].indexOf("java.awt.Shape") >= 0 || s.constructor != null && s.constructor["__interfaces"] != null && s.constructor["__interfaces"].indexOf("java.awt.Shape") >= 0)) || s === null)) {
            var __args = Array.prototype.slice.call(arguments);
            this.curves = null;
            this.cachedBounds = null;
            this.curves = null;
            this.cachedBounds = null;
            (function () {
                if (s != null && s instanceof Area) {
                    _this.curves = s.curves;
                }
                else {
                    _this.curves = Area.pathToCurves(s['getPathIterator$java_awt_geom_AffineTransform'](null));
                }
            })();
        }
        else if (s === undefined) {
            var __args = Array.prototype.slice.call(arguments);
            this.curves = null;
            this.cachedBounds = null;
            this.curves = null;
            this.cachedBounds = null;
            (function () {
                _this.curves = Area.EmptyCurves_$LI$();
            })();
        }
        else
            throw new Error('invalid overload');
    }
    Area.EmptyCurves_$LI$ = function () { if (Area.EmptyCurves == null)
        Area.EmptyCurves = ([]); return Area.EmptyCurves; };
    ;
    Area.pathToCurves = function (pi) {
        var curves = ([]);
        var windingRule = pi.getWindingRule();
        var coords = (function (s) { var a = []; while (s-- > 0)
            a.push(0); return a; })(23);
        var movx = 0;
        var movy = 0;
        var curx = 0;
        var cury = 0;
        var newx;
        var newy;
        while ((!pi.isDone())) {
            switch ((pi['currentSegment$double_A'](coords))) {
                case PathIterator.SEG_MOVETO:
                    sun.awt.geom.Curve.insertLine(curves, curx, cury, movx, movy);
                    curx = movx = coords[0];
                    cury = movy = coords[1];
                    sun.awt.geom.Curve.insertMove(curves, movx, movy);
                    break;
                case PathIterator.SEG_LINETO:
                    newx = coords[0];
                    newy = coords[1];
                    sun.awt.geom.Curve.insertLine(curves, curx, cury, newx, newy);
                    curx = newx;
                    cury = newy;
                    break;
                case PathIterator.SEG_QUADTO:
                    newx = coords[2];
                    newy = coords[3];
                    sun.awt.geom.Curve.insertQuad(curves, curx, cury, coords);
                    curx = newx;
                    cury = newy;
                    break;
                case PathIterator.SEG_CUBICTO:
                    newx = coords[4];
                    newy = coords[5];
                    sun.awt.geom.Curve.insertCubic(curves, curx, cury, coords);
                    curx = newx;
                    cury = newy;
                    break;
                case PathIterator.SEG_CLOSE:
                    sun.awt.geom.Curve.insertLine(curves, curx, cury, movx, movy);
                    curx = movx;
                    cury = movy;
                    break;
            }
            pi.next();
        }
        ;
        sun.awt.geom.Curve.insertLine(curves, curx, cury, movx, movy);
        var operator;
        if (windingRule === PathIterator.WIND_EVEN_ODD) {
            operator = new sun.awt.geom.AreaOp.EOWindOp();
        }
        else {
            operator = new sun.awt.geom.AreaOp.NZWindOp();
        }
        return operator.calculate(curves, Area.EmptyCurves_$LI$());
    };
    /**
     * Adds the shape of the specified <code>Area</code> to the shape of this
     * <code>Area</code>. The resulting shape of this <code>Area</code> will
     * include the union of both shapes, or all areas that were contained in
     * either this or the specified <code>Area</code>.
     *
     * <pre>
     * // Example:
     * Area a1 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 0,8]);
     * Area a2 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 8,8]);
     * a1.add(a2);
     *
     * a1(before)     +         a2         =     a1(after)
     *
     * ################     ################     ################
     * ##############         ##############     ################
     * ############             ############     ################
     * ##########                 ##########     ################
     * ########                     ########     ################
     * ######                         ######     ######    ######
     * ####                             ####     ####        ####
     * ##                                 ##     ##            ##
     * </pre>
     *
     * @param {Area} rhs
     * the <code>Area</code> to be added to the current shape
     * @throws NullPointerException
     * if <code>rhs</code> is null
     * @since 1.2
     */
    Area.prototype.add = function (rhs) {
        this.curves = new sun.awt.geom.AreaOp.AddOp().calculate(this.curves, rhs.curves);
        this.invalidateBounds();
    };
    /**
     * Subtracts the shape of the specified <code>Area</code> from the shape of
     * this <code>Area</code>. The resulting shape of this <code>Area</code>
     * will include areas that were contained only in this <code>Area</code> and
     * not in the specified <code>Area</code>.
     *
     * <pre>
     * // Example:
     * Area a1 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 0,8]);
     * Area a2 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 8,8]);
     * a1.subtract(a2);
     *
     * a1(before)     -         a2         =     a1(after)
     *
     * ################     ################
     * ##############         ##############     ##
     * ############             ############     ####
     * ##########                 ##########     ######
     * ########                     ########     ########
     * ######                         ######     ######
     * ####                             ####     ####
     * ##                                 ##     ##
     * </pre>
     *
     * @param {Area} rhs
     * the <code>Area</code> to be subtracted from the current shape
     * @throws NullPointerException
     * if <code>rhs</code> is null
     * @since 1.2
     */
    Area.prototype.subtract = function (rhs) {
        this.curves = new sun.awt.geom.AreaOp.SubOp().calculate(this.curves, rhs.curves);
        this.invalidateBounds();
    };
    /**
     * Sets the shape of this <code>Area</code> to the intersection of its
     * current shape and the shape of the specified <code>Area</code>. The
     * resulting shape of this <code>Area</code> will include only areas that
     * were contained in both this <code>Area</code> and also in the specified
     * <code>Area</code>.
     *
     * <pre>
     * // Example:
     * Area a1 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 0,8]);
     * Area a2 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 8,8]);
     * a1.intersect(a2);
     *
     * a1(before)   intersect     a2         =     a1(after)
     *
     * ################     ################     ################
     * ##############         ##############       ############
     * ############             ############         ########
     * ##########                 ##########           ####
     * ########                     ########
     * ######                         ######
     * ####                             ####
     * ##                                 ##
     * </pre>
     *
     * @param {Area} rhs
     * the <code>Area</code> to be intersected with this
     * <code>Area</code>
     * @throws NullPointerException
     * if <code>rhs</code> is null
     * @since 1.2
     */
    Area.prototype.intersect = function (rhs) {
        this.curves = new sun.awt.geom.AreaOp.IntOp().calculate(this.curves, rhs.curves);
        this.invalidateBounds();
    };
    /**
     * Sets the shape of this <code>Area</code> to be the combined area of its
     * current shape and the shape of the specified <code>Area</code>, minus
     * their intersection. The resulting shape of this <code>Area</code> will
     * include only areas that were contained in either this <code>Area</code>
     * or in the specified <code>Area</code>, but not in both.
     *
     * <pre>
     * // Example:
     * Area a1 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 0,8]);
     * Area a2 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 8,8]);
     * a1.exclusiveOr(a2);
     *
     * a1(before)    xor        a2         =     a1(after)
     *
     * ################     ################
     * ##############         ##############     ##            ##
     * ############             ############     ####        ####
     * ##########                 ##########     ######    ######
     * ########                     ########     ################
     * ######                         ######     ######    ######
     * ####                             ####     ####        ####
     * ##                                 ##     ##            ##
     * </pre>
     *
     * @param {Area} rhs
     * the <code>Area</code> to be exclusive ORed with this
     * <code>Area</code>.
     * @throws NullPointerException
     * if <code>rhs</code> is null
     * @since 1.2
     */
    Area.prototype.exclusiveOr = function (rhs) {
        this.curves = new sun.awt.geom.AreaOp.XorOp().calculate(this.curves, rhs.curves);
        this.invalidateBounds();
    };
    /**
     * Removes all of the geometry from this <code>Area</code> and restores it
     * to an empty area.
     *
     * @since 1.2
     */
    Area.prototype.reset = function () {
        this.curves = ([]);
        this.invalidateBounds();
    };
    /**
     * Tests whether this <code>Area</code> object encloses any area.
     *
     * @return {boolean} <code>true</code> if this <code>Area</code> object represents an
     * empty area; <code>false</code> otherwise.
     * @since 1.2
     */
    Area.prototype.isEmpty = function () {
        return (this.curves.length === 0);
    };
    /**
     * Tests whether this <code>Area</code> consists entirely of straight edged
     * polygonal geometry.
     *
     * @return {boolean} <code>true</code> if the geometry of this <code>Area</code>
     * consists entirely of line segments; <code>false</code> otherwise.
     * @since 1.2
     */
    Area.prototype.isPolygonal = function () {
        var enum_ = (function (a) { var i = 0; return { nextElement: function () { return i < a.length ? a[i++] : null; }, hasMoreElements: function () { return i < a.length; } }; })(this.curves);
        while ((enum_.hasMoreElements())) {
            if (enum_.nextElement().getOrder() > 1) {
                return false;
            }
        }
        ;
        return true;
    };
    /**
     * Tests whether this <code>Area</code> is rectangular in shape.
     *
     * @return {boolean} <code>true</code> if the geometry of this <code>Area</code> is
     * rectangular in shape; <code>false</code> otherwise.
     * @since 1.2
     */
    Area.prototype.isRectangular = function () {
        var size = this.curves.length;
        if (size === 0) {
            return true;
        }
        if (size > 3) {
            return false;
        }
        var c1 = this.curves[1];
        var c2 = this.curves[2];
        if (c1.getOrder() !== 1 || c2.getOrder() !== 1) {
            return false;
        }
        if (c1.getXTop() !== c1.getXBot() || c2.getXTop() !== c2.getXBot()) {
            return false;
        }
        if (c1.getYTop() !== c2.getYTop() || c1.getYBot() !== c2.getYBot()) {
            return false;
        }
        return true;
    };
    /**
     * Tests whether this <code>Area</code> is comprised of a single closed
     * subpath. This method returns <code>true</code> if the path contains 0 or
     * 1 subpaths, or <code>false</code> if the path contains more than 1
     * subpath. The subpaths are counted by the number of
     * {@link PathIterator#SEG_MOVETO} segments that appear in the
     * path.
     *
     * @return {boolean} <code>true</code> if the <code>Area</code> is comprised of a
     * single basic geometry; <code>false</code> otherwise.
     * @since 1.2
     */
    Area.prototype.isSingular = function () {
        if (this.curves.length < 3) {
            return true;
        }
        var enum_ = (function (a) { var i = 0; return { nextElement: function () { return i < a.length ? a[i++] : null; }, hasMoreElements: function () { return i < a.length; } }; })(this.curves);
        enum_.nextElement();
        while ((enum_.hasMoreElements())) {
            if (enum_.nextElement().getOrder() === 0) {
                return false;
            }
        }
        ;
        return true;
    };
    Area.prototype.invalidateBounds = function () {
        this.cachedBounds = null;
    };
    Area.prototype.getCachedBounds = function () {
        if (this.cachedBounds != null) {
            return this.cachedBounds;
        }
        var r = new Rectangle2D.Double();
        if (this.curves.length > 0) {
            var c = this.curves[0];
            r.setRect$double$double$double$double(c.getX0(), c.getY0(), 0, 0);
            for (var i = 1; i < this.curves.length; i++) {
                this.curves[i].enlarge(r);
            }
        }
        return (this.cachedBounds = r);
    };
    /**
     * Returns a high precision bounding {@link Rectangle2D} that completely
     * encloses this <code>Area</code>.
     * <p>
     * The Area class will attempt to return the tightest bounding box possible
     * for the Shape. The bounding box will not be padded to include the control
     * points of curves in the outline of the Shape, but should tightly fit the
     * actual geometry of the outline itself.
     *
     * @return {Rectangle2D} the bounding <code>Rectangle2D</code> for the <code>Area</code>.
     * @since 1.2
     */
    Area.prototype.getBounds2D = function () {
        return this.getCachedBounds().getBounds2D();
    };
    /**
     * Returns an exact copy of this <code>Area</code> object.
     *
     * @return {*} Created clone object
     * @since 1.2
     */
    Area.prototype.clone = function () {
        return new Area(this);
    };
    /**
     * Tests whether the geometries of the two <code>Area</code> objects are
     * equal. This method will return false if the argument is null.
     *
     * @param {Area} other
     * the <code>Area</code> to be compared to this <code>Area</code>
     * @return {boolean} <code>true</code> if the two geometries are equal;
     * <code>false</code> otherwise.
     * @since 1.2
     */
    Area.prototype.equals = function (other) {
        if (other === this) {
            return true;
        }
        if (other == null) {
            return false;
        }
        var c = new sun.awt.geom.AreaOp.XorOp().calculate(this.curves, other.curves);
        return (c.length == 0);
    };
    /**
     * Transforms the geometry of this <code>Area</code> using the specified
     * {@link AffineTransform}. The geometry is transformed in place, which
     * permanently changes the enclosed area defined by this object.
     *
     * @param {AffineTransform} t
     * the transformation used to transform the area
     * @throws NullPointerException
     * if <code>t</code> is null
     * @since 1.2
     */
    Area.prototype.transform = function (t) {
        if (t == null) {
            throw Object.defineProperty(new Error("transform must not be null"), '__class', { configurable: true, value: 'java.lang.NullPointerException' });
        }
        this.curves = Area.pathToCurves(this.getPathIterator$java_awt_geom_AffineTransform(t));
        this.invalidateBounds();
    };
    /**
     * Creates a new <code>Area</code> object that contains the same geometry as
     * this <code>Area</code> transformed by the specified
     * <code>AffineTransform</code>. This <code>Area</code> object is unchanged.
     *
     * @param {AffineTransform} t
     * the specified <code>AffineTransform</code> used to transform
     * the new <code>Area</code>
     * @throws NullPointerException
     * if <code>t</code> is null
     * @return {Area} a new <code>Area</code> object representing the transformed
     * geometry.
     * @since 1.2
     */
    Area.prototype.createTransformedArea = function (t) {
        var a = new Area(this);
        a.transform(t);
        return a;
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @return {boolean}
     */
    Area.prototype.contains$double$double = function (x, y) {
        if (!this.getCachedBounds().contains$double$double(x, y)) {
            return false;
        }
        var enum_ = (function (a) { var i = 0; return { nextElement: function () { return i < a.length ? a[i++] : null; }, hasMoreElements: function () { return i < a.length; } }; })(this.curves);
        var crossings = 0;
        while ((enum_.hasMoreElements())) {
            var c = enum_.nextElement();
            crossings += c.crossingsFor(x, y);
        }
        ;
        return ((crossings & 1) === 1);
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {Point2D} p
     * @return {boolean}
     */
    Area.prototype.contains$java_awt_geom_Point2D = function (p) {
        return this.contains$double$double(p.getX(), p.getY());
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @return {boolean}
     */
    Area.prototype.contains$double$double$double$double = function (x, y, w, h) {
        if (w < 0 || h < 0) {
            return false;
        }
        if (!this.getCachedBounds().contains$double$double$double$double(x, y, w, h)) {
            return false;
        }
        var c = sun.awt.geom.Crossings.findCrossings$java_util_Vector$double$double$double$double(this.curves, x, y, x + w, y + h);
        return (c != null && c.covers(y, y + h));
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @return {boolean}
     */
    Area.prototype.contains = function (x, y, w, h) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
            return this.contains$double$double$double$double(x, y, w, h);
        }
        else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined) {
            return this.contains$double$double(x, y);
        }
        else if (((x != null && x instanceof Point2D) || x === null) && y === undefined && w === undefined && h === undefined) {
            return this.contains$java_awt_geom_Point2D(x);
        }
        else if (((x != null && x instanceof Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
            return this.contains$java_awt_geom_Rectangle2D(x);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {Rectangle2D} r
     * @return {boolean}
     */
    Area.prototype.contains$java_awt_geom_Rectangle2D = function (r) {
        return this.contains$double$double$double$double(r.getX(), r.getY(), r.getWidth(), r.getHeight());
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @return {boolean}
     */
    Area.prototype.intersects$double$double$double$double = function (x, y, w, h) {
        if (w < 0 || h < 0) {
            return false;
        }
        if (!this.getCachedBounds().intersects$double$double$double$double(x, y, w, h)) {
            return false;
        }
        var c = sun.awt.geom.Crossings.findCrossings$java_util_Vector$double$double$double$double(this.curves, x, y, x + w, y + h);
        return (c == null || !c.isEmpty());
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @return {boolean}
     */
    Area.prototype.intersects = function (x, y, w, h) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
            return this.intersects$double$double$double$double(x, y, w, h);
        }
        else if (((x != null && x instanceof Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
            return this.intersects$java_awt_geom_Rectangle2D(x);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {Rectangle2D} r
     * @return {boolean}
     */
    Area.prototype.intersects$java_awt_geom_Rectangle2D = function (r) {
        return this.intersects$double$double$double$double(r.getX(), r.getY(), r.getWidth(), r.getHeight());
    };
    /**
     * Creates a {@link PathIterator} for the outline of this <code>Area</code>
     * object. This <code>Area</code> object is unchanged.
     *
     * @param {AffineTransform} at
     * an optional <code>AffineTransform</code> to be applied to the
     * coordinates as they are returned in the iteration, or
     * <code>null</code> if untransformed coordinates are desired
     * @return {PathIterator} the <code>PathIterator</code> object that returns the geometry of
     * the outline of this <code>Area</code>, one segment at a time.
     * @since 1.2
     */
    Area.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
        return new AreaIterator(this.curves, at);
    };
    /**
     * Creates a <code>PathIterator</code> for the flattened outline of this
     * <code>Area</code> object. Only uncurved path segments represented by the
     * SEG_MOVETO, SEG_LINETO, and SEG_CLOSE point types are returned by the
     * iterator. This <code>Area</code> object is unchanged.
     *
     * @param {AffineTransform} at
     * an optional <code>AffineTransform</code> to be applied to the
     * coordinates as they are returned in the iteration, or
     * <code>null</code> if untransformed coordinates are desired
     * @param {number} flatness
     * the maximum amount that the control points for a given curve
     * can vary from colinear before a subdivided curve is replaced
     * by a straight line connecting the end points
     * @return {PathIterator} the <code>PathIterator</code> object that returns the geometry of
     * the outline of this <code>Area</code>, one segment at a time.
     * @since 1.2
     */
    Area.prototype.getPathIterator$java_awt_geom_AffineTransform$double = function (at, flatness) {
        return new FlatteningPathIterator(this.getPathIterator$java_awt_geom_AffineTransform(at), flatness);
    };
    /**
     * Creates a <code>PathIterator</code> for the flattened outline of this
     * <code>Area</code> object. Only uncurved path segments represented by the
     * SEG_MOVETO, SEG_LINETO, and SEG_CLOSE point types are returned by the
     * iterator. This <code>Area</code> object is unchanged.
     *
     * @param {AffineTransform} at
     * an optional <code>AffineTransform</code> to be applied to the
     * coordinates as they are returned in the iteration, or
     * <code>null</code> if untransformed coordinates are desired
     * @param {number} flatness
     * the maximum amount that the control points for a given curve
     * can vary from colinear before a subdivided curve is replaced
     * by a straight line connecting the end points
     * @return {PathIterator} the <code>PathIterator</code> object that returns the geometry of
     * the outline of this <code>Area</code>, one segment at a time.
     * @since 1.2
     */
    Area.prototype.getPathIterator = function (at, flatness) {
        if (((at != null && at instanceof AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
            return this.getPathIterator$java_awt_geom_AffineTransform$double(at, flatness);
        }
        else if (((at != null && at instanceof AffineTransform) || at === null) && flatness === undefined) {
            return this.getPathIterator$java_awt_geom_AffineTransform(at);
        }
        else
            throw new Error('invalid overload');
    };
    return Area;
}());
Area["__class"] = "Area";
Area["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable"];
var AreaIterator = (function () {
    function AreaIterator(curves, at) {
        this.transform = null;
        this.curves = null;
        this.index = 0;
        this.prevcurve = null;
        this.thiscurve = null;
        this.curves = curves;
        this.transform = at;
        if (curves.length >= 1) {
            this.thiscurve = curves[0];
        }
    }
    AreaIterator.prototype.getWindingRule = function () {
        return PathIterator.WIND_NON_ZERO;
    };
    AreaIterator.prototype.isDone = function () {
        return (this.prevcurve == null && this.thiscurve == null);
    };
    AreaIterator.prototype.next = function () {
        if (this.prevcurve != null) {
            this.prevcurve = null;
        }
        else {
            this.prevcurve = this.thiscurve;
            this.index++;
            if (this.index < this.curves.length) {
                this.thiscurve = this.curves[this.index];
                if (this.thiscurve.getOrder() !== 0 && this.prevcurve.getX1() === this.thiscurve.getX0() && this.prevcurve.getY1() === this.thiscurve.getY0()) {
                    this.prevcurve = null;
                }
            }
            else {
                this.thiscurve = null;
            }
        }
    };
    AreaIterator.prototype.currentSegment$float_A = function (coords) {
        var dcoords = [0, 0, 0, 0, 0, 0];
        var segtype = this.currentSegment$double_A(dcoords);
        var numpoints = (segtype === PathIterator.SEG_CLOSE ? 0 : (segtype === PathIterator.SEG_QUADTO ? 2 : (segtype === PathIterator.SEG_CUBICTO ? 3 : 1)));
        for (var i = 0; i < numpoints * 2; i++) {
            coords[i] = dcoords[i];
        }
        return segtype;
    };
    AreaIterator.prototype.currentSegment = function (coords) {
        if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
            return this.currentSegment$float_A(coords);
        }
        else if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
            return this.currentSegment$double_A(coords);
        }
        else
            throw new Error('invalid overload');
    };
    AreaIterator.prototype.currentSegment$double_A = function (coords) {
        var segtype;
        var numpoints;
        if (this.prevcurve != null) {
            if (this.thiscurve == null || this.thiscurve.getOrder() === 0) {
                return PathIterator.SEG_CLOSE;
            }
            coords[0] = this.thiscurve.getX0();
            coords[1] = this.thiscurve.getY0();
            segtype = PathIterator.SEG_LINETO;
            numpoints = 1;
        }
        else if (this.thiscurve == null) {
            throw Object.defineProperty(new Error("area iterator out of bounds"), '__class', { configurable: true, value: 'java.util.NoSuchElementException' });
        }
        else {
            segtype = this.thiscurve.getSegment(coords);
            numpoints = this.thiscurve.getOrder();
            if (numpoints === 0) {
                numpoints = 1;
            }
        }
        if (this.transform != null) {
            this.transform.transform$double_A$int$double_A$int$int(coords, 0, coords, 0, numpoints);
        }
        return segtype;
    };
    return AreaIterator;
}());
AreaIterator["__class"] = "AreaIterator";
AreaIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
/**
 * This is an abstract class that cannot be instantiated directly.
 * Type-specific implementation subclasses are available for instantiation
 * and provide a number of formats for storing the information necessary to
 * satisfy the various accessor methods below.
 *
 * @see java.awt.geom.CubicCurve2D.Float
 * @see java.awt.geom.CubicCurve2D.Double
 * @since 1.2
 * @class
 */
var CubicCurve2D = (function () {
    function CubicCurve2D() {
    }
    /**
     * Sets the location of the end points and control points of this curve
     * to the specified {@code float} coordinates.
     *
     * @param {number} x1
     * the X coordinate used to set the start point of this
     * {@code CubicCurve2D}
     * @param {number} y1
     * the Y coordinate used to set the start point of this
     * {@code CubicCurve2D}
     * @param {number} ctrlx1
     * the X coordinate used to set the first control point of
     * this {@code CubicCurve2D}
     * @param {number} ctrly1
     * the Y coordinate used to set the first control point of
     * this {@code CubicCurve2D}
     * @param {number} ctrlx2
     * the X coordinate used to set the second control point of
     * this {@code CubicCurve2D}
     * @param {number} ctrly2
     * the Y coordinate used to set the second control point of
     * this {@code CubicCurve2D}
     * @param {number} x2
     * the X coordinate used to set the end point of this
     * {@code CubicCurve2D}
     * @param {number} y2
     * the Y coordinate used to set the end point of this
     * {@code CubicCurve2D}
     * @since 1.2
     */
    CubicCurve2D.prototype.setCurve = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
            return this.setCurve$double$double$double$double$double$double$double$double(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2);
        }
        else if (((x1 != null && x1 instanceof Point2D) || x1 === null) && ((y1 != null && y1 instanceof Point2D) || y1 === null) && ((ctrlx1 != null && ctrlx1 instanceof Point2D) || ctrlx1 === null) && ((ctrly1 != null && ctrly1 instanceof Point2D) || ctrly1 === null) && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
            return this.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1, ctrlx1, ctrly1);
        }
        else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (typeof x1[0] === 'number'))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
            return this.setCurve$double_A$int(x1, y1);
        }
        else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (x1[0] != null && x1[0] instanceof Point2D))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
            return this.setCurve$java_awt_geom_Point2D_A$int(x1, y1);
        }
        else if (((x1 != null && x1 instanceof CubicCurve2D) || x1 === null) && y1 === undefined && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
            return this.setCurve$java_awt_geom_CubicCurve2D(x1);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Sets the location of the end points and control points of this curve to
     * the specified double coordinates.
     *
     * @param {number} x1
     * the X coordinate used to set the start point of this
     * {@code CubicCurve2D}
     * @param {number} y1
     * the Y coordinate used to set the start point of this
     * {@code CubicCurve2D}
     * @param {number} ctrlx1
     * the X coordinate used to set the first control point of this
     * {@code CubicCurve2D}
     * @param {number} ctrly1
     * the Y coordinate used to set the first control point of this
     * {@code CubicCurve2D}
     * @param {number} ctrlx2
     * the X coordinate used to set the second control point of this
     * {@code CubicCurve2D}
     * @param {number} ctrly2
     * the Y coordinate used to set the second control point of this
     * {@code CubicCurve2D}
     * @param {number} x2
     * the X coordinate used to set the end point of this
     * {@code CubicCurve2D}
     * @param {number} y2
     * the Y coordinate used to set the end point of this
     * {@code CubicCurve2D}
     * @since 1.2
     */
    CubicCurve2D.prototype.setCurve$double$double$double$double$double$double$double$double = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
    /**
     * Sets the location of the end points and control points of this curve to
     * the double coordinates at the specified offset in the specified array.
     *
     * @param {Array} coords
     * a double array containing coordinates
     * @param {number} offset
     * the index of <code>coords</code> from which to begin setting
     * the end points and control points of this curve to the
     * coordinates contained in <code>coords</code>
     * @since 1.2
     */
    CubicCurve2D.prototype.setCurve$double_A$int = function (coords, offset) {
        this.setCurve$double$double$double$double$double$double$double$double(coords[offset + 0], coords[offset + 1], coords[offset + 2], coords[offset + 3], coords[offset + 4], coords[offset + 5], coords[offset + 6], coords[offset + 7]);
    };
    /**
     * Sets the location of the end points and control points of this curve to
     * the specified <code>Point2D</code> coordinates.
     *
     * @param {Point2D} p1
     * the first specified <code>Point2D</code> used to set the start
     * point of this curve
     * @param {Point2D} cp1
     * the second specified <code>Point2D</code> used to set the
     * first control point of this curve
     * @param {Point2D} cp2
     * the third specified <code>Point2D</code> used to set the
     * second control point of this curve
     * @param {Point2D} p2
     * the fourth specified <code>Point2D</code> used to set the end
     * point of this curve
     * @since 1.2
     */
    CubicCurve2D.prototype.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D = function (p1, cp1, cp2, p2) {
        this.setCurve$double$double$double$double$double$double$double$double(p1.getX(), p1.getY(), cp1.getX(), cp1.getY(), cp2.getX(), cp2.getY(), p2.getX(), p2.getY());
    };
    /**
     * Sets the location of the end points and control points of this curve to
     * the coordinates of the <code>Point2D</code> objects at the specified
     * offset in the specified array.
     *
     * @param {Array} pts
     * an array of <code>Point2D</code> objects
     * @param {number} offset
     * the index of <code>pts</code> from which to begin setting the
     * end points and control points of this curve to the points
     * contained in <code>pts</code>
     * @since 1.2
     */
    CubicCurve2D.prototype.setCurve$java_awt_geom_Point2D_A$int = function (pts, offset) {
        this.setCurve$double$double$double$double$double$double$double$double(pts[offset + 0].getX(), pts[offset + 0].getY(), pts[offset + 1].getX(), pts[offset + 1].getY(), pts[offset + 2].getX(), pts[offset + 2].getY(), pts[offset + 3].getX(), pts[offset + 3].getY());
    };
    /**
     * Sets the location of the end points and control points of this curve to
     * the same as those in the specified <code>CubicCurve2D</code>.
     *
     * @param {CubicCurve2D} c
     * the specified <code>CubicCurve2D</code>
     * @since 1.2
     */
    CubicCurve2D.prototype.setCurve$java_awt_geom_CubicCurve2D = function (c) {
        this.setCurve$double$double$double$double$double$double$double$double(c.getX1(), c.getY1(), c.getCtrlX1(), c.getCtrlY1(), c.getCtrlX2(), c.getCtrlY2(), c.getX2(), c.getY2());
    };
    /**
     * Returns the square of the flatness of the cubic curve specified by the
     * indicated control points. The flatness is the maximum distance of a
     * control point from the line connecting the end points.
     *
     * @param {number} x1
     * the X coordinate that specifies the start point of a
     * {@code CubicCurve2D}
     * @param {number} y1
     * the Y coordinate that specifies the start point of a
     * {@code CubicCurve2D}
     * @param {number} ctrlx1
     * the X coordinate that specifies the first control point of a
     * {@code CubicCurve2D}
     * @param {number} ctrly1
     * the Y coordinate that specifies the first control point of a
     * {@code CubicCurve2D}
     * @param {number} ctrlx2
     * the X coordinate that specifies the second control point of a
     * {@code CubicCurve2D}
     * @param {number} ctrly2
     * the Y coordinate that specifies the second control point of a
     * {@code CubicCurve2D}
     * @param {number} x2
     * the X coordinate that specifies the end point of a
     * {@code CubicCurve2D}
     * @param {number} y2
     * the Y coordinate that specifies the end point of a
     * {@code CubicCurve2D}
     * @return {number} the square of the flatness of the {@code CubicCurve2D}
     * represented by the specified coordinates.
     * @since 1.2
     */
    CubicCurve2D.getFlatnessSq$double$double$double$double$double$double$double$double = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
        return Math.max(Line2D.ptSegDistSq(x1, y1, x2, y2, ctrlx1, ctrly1), Line2D.ptSegDistSq(x1, y1, x2, y2, ctrlx2, ctrly2));
    };
    /**
     * Returns the square of the flatness of the cubic curve specified by the
     * indicated control points. The flatness is the maximum distance of a
     * control point from the line connecting the end points.
     *
     * @param {number} x1
     * the X coordinate that specifies the start point of a
     * {@code CubicCurve2D}
     * @param {number} y1
     * the Y coordinate that specifies the start point of a
     * {@code CubicCurve2D}
     * @param {number} ctrlx1
     * the X coordinate that specifies the first control point of a
     * {@code CubicCurve2D}
     * @param {number} ctrly1
     * the Y coordinate that specifies the first control point of a
     * {@code CubicCurve2D}
     * @param {number} ctrlx2
     * the X coordinate that specifies the second control point of a
     * {@code CubicCurve2D}
     * @param {number} ctrly2
     * the Y coordinate that specifies the second control point of a
     * {@code CubicCurve2D}
     * @param {number} x2
     * the X coordinate that specifies the end point of a
     * {@code CubicCurve2D}
     * @param {number} y2
     * the Y coordinate that specifies the end point of a
     * {@code CubicCurve2D}
     * @return {number} the square of the flatness of the {@code CubicCurve2D}
     * represented by the specified coordinates.
     * @since 1.2
     */
    CubicCurve2D.getFlatnessSq = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
            return CubicCurve2D.getFlatnessSq$double$double$double$double$double$double$double$double(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2);
        }
        else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (typeof x1[0] === 'number'))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
            return CubicCurve2D.getFlatnessSq$double_A$int(x1, y1);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Returns the flatness of the cubic curve specified by the indicated
     * control points. The flatness is the maximum distance of a control point
     * from the line connecting the end points.
     *
     * @param {number} x1
     * the X coordinate that specifies the start point of a
     * {@code CubicCurve2D}
     * @param {number} y1
     * the Y coordinate that specifies the start point of a
     * {@code CubicCurve2D}
     * @param {number} ctrlx1
     * the X coordinate that specifies the first control point of a
     * {@code CubicCurve2D}
     * @param {number} ctrly1
     * the Y coordinate that specifies the first control point of a
     * {@code CubicCurve2D}
     * @param {number} ctrlx2
     * the X coordinate that specifies the second control point of a
     * {@code CubicCurve2D}
     * @param {number} ctrly2
     * the Y coordinate that specifies the second control point of a
     * {@code CubicCurve2D}
     * @param {number} x2
     * the X coordinate that specifies the end point of a
     * {@code CubicCurve2D}
     * @param {number} y2
     * the Y coordinate that specifies the end point of a
     * {@code CubicCurve2D}
     * @return {number} the flatness of the {@code CubicCurve2D} represented by the
     * specified coordinates.
     * @since 1.2
     */
    CubicCurve2D.getFlatness$double$double$double$double$double$double$double$double = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
        return Math.sqrt(CubicCurve2D.getFlatnessSq$double$double$double$double$double$double$double$double(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2));
    };
    /**
     * Returns the flatness of the cubic curve specified by the indicated
     * control points. The flatness is the maximum distance of a control point
     * from the line connecting the end points.
     *
     * @param {number} x1
     * the X coordinate that specifies the start point of a
     * {@code CubicCurve2D}
     * @param {number} y1
     * the Y coordinate that specifies the start point of a
     * {@code CubicCurve2D}
     * @param {number} ctrlx1
     * the X coordinate that specifies the first control point of a
     * {@code CubicCurve2D}
     * @param {number} ctrly1
     * the Y coordinate that specifies the first control point of a
     * {@code CubicCurve2D}
     * @param {number} ctrlx2
     * the X coordinate that specifies the second control point of a
     * {@code CubicCurve2D}
     * @param {number} ctrly2
     * the Y coordinate that specifies the second control point of a
     * {@code CubicCurve2D}
     * @param {number} x2
     * the X coordinate that specifies the end point of a
     * {@code CubicCurve2D}
     * @param {number} y2
     * the Y coordinate that specifies the end point of a
     * {@code CubicCurve2D}
     * @return {number} the flatness of the {@code CubicCurve2D} represented by the
     * specified coordinates.
     * @since 1.2
     */
    CubicCurve2D.getFlatness = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
            return CubicCurve2D.getFlatness$double$double$double$double$double$double$double$double(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2);
        }
        else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (typeof x1[0] === 'number'))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
            return CubicCurve2D.getFlatness$double_A$int(x1, y1);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Returns the square of the flatness of the cubic curve specified by the
     * control points stored in the indicated array at the indicated index. The
     * flatness is the maximum distance of a control point from the line
     * connecting the end points.
     *
     * @param {Array} coords
     * an array containing coordinates
     * @param {number} offset
     * the index of <code>coords</code> from which to begin getting
     * the end points and control points of the curve
     * @return {number} the square of the flatness of the <code>CubicCurve2D</code>
     * specified by the coordinates in <code>coords</code> at the
     * specified offset.
     * @since 1.2
     */
    CubicCurve2D.getFlatnessSq$double_A$int = function (coords, offset) {
        return CubicCurve2D.getFlatnessSq$double$double$double$double$double$double$double$double(coords[offset + 0], coords[offset + 1], coords[offset + 2], coords[offset + 3], coords[offset + 4], coords[offset + 5], coords[offset + 6], coords[offset + 7]);
    };
    /**
     * Returns the flatness of the cubic curve specified by the control points
     * stored in the indicated array at the indicated index. The flatness is the
     * maximum distance of a control point from the line connecting the end
     * points.
     *
     * @param {Array} coords
     * an array containing coordinates
     * @param {number} offset
     * the index of <code>coords</code> from which to begin getting
     * the end points and control points of the curve
     * @return {number} the flatness of the <code>CubicCurve2D</code> specified by the
     * coordinates in <code>coords</code> at the specified offset.
     * @since 1.2
     */
    CubicCurve2D.getFlatness$double_A$int = function (coords, offset) {
        return CubicCurve2D.getFlatness$double$double$double$double$double$double$double$double(coords[offset + 0], coords[offset + 1], coords[offset + 2], coords[offset + 3], coords[offset + 4], coords[offset + 5], coords[offset + 6], coords[offset + 7]);
    };
    /**
     * Returns the square of the flatness of this curve. The flatness is the
     * maximum distance of a control point from the line connecting the end
     * points.
     *
     * @return {number} the square of the flatness of this curve.
     * @since 1.2
     */
    CubicCurve2D.prototype.getFlatnessSq = function () {
        return CubicCurve2D.getFlatnessSq$double$double$double$double$double$double$double$double(this.getX1(), this.getY1(), this.getCtrlX1(), this.getCtrlY1(), this.getCtrlX2(), this.getCtrlY2(), this.getX2(), this.getY2());
    };
    /**
     * Returns the flatness of this curve. The flatness is the maximum distance
     * of a control point from the line connecting the end points.
     *
     * @return {number} the flatness of this curve.
     * @since 1.2
     */
    CubicCurve2D.prototype.getFlatness = function () {
        return CubicCurve2D.getFlatness$double$double$double$double$double$double$double$double(this.getX1(), this.getY1(), this.getCtrlX1(), this.getCtrlY1(), this.getCtrlX2(), this.getCtrlY2(), this.getX2(), this.getY2());
    };
    /**
     * Subdivides this cubic curve and stores the resulting two subdivided
     * curves into the left and right curve parameters. Either or both of the
     * left and right objects may be the same as this object or null.
     *
     * @param {CubicCurve2D} left
     * the cubic curve object for storing for the left or first half
     * of the subdivided curve
     * @param {CubicCurve2D} right
     * the cubic curve object for storing for the right or second
     * half of the subdivided curve
     * @since 1.2
     */
    CubicCurve2D.prototype.subdivide = function (left, right) {
        CubicCurve2D.subdivide$java_awt_geom_CubicCurve2D$java_awt_geom_CubicCurve2D$java_awt_geom_CubicCurve2D(this, left, right);
    };
    /**
     * Subdivides the cubic curve specified by the <code>src</code> parameter
     * and stores the resulting two subdivided curves into the <code>left</code>
     * and <code>right</code> curve parameters. Either or both of the
     * <code>left</code> and <code>right</code> objects may be the same as the
     * <code>src</code> object or <code>null</code>.
     *
     * @param {CubicCurve2D} src
     * the cubic curve to be subdivided
     * @param {CubicCurve2D} left
     * the cubic curve object for storing the left or first half of
     * the subdivided curve
     * @param {CubicCurve2D} right
     * the cubic curve object for storing the right or second half of
     * the subdivided curve
     * @since 1.2
     */
    CubicCurve2D.subdivide$java_awt_geom_CubicCurve2D$java_awt_geom_CubicCurve2D$java_awt_geom_CubicCurve2D = function (src, left, right) {
        var x1 = src.getX1();
        var y1 = src.getY1();
        var ctrlx1 = src.getCtrlX1();
        var ctrly1 = src.getCtrlY1();
        var ctrlx2 = src.getCtrlX2();
        var ctrly2 = src.getCtrlY2();
        var x2 = src.getX2();
        var y2 = src.getY2();
        var centerx = (ctrlx1 + ctrlx2) / 2.0;
        var centery = (ctrly1 + ctrly2) / 2.0;
        ctrlx1 = (x1 + ctrlx1) / 2.0;
        ctrly1 = (y1 + ctrly1) / 2.0;
        ctrlx2 = (x2 + ctrlx2) / 2.0;
        ctrly2 = (y2 + ctrly2) / 2.0;
        var ctrlx12 = (ctrlx1 + centerx) / 2.0;
        var ctrly12 = (ctrly1 + centery) / 2.0;
        var ctrlx21 = (ctrlx2 + centerx) / 2.0;
        var ctrly21 = (ctrly2 + centery) / 2.0;
        centerx = (ctrlx12 + ctrlx21) / 2.0;
        centery = (ctrly12 + ctrly21) / 2.0;
        if (left != null) {
            left.setCurve$double$double$double$double$double$double$double$double(x1, y1, ctrlx1, ctrly1, ctrlx12, ctrly12, centerx, centery);
        }
        if (right != null) {
            right.setCurve$double$double$double$double$double$double$double$double(centerx, centery, ctrlx21, ctrly21, ctrlx2, ctrly2, x2, y2);
        }
    };
    /**
     * Subdivides the cubic curve specified by the coordinates stored in the
     * <code>src</code> array at indices <code>srcoff</code> through (
     * <code>srcoff</code>&nbsp;+&nbsp;7) and stores the resulting two
     * subdivided curves into the two result arrays at the corresponding
     * indices. Either or both of the <code>left</code> and <code>right</code>
     * arrays may be <code>null</code> or a reference to the same array as the
     * <code>src</code> array. Note that the last point in the first subdivided
     * curve is the same as the first point in the second subdivided curve.
     * Thus, it is possible to pass the same array for <code>left</code> and
     * <code>right</code> and to use offsets, such as <code>rightoff</code>
     * equals (<code>leftoff</code> + 6), in order to avoid allocating extra
     * storage for this common point.
     *
     * @param {Array} src
     * the array holding the coordinates for the source curve
     * @param {number} srcoff
     * the offset into the array of the beginning of the the 6 source
     * coordinates
     * @param {Array} left
     * the array for storing the coordinates for the first half of
     * the subdivided curve
     * @param {number} leftoff
     * the offset into the array of the beginning of the the 6 left
     * coordinates
     * @param {Array} right
     * the array for storing the coordinates for the second half of
     * the subdivided curve
     * @param {number} rightoff
     * the offset into the array of the beginning of the the 6 right
     * coordinates
     * @since 1.2
     */
    CubicCurve2D.subdivide$double_A$int$double_A$int$double_A$int = function (src, srcoff, left, leftoff, right, rightoff) {
        var x1 = src[srcoff + 0];
        var y1 = src[srcoff + 1];
        var ctrlx1 = src[srcoff + 2];
        var ctrly1 = src[srcoff + 3];
        var ctrlx2 = src[srcoff + 4];
        var ctrly2 = src[srcoff + 5];
        var x2 = src[srcoff + 6];
        var y2 = src[srcoff + 7];
        if (left != null) {
            left[leftoff + 0] = x1;
            left[leftoff + 1] = y1;
        }
        if (right != null) {
            right[rightoff + 6] = x2;
            right[rightoff + 7] = y2;
        }
        x1 = (x1 + ctrlx1) / 2.0;
        y1 = (y1 + ctrly1) / 2.0;
        x2 = (x2 + ctrlx2) / 2.0;
        y2 = (y2 + ctrly2) / 2.0;
        var centerx = (ctrlx1 + ctrlx2) / 2.0;
        var centery = (ctrly1 + ctrly2) / 2.0;
        ctrlx1 = (x1 + centerx) / 2.0;
        ctrly1 = (y1 + centery) / 2.0;
        ctrlx2 = (x2 + centerx) / 2.0;
        ctrly2 = (y2 + centery) / 2.0;
        centerx = (ctrlx1 + ctrlx2) / 2.0;
        centery = (ctrly1 + ctrly2) / 2.0;
        if (left != null) {
            left[leftoff + 2] = x1;
            left[leftoff + 3] = y1;
            left[leftoff + 4] = ctrlx1;
            left[leftoff + 5] = ctrly1;
            left[leftoff + 6] = centerx;
            left[leftoff + 7] = centery;
        }
        if (right != null) {
            right[rightoff + 0] = centerx;
            right[rightoff + 1] = centery;
            right[rightoff + 2] = ctrlx2;
            right[rightoff + 3] = ctrly2;
            right[rightoff + 4] = x2;
            right[rightoff + 5] = y2;
        }
    };
    /**
     * Subdivides the cubic curve specified by the coordinates stored in the
     * <code>src</code> array at indices <code>srcoff</code> through (
     * <code>srcoff</code>&nbsp;+&nbsp;7) and stores the resulting two
     * subdivided curves into the two result arrays at the corresponding
     * indices. Either or both of the <code>left</code> and <code>right</code>
     * arrays may be <code>null</code> or a reference to the same array as the
     * <code>src</code> array. Note that the last point in the first subdivided
     * curve is the same as the first point in the second subdivided curve.
     * Thus, it is possible to pass the same array for <code>left</code> and
     * <code>right</code> and to use offsets, such as <code>rightoff</code>
     * equals (<code>leftoff</code> + 6), in order to avoid allocating extra
     * storage for this common point.
     *
     * @param {Array} src
     * the array holding the coordinates for the source curve
     * @param {number} srcoff
     * the offset into the array of the beginning of the the 6 source
     * coordinates
     * @param {Array} left
     * the array for storing the coordinates for the first half of
     * the subdivided curve
     * @param {number} leftoff
     * the offset into the array of the beginning of the the 6 left
     * coordinates
     * @param {Array} right
     * the array for storing the coordinates for the second half of
     * the subdivided curve
     * @param {number} rightoff
     * the offset into the array of the beginning of the the 6 right
     * coordinates
     * @since 1.2
     */
    CubicCurve2D.subdivide = function (src, srcoff, left, leftoff, right, rightoff) {
        if (((src != null && src instanceof Array && (src.length == 0 || src[0] == null || (typeof src[0] === 'number'))) || src === null) && ((typeof srcoff === 'number') || srcoff === null) && ((left != null && left instanceof Array && (left.length == 0 || left[0] == null || (typeof left[0] === 'number'))) || left === null) && ((typeof leftoff === 'number') || leftoff === null) && ((right != null && right instanceof Array && (right.length == 0 || right[0] == null || (typeof right[0] === 'number'))) || right === null) && ((typeof rightoff === 'number') || rightoff === null)) {
            return CubicCurve2D.subdivide$double_A$int$double_A$int$double_A$int(src, srcoff, left, leftoff, right, rightoff);
        }
        else if (((src != null && src instanceof CubicCurve2D) || src === null) && ((srcoff != null && srcoff instanceof CubicCurve2D) || srcoff === null) && ((left != null && left instanceof CubicCurve2D) || left === null) && leftoff === undefined && right === undefined && rightoff === undefined) {
            return CubicCurve2D.subdivide$java_awt_geom_CubicCurve2D$java_awt_geom_CubicCurve2D$java_awt_geom_CubicCurve2D(src, srcoff, left);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Solves the cubic whose coefficients are in the <code>eqn</code> array and
     * places the non-complex roots back into the same array, returning the
     * number of roots. The solved cubic is represented by the equation:
     *
     * <pre>
     * eqn = {c, b, a, d}
     * dx^3 + ax^2 + bx + c = 0
     * </pre>
     *
     * A return value of -1 is used to distinguish a constant equation that
     * might be always 0 or never 0 from an equation that has no zeroes.
     *
     * @param {Array} eqn
     * an array containing coefficients for a cubic
     * @return {number} the number of roots, or -1 if the equation is a constant.
     * @since 1.2
     */
    CubicCurve2D.solveCubic$double_A = function (eqn) {
        return CubicCurve2D.solveCubic$double_A$double_A(eqn, eqn);
    };
    /**
     * Solve the cubic whose coefficients are in the <code>eqn</code> array and
     * place the non-complex roots into the <code>res</code> array, returning
     * the number of roots. The cubic solved is represented by the equation: eqn
     * = {c, b, a, d} dx^3 + ax^2 + bx + c = 0 A return value of -1 is used to
     * distinguish a constant equation, which may be always 0 or never 0, from
     * an equation which has no zeroes.
     *
     * @param {Array} eqn
     * the specified array of coefficients to use to solve the cubic
     * equation
     * @param {Array} res
     * the array that contains the non-complex roots resulting from
     * the solution of the cubic equation
     * @return {number} the number of roots, or -1 if the equation is a constant
     * @since 1.3
     */
    CubicCurve2D.solveCubic$double_A$double_A = function (eqn, res) {
        var d = eqn[3];
        if (d === 0) {
            return QuadCurve2D.solveQuadratic$double_A$double_A(eqn, res);
        }
        var A = eqn[2] / d;
        var B = eqn[1] / d;
        var C = eqn[0] / d;
        var sq_A = A * A;
        var p = 1.0 / 3 * (-1.0 / 3 * sq_A + B);
        var q = 1.0 / 2 * (2.0 / 27 * A * sq_A - 1.0 / 3 * A * B + C);
        var cb_p = p * p * p;
        var D = q * q + cb_p;
        var sub = 1.0 / 3 * A;
        var num;
        if (D < 0) {
            var phi = 1.0 / 3 * Math.acos(-q / Math.sqrt(-cb_p));
            var t = 2 * Math.sqrt(-p);
            if (res === eqn) {
                eqn = eqn.slice(0, 4);
            }
            res[0] = (t * Math.cos(phi));
            res[1] = (-t * Math.cos(phi + Math.PI / 3));
            res[2] = (-t * Math.cos(phi - Math.PI / 3));
            num = 3;
            for (var i = 0; i < num; ++i) {
                res[i] -= sub;
            }
        }
        else {
            var sqrt_D = Math.sqrt(D);
            var u = Math.pow(sqrt_D - q, 1 / 3);
            var v = -Math.pow(sqrt_D + q, 1 / 3);
            var uv = u + v;
            num = 1;
            var err = 1200000000 * javaemul.internal.MathHelper.ulp(Math.abs(uv) + Math.abs(sub));
            if (CubicCurve2D.iszero(D, err) || CubicCurve2D.within(u, v, err)) {
                if (res === eqn) {
                    eqn = eqn.slice(0, 4);
                }
                res[1] = -(uv / 2) - sub;
                num = 2;
            }
            res[0] = uv - sub;
        }
        if (num > 1) {
            num = CubicCurve2D.fixRoots(eqn, res, num);
        }
        if (num > 2 && (res[2] === res[1] || res[2] === res[0])) {
            num--;
        }
        if (num > 1 && res[1] === res[0]) {
            res[1] = res[--num];
        }
        return num;
    };
    /**
     * Solve the cubic whose coefficients are in the <code>eqn</code> array and
     * place the non-complex roots into the <code>res</code> array, returning
     * the number of roots. The cubic solved is represented by the equation: eqn
     * = {c, b, a, d} dx^3 + ax^2 + bx + c = 0 A return value of -1 is used to
     * distinguish a constant equation, which may be always 0 or never 0, from
     * an equation which has no zeroes.
     *
     * @param {Array} eqn
     * the specified array of coefficients to use to solve the cubic
     * equation
     * @param {Array} res
     * the array that contains the non-complex roots resulting from
     * the solution of the cubic equation
     * @return {number} the number of roots, or -1 if the equation is a constant
     * @since 1.3
     */
    CubicCurve2D.solveCubic = function (eqn, res) {
        if (((eqn != null && eqn instanceof Array && (eqn.length == 0 || eqn[0] == null || (typeof eqn[0] === 'number'))) || eqn === null) && ((res != null && res instanceof Array && (res.length == 0 || res[0] == null || (typeof res[0] === 'number'))) || res === null)) {
            return CubicCurve2D.solveCubic$double_A$double_A(eqn, res);
        }
        else if (((eqn != null && eqn instanceof Array && (eqn.length == 0 || eqn[0] == null || (typeof eqn[0] === 'number'))) || eqn === null) && res === undefined) {
            return CubicCurve2D.solveCubic$double_A(eqn);
        }
        else
            throw new Error('invalid overload');
    };
    CubicCurve2D.fixRoots = function (eqn, res, num) {
        var intervals = [eqn[1], 2 * eqn[2], 3 * eqn[3]];
        var critCount = QuadCurve2D.solveQuadratic$double_A$double_A(intervals, intervals);
        if (critCount === 2 && intervals[0] === intervals[1]) {
            critCount--;
        }
        if (critCount === 2 && intervals[0] > intervals[1]) {
            var tmp = intervals[0];
            intervals[0] = intervals[1];
            intervals[1] = tmp;
        }
        if (num === 3) {
            var xe = CubicCurve2D.getRootUpperBound(eqn);
            var x0 = -xe;
            /* sort */ (function (arr, start, end, f) { return (function (arr1, arr2) { return arr1.splice.apply(arr1, [start, arr2.length].concat(arr2)); })(res, res.slice(start, end).sort(f)); })(res, 0, num);
            if (critCount === 2) {
                res[0] = CubicCurve2D.refineRootWithHint(eqn, x0, intervals[0], res[0]);
                res[1] = CubicCurve2D.refineRootWithHint(eqn, intervals[0], intervals[1], res[1]);
                res[2] = CubicCurve2D.refineRootWithHint(eqn, intervals[1], xe, res[2]);
                return 3;
            }
            else if (critCount === 1) {
                var fxe = eqn[3];
                var fx0 = -fxe;
                var x1 = intervals[0];
                var fx1 = CubicCurve2D.solveEqn(eqn, 3, x1);
                if (CubicCurve2D.oppositeSigns(fx0, fx1)) {
                    res[0] = CubicCurve2D.bisectRootWithHint(eqn, x0, x1, res[0]);
                }
                else if (CubicCurve2D.oppositeSigns(fx1, fxe)) {
                    res[0] = CubicCurve2D.bisectRootWithHint(eqn, x1, xe, res[2]);
                }
                else {
                    res[0] = x1;
                }
            }
            else if (critCount === 0) {
                res[0] = CubicCurve2D.bisectRootWithHint(eqn, x0, xe, res[1]);
            }
        }
        else if (num === 2 && critCount === 2) {
            var goodRoot = res[0];
            var badRoot = res[1];
            var x1 = intervals[0];
            var x2 = intervals[1];
            var x = Math.abs(x1 - goodRoot) > Math.abs(x2 - goodRoot) ? x1 : x2;
            var fx = CubicCurve2D.solveEqn(eqn, 3, x);
            if (CubicCurve2D.iszero(fx, 10000000 * javaemul.internal.MathHelper.ulp(x))) {
                var badRootVal = CubicCurve2D.solveEqn(eqn, 3, badRoot);
                res[1] = Math.abs(badRootVal) < Math.abs(fx) ? badRoot : x;
                return 2;
            }
        }
        return 1;
    };
    CubicCurve2D.refineRootWithHint = function (eqn, min, max, t) {
        if (!CubicCurve2D.inInterval(t, min, max)) {
            return t;
        }
        var deriv = [eqn[1], 2 * eqn[2], 3 * eqn[3]];
        var origt = t;
        for (var i = 0; i < 3; i++) {
            var slope = CubicCurve2D.solveEqn(deriv, 2, t);
            var y = CubicCurve2D.solveEqn(eqn, 3, t);
            var delta = -(y / slope);
            var newt = t + delta;
            if (slope === 0 || y === 0 || t === newt) {
                break;
            }
            t = newt;
        }
        if (CubicCurve2D.within(t, origt, 1000 * javaemul.internal.MathHelper.ulp(origt)) && CubicCurve2D.inInterval(t, min, max)) {
            return t;
        }
        return origt;
    };
    CubicCurve2D.bisectRootWithHint = function (eqn, x0, xe, hint) {
        var delta1 = Math.min(Math.abs(hint - x0) / 64, 0.0625);
        var delta2 = Math.min(Math.abs(hint - xe) / 64, 0.0625);
        var x02 = hint - delta1;
        var xe2 = hint + delta2;
        var fx02 = CubicCurve2D.solveEqn(eqn, 3, x02);
        var fxe2 = CubicCurve2D.solveEqn(eqn, 3, xe2);
        while ((CubicCurve2D.oppositeSigns(fx02, fxe2))) {
            if (x02 >= xe2) {
                return x02;
            }
            x0 = x02;
            xe = xe2;
            delta1 /= 64;
            delta2 /= 64;
            x02 = hint - delta1;
            xe2 = hint + delta2;
            fx02 = CubicCurve2D.solveEqn(eqn, 3, x02);
            fxe2 = CubicCurve2D.solveEqn(eqn, 3, xe2);
        }
        ;
        if (fx02 === 0) {
            return x02;
        }
        if (fxe2 === 0) {
            return xe2;
        }
        return CubicCurve2D.bisectRoot(eqn, x0, xe);
    };
    CubicCurve2D.bisectRoot = function (eqn, x0, xe) {
        var fx0 = CubicCurve2D.solveEqn(eqn, 3, x0);
        var m = x0 + (xe - x0) / 2;
        while ((m !== x0 && m !== xe)) {
            var fm = CubicCurve2D.solveEqn(eqn, 3, m);
            if (fm === 0) {
                return m;
            }
            if (CubicCurve2D.oppositeSigns(fx0, fm)) {
                xe = m;
            }
            else {
                fx0 = fm;
                x0 = m;
            }
            m = x0 + (xe - x0) / 2;
        }
        ;
        return m;
    };
    CubicCurve2D.inInterval = function (t, min, max) {
        return min <= t && t <= max;
    };
    CubicCurve2D.within = function (x, y, err) {
        var d = y - x;
        return (d <= err && d >= -err);
    };
    CubicCurve2D.iszero = function (x, err) {
        return CubicCurve2D.within(x, 0, err);
    };
    CubicCurve2D.oppositeSigns = function (x1, x2) {
        return (x1 < 0 && x2 > 0) || (x1 > 0 && x2 < 0);
    };
    CubicCurve2D.solveEqn = function (eqn, order, t) {
        var v = eqn[order];
        while ((--order >= 0)) {
            v = v * t + eqn[order];
        }
        ;
        return v;
    };
    CubicCurve2D.getRootUpperBound = function (eqn) {
        var d = eqn[3];
        var a = eqn[2];
        var b = eqn[1];
        var c = eqn[0];
        var M = 1 + Math.max(Math.max(Math.abs(a), Math.abs(b)), Math.abs(c)) / Math.abs(d);
        M += javaemul.internal.MathHelper.ulp(M) + 1;
        return M;
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @return {boolean}
     */
    CubicCurve2D.prototype.contains$double$double = function (x, y) {
        if (!(x * 0.0 + y * 0.0 === 0.0)) {
            return false;
        }
        var x1 = this.getX1();
        var y1 = this.getY1();
        var x2 = this.getX2();
        var y2 = this.getY2();
        var crossings = (sun.awt.geom.Curve.pointCrossingsForLine(x, y, x1, y1, x2, y2) + sun.awt.geom.Curve.pointCrossingsForCubic(x, y, x1, y1, this.getCtrlX1(), this.getCtrlY1(), this.getCtrlX2(), this.getCtrlY2(), x2, y2, 0));
        return ((crossings & 1) === 1);
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {Point2D} p
     * @return {boolean}
     */
    CubicCurve2D.prototype.contains$java_awt_geom_Point2D = function (p) {
        return this.contains$double$double(p.getX(), p.getY());
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @return {boolean}
     */
    CubicCurve2D.prototype.intersects$double$double$double$double = function (x, y, w, h) {
        if (w <= 0 || h <= 0) {
            return false;
        }
        var numCrossings = this.rectCrossings(x, y, w, h);
        return numCrossings !== 0;
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @return {boolean}
     */
    CubicCurve2D.prototype.intersects = function (x, y, w, h) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
            return this.intersects$double$double$double$double(x, y, w, h);
        }
        else if (((x != null && x instanceof Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
            return this.intersects$java_awt_geom_Rectangle2D(x);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {Rectangle2D} r
     * @return {boolean}
     */
    CubicCurve2D.prototype.intersects$java_awt_geom_Rectangle2D = function (r) {
        return this.intersects$double$double$double$double(r.getX(), r.getY(), r.getWidth(), r.getHeight());
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @return {boolean}
     */
    CubicCurve2D.prototype.contains$double$double$double$double = function (x, y, w, h) {
        if (w <= 0 || h <= 0) {
            return false;
        }
        var numCrossings = this.rectCrossings(x, y, w, h);
        return !(numCrossings === 0 || numCrossings === sun.awt.geom.Curve.RECT_INTERSECTS);
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @return {boolean}
     */
    CubicCurve2D.prototype.contains = function (x, y, w, h) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
            return this.contains$double$double$double$double(x, y, w, h);
        }
        else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined) {
            return this.contains$double$double(x, y);
        }
        else if (((x != null && x instanceof Point2D) || x === null) && y === undefined && w === undefined && h === undefined) {
            return this.contains$java_awt_geom_Point2D(x);
        }
        else if (((x != null && x instanceof Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
            return this.contains$java_awt_geom_Rectangle2D(x);
        }
        else
            throw new Error('invalid overload');
    };
    CubicCurve2D.prototype.rectCrossings = function (x, y, w, h) {
        var crossings = 0;
        if (!(this.getX1() === this.getX2() && this.getY1() === this.getY2())) {
            crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, x, y, x + w, y + h, this.getX1(), this.getY1(), this.getX2(), this.getY2());
            if (crossings === sun.awt.geom.Curve.RECT_INTERSECTS) {
                return crossings;
            }
        }
        return sun.awt.geom.Curve.rectCrossingsForCubic(crossings, x, y, x + w, y + h, this.getX2(), this.getY2(), this.getCtrlX2(), this.getCtrlY2(), this.getCtrlX1(), this.getCtrlY1(), this.getX1(), this.getY1(), 0);
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {Rectangle2D} r
     * @return {boolean}
     */
    CubicCurve2D.prototype.contains$java_awt_geom_Rectangle2D = function (r) {
        return this.contains$double$double$double$double(r.getX(), r.getY(), r.getWidth(), r.getHeight());
    };
    /**
     * Returns an iteration object that defines the boundary of the shape. The
     * iterator for this class is not multi-threaded safe, which means that this
     * <code>CubicCurve2D</code> class does not guarantee that modifications to
     * the geometry of this <code>CubicCurve2D</code> object do not affect any
     * iterations of that geometry that are already in process.
     *
     * @param {AffineTransform} at
     * an optional <code>AffineTransform</code> to be applied to the
     * coordinates as they are returned in the iteration, or
     * <code>null</code> if untransformed coordinates are desired
     * @return {PathIterator} the <code>PathIterator</code> object that returns the geometry of
     * the outline of this <code>CubicCurve2D</code>, one segment at a
     * time.
     * @since 1.2
     */
    CubicCurve2D.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
        return new CubicIterator(this, at);
    };
    /**
     * Return an iteration object that defines the boundary of the flattened
     * shape. The iterator for this class is not multi-threaded safe, which
     * means that this <code>CubicCurve2D</code> class does not guarantee that
     * modifications to the geometry of this <code>CubicCurve2D</code> object do
     * not affect any iterations of that geometry that are already in process.
     *
     * @param {AffineTransform} at
     * an optional <code>AffineTransform</code> to be applied to the
     * coordinates as they are returned in the iteration, or
     * <code>null</code> if untransformed coordinates are desired
     * @param {number} flatness
     * the maximum amount that the control points for a given curve
     * can vary from colinear before a subdivided curve is replaced
     * by a straight line connecting the end points
     * @return {PathIterator} the <code>PathIterator</code> object that returns the geometry of
     * the outline of this <code>CubicCurve2D</code>, one segment at a
     * time.
     * @since 1.2
     */
    CubicCurve2D.prototype.getPathIterator$java_awt_geom_AffineTransform$double = function (at, flatness) {
        return new FlatteningPathIterator(this.getPathIterator$java_awt_geom_AffineTransform(at), flatness);
    };
    /**
     * Return an iteration object that defines the boundary of the flattened
     * shape. The iterator for this class is not multi-threaded safe, which
     * means that this <code>CubicCurve2D</code> class does not guarantee that
     * modifications to the geometry of this <code>CubicCurve2D</code> object do
     * not affect any iterations of that geometry that are already in process.
     *
     * @param {AffineTransform} at
     * an optional <code>AffineTransform</code> to be applied to the
     * coordinates as they are returned in the iteration, or
     * <code>null</code> if untransformed coordinates are desired
     * @param {number} flatness
     * the maximum amount that the control points for a given curve
     * can vary from colinear before a subdivided curve is replaced
     * by a straight line connecting the end points
     * @return {PathIterator} the <code>PathIterator</code> object that returns the geometry of
     * the outline of this <code>CubicCurve2D</code>, one segment at a
     * time.
     * @since 1.2
     */
    CubicCurve2D.prototype.getPathIterator = function (at, flatness) {
        if (((at != null && at instanceof AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
            return this.getPathIterator$java_awt_geom_AffineTransform$double(at, flatness);
        }
        else if (((at != null && at instanceof AffineTransform) || at === null) && flatness === undefined) {
            return this.getPathIterator$java_awt_geom_AffineTransform(at);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Creates a new object of the same class as this object.
     *
     * @return {*} a clone of this instance.
     * @exception OutOfMemoryError
     * if there is not enough memory.
     * @see java.lang.Cloneable
     * @since 1.2
     */
    CubicCurve2D.prototype.clone = function () {
        try {
            return (function (o) { var clone = Object.create(o); for (var p in o) {
                if (o.hasOwnProperty(p))
                    clone[p] = o[p];
            } return clone; })(this);
        }
        catch (e) {
            throw Object.defineProperty(new Error(e.message), '__class', { configurable: true, value: 'java.lang.InternalError' });
        }
        ;
    };
    return CubicCurve2D;
}());
CubicCurve2D["__class"] = "CubicCurve2D";
CubicCurve2D["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable"];
(function (CubicCurve2D) {
    /**
     * Constructs and initializes a {@code CubicCurve2D} from the specified
     * {@code float} coordinates.
     *
     * @param {number} x1
     * the X coordinate for the start point of the resulting
     * {@code CubicCurve2D}
     * @param {number} y1
     * the Y coordinate for the start point of the resulting
     * {@code CubicCurve2D}
     * @param {number} ctrlx1
     * the X coordinate for the first control point of the
     * resulting {@code CubicCurve2D}
     * @param {number} ctrly1
     * the Y coordinate for the first control point of the
     * resulting {@code CubicCurve2D}
     * @param {number} ctrlx2
     * the X coordinate for the second control point of the
     * resulting {@code CubicCurve2D}
     * @param {number} ctrly2
     * the Y coordinate for the second control point of the
     * resulting {@code CubicCurve2D}
     * @param {number} x2
     * the X coordinate for the end point of the resulting
     * {@code CubicCurve2D}
     * @param {number} y2
     * the Y coordinate for the end point of the resulting
     * {@code CubicCurve2D}
     * @since 1.2
     * @class
     */
    var Float = (function (_super) {
        __extends(Float, _super);
        function Float(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
            var _this = this;
            if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this) || this;
                _this.x1 = 0;
                _this.y1 = 0;
                _this.ctrlx1 = 0;
                _this.ctrly1 = 0;
                _this.ctrlx2 = 0;
                _this.ctrly2 = 0;
                _this.x2 = 0;
                _this.y2 = 0;
                _this.x1 = 0;
                _this.y1 = 0;
                _this.ctrlx1 = 0;
                _this.ctrly1 = 0;
                _this.ctrlx2 = 0;
                _this.ctrly2 = 0;
                _this.x2 = 0;
                _this.y2 = 0;
                (function () {
                    _this.setCurve$double$double$double$double$double$double$double$double(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2);
                })();
            }
            else if (x1 === undefined && y1 === undefined && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this) || this;
                _this.x1 = 0;
                _this.y1 = 0;
                _this.ctrlx1 = 0;
                _this.ctrly1 = 0;
                _this.ctrlx2 = 0;
                _this.ctrly2 = 0;
                _this.x2 = 0;
                _this.y2 = 0;
                _this.x1 = 0;
                _this.y1 = 0;
                _this.ctrlx1 = 0;
                _this.ctrly1 = 0;
                _this.ctrlx2 = 0;
                _this.ctrly2 = 0;
                _this.x2 = 0;
                _this.y2 = 0;
            }
            else
                throw new Error('invalid overload');
            return _this;
        }
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getX1 = function () {
            return this.x1;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getY1 = function () {
            return this.y1;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {Point2D}
         */
        Float.prototype.getP1 = function () {
            return new Point2D.Float(this.x1, this.y1);
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getCtrlX1 = function () {
            return this.ctrlx1;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getCtrlY1 = function () {
            return this.ctrly1;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {Point2D}
         */
        Float.prototype.getCtrlP1 = function () {
            return new Point2D.Float(this.ctrlx1, this.ctrly1);
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getCtrlX2 = function () {
            return this.ctrlx2;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getCtrlY2 = function () {
            return this.ctrly2;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {Point2D}
         */
        Float.prototype.getCtrlP2 = function () {
            return new Point2D.Float(this.ctrlx2, this.ctrly2);
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getX2 = function () {
            return this.x2;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getY2 = function () {
            return this.y2;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {Point2D}
         */
        Float.prototype.getP2 = function () {
            return new Point2D.Float(this.x2, this.y2);
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @param {number} x1
         * @param {number} y1
         * @param {number} ctrlx1
         * @param {number} ctrly1
         * @param {number} ctrlx2
         * @param {number} ctrly2
         * @param {number} x2
         * @param {number} y2
         */
        Float.prototype.setCurve$double$double$double$double$double$double$double$double = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
            this.x1 = x1;
            this.y1 = y1;
            this.ctrlx1 = ctrlx1;
            this.ctrly1 = ctrly1;
            this.ctrlx2 = ctrlx2;
            this.ctrly2 = ctrly2;
            this.x2 = x2;
            this.y2 = y2;
        };
        /**
         * Sets the location of the end points and control points of this curve
         * to the specified {@code float} coordinates.
         *
         * @param {number} x1
         * the X coordinate used to set the start point of this
         * {@code CubicCurve2D}
         * @param {number} y1
         * the Y coordinate used to set the start point of this
         * {@code CubicCurve2D}
         * @param {number} ctrlx1
         * the X coordinate used to set the first control point of
         * this {@code CubicCurve2D}
         * @param {number} ctrly1
         * the Y coordinate used to set the first control point of
         * this {@code CubicCurve2D}
         * @param {number} ctrlx2
         * the X coordinate used to set the second control point of
         * this {@code CubicCurve2D}
         * @param {number} ctrly2
         * the Y coordinate used to set the second control point of
         * this {@code CubicCurve2D}
         * @param {number} x2
         * the X coordinate used to set the end point of this
         * {@code CubicCurve2D}
         * @param {number} y2
         * the Y coordinate used to set the end point of this
         * {@code CubicCurve2D}
         * @since 1.2
         */
        Float.prototype.setCurve$float$float$float$float$float$float$float$float = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
            this.x1 = x1;
            this.y1 = y1;
            this.ctrlx1 = ctrlx1;
            this.ctrly1 = ctrly1;
            this.ctrlx2 = ctrlx2;
            this.ctrly2 = ctrly2;
            this.x2 = x2;
            this.y2 = y2;
        };
        /**
         * Sets the location of the end points and control points of this curve
         * to the specified {@code float} coordinates.
         *
         * @param {number} x1
         * the X coordinate used to set the start point of this
         * {@code CubicCurve2D}
         * @param {number} y1
         * the Y coordinate used to set the start point of this
         * {@code CubicCurve2D}
         * @param {number} ctrlx1
         * the X coordinate used to set the first control point of
         * this {@code CubicCurve2D}
         * @param {number} ctrly1
         * the Y coordinate used to set the first control point of
         * this {@code CubicCurve2D}
         * @param {number} ctrlx2
         * the X coordinate used to set the second control point of
         * this {@code CubicCurve2D}
         * @param {number} ctrly2
         * the Y coordinate used to set the second control point of
         * this {@code CubicCurve2D}
         * @param {number} x2
         * the X coordinate used to set the end point of this
         * {@code CubicCurve2D}
         * @param {number} y2
         * the Y coordinate used to set the end point of this
         * {@code CubicCurve2D}
         * @since 1.2
         */
        Float.prototype.setCurve = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
            if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                return this.setCurve$float$float$float$float$float$float$float$float(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2);
            }
            else if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                return this.setCurve$double$double$double$double$double$double$double$double(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2);
            }
            else if (((x1 != null && x1 instanceof Point2D) || x1 === null) && ((y1 != null && y1 instanceof Point2D) || y1 === null) && ((ctrlx1 != null && ctrlx1 instanceof Point2D) || ctrlx1 === null) && ((ctrly1 != null && ctrly1 instanceof Point2D) || ctrly1 === null) && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                return this.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1, ctrlx1, ctrly1);
            }
            else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (typeof x1[0] === 'number'))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                return this.setCurve$double_A$int(x1, y1);
            }
            else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (x1[0] != null && x1[0] instanceof Point2D))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                return this.setCurve$java_awt_geom_Point2D_A$int(x1, y1);
            }
            else if (((x1 != null && x1 instanceof CubicCurve2D) || x1 === null) && y1 === undefined && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                return this.setCurve$java_awt_geom_CubicCurve2D(x1);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {Rectangle2D}
         */
        Float.prototype.getBounds2D = function () {
            var left = Math.min(Math.min(this.x1, this.x2), Math.min(this.ctrlx1, this.ctrlx2));
            var top = Math.min(Math.min(this.y1, this.y2), Math.min(this.ctrly1, this.ctrly2));
            var right = Math.max(Math.max(this.x1, this.x2), Math.max(this.ctrlx1, this.ctrlx2));
            var bottom = Math.max(Math.max(this.y1, this.y2), Math.max(this.ctrly1, this.ctrly2));
            return new Rectangle2D.Float(left, top, right - left, bottom - top);
        };
        return Float;
    }(CubicCurve2D));
    Float.serialVersionUID = -1272015596714244385;
    CubicCurve2D.Float = Float;
    Float["__class"] = "CubicCurve2D.Float";
    Float["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
    /**
     * Constructs and initializes a {@code CubicCurve2D} from the specified
     * {@code double} coordinates.
     *
     * @param {number} x1
     * the X coordinate for the start point of the resulting
     * {@code CubicCurve2D}
     * @param {number} y1
     * the Y coordinate for the start point of the resulting
     * {@code CubicCurve2D}
     * @param {number} ctrlx1
     * the X coordinate for the first control point of the
     * resulting {@code CubicCurve2D}
     * @param {number} ctrly1
     * the Y coordinate for the first control point of the
     * resulting {@code CubicCurve2D}
     * @param {number} ctrlx2
     * the X coordinate for the second control point of the
     * resulting {@code CubicCurve2D}
     * @param {number} ctrly2
     * the Y coordinate for the second control point of the
     * resulting {@code CubicCurve2D}
     * @param {number} x2
     * the X coordinate for the end point of the resulting
     * {@code CubicCurve2D}
     * @param {number} y2
     * the Y coordinate for the end point of the resulting
     * {@code CubicCurve2D}
     * @since 1.2
     * @class
     */
    var Double = (function (_super) {
        __extends(Double, _super);
        function Double(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
            var _this = this;
            if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this) || this;
                _this.x1 = 0;
                _this.y1 = 0;
                _this.ctrlx1 = 0;
                _this.ctrly1 = 0;
                _this.ctrlx2 = 0;
                _this.ctrly2 = 0;
                _this.x2 = 0;
                _this.y2 = 0;
                _this.x1 = 0;
                _this.y1 = 0;
                _this.ctrlx1 = 0;
                _this.ctrly1 = 0;
                _this.ctrlx2 = 0;
                _this.ctrly2 = 0;
                _this.x2 = 0;
                _this.y2 = 0;
                (function () {
                    _this.setCurve$double$double$double$double$double$double$double$double(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2);
                })();
            }
            else if (x1 === undefined && y1 === undefined && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this) || this;
                _this.x1 = 0;
                _this.y1 = 0;
                _this.ctrlx1 = 0;
                _this.ctrly1 = 0;
                _this.ctrlx2 = 0;
                _this.ctrly2 = 0;
                _this.x2 = 0;
                _this.y2 = 0;
                _this.x1 = 0;
                _this.y1 = 0;
                _this.ctrlx1 = 0;
                _this.ctrly1 = 0;
                _this.ctrlx2 = 0;
                _this.ctrly2 = 0;
                _this.x2 = 0;
                _this.y2 = 0;
            }
            else
                throw new Error('invalid overload');
            return _this;
        }
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getX1 = function () {
            return this.x1;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getY1 = function () {
            return this.y1;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {Point2D}
         */
        Double.prototype.getP1 = function () {
            return new Point2D.Double(this.x1, this.y1);
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getCtrlX1 = function () {
            return this.ctrlx1;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getCtrlY1 = function () {
            return this.ctrly1;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {Point2D}
         */
        Double.prototype.getCtrlP1 = function () {
            return new Point2D.Double(this.ctrlx1, this.ctrly1);
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getCtrlX2 = function () {
            return this.ctrlx2;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getCtrlY2 = function () {
            return this.ctrly2;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {Point2D}
         */
        Double.prototype.getCtrlP2 = function () {
            return new Point2D.Double(this.ctrlx2, this.ctrly2);
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getX2 = function () {
            return this.x2;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getY2 = function () {
            return this.y2;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {Point2D}
         */
        Double.prototype.getP2 = function () {
            return new Point2D.Double(this.x2, this.y2);
        };
        /**
         * Sets the location of the end points and control points of this curve
         * to the specified {@code float} coordinates.
         *
         * @param {number} x1
         * the X coordinate used to set the start point of this
         * {@code CubicCurve2D}
         * @param {number} y1
         * the Y coordinate used to set the start point of this
         * {@code CubicCurve2D}
         * @param {number} ctrlx1
         * the X coordinate used to set the first control point of
         * this {@code CubicCurve2D}
         * @param {number} ctrly1
         * the Y coordinate used to set the first control point of
         * this {@code CubicCurve2D}
         * @param {number} ctrlx2
         * the X coordinate used to set the second control point of
         * this {@code CubicCurve2D}
         * @param {number} ctrly2
         * the Y coordinate used to set the second control point of
         * this {@code CubicCurve2D}
         * @param {number} x2
         * the X coordinate used to set the end point of this
         * {@code CubicCurve2D}
         * @param {number} y2
         * the Y coordinate used to set the end point of this
         * {@code CubicCurve2D}
         * @since 1.2
         */
        Double.prototype.setCurve = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
            if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                return this.setCurve$double$double$double$double$double$double$double$double(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2);
            }
            else if (((x1 != null && x1 instanceof Point2D) || x1 === null) && ((y1 != null && y1 instanceof Point2D) || y1 === null) && ((ctrlx1 != null && ctrlx1 instanceof Point2D) || ctrlx1 === null) && ((ctrly1 != null && ctrly1 instanceof Point2D) || ctrly1 === null) && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                return this.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1, ctrlx1, ctrly1);
            }
            else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (typeof x1[0] === 'number'))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                return this.setCurve$double_A$int(x1, y1);
            }
            else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (x1[0] != null && x1[0] instanceof Point2D))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                return this.setCurve$java_awt_geom_Point2D_A$int(x1, y1);
            }
            else if (((x1 != null && x1 instanceof CubicCurve2D) || x1 === null) && y1 === undefined && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                return this.setCurve$java_awt_geom_CubicCurve2D(x1);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @param {number} x1
         * @param {number} y1
         * @param {number} ctrlx1
         * @param {number} ctrly1
         * @param {number} ctrlx2
         * @param {number} ctrly2
         * @param {number} x2
         * @param {number} y2
         */
        Double.prototype.setCurve$double$double$double$double$double$double$double$double = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
            this.x1 = x1;
            this.y1 = y1;
            this.ctrlx1 = ctrlx1;
            this.ctrly1 = ctrly1;
            this.ctrlx2 = ctrlx2;
            this.ctrly2 = ctrly2;
            this.x2 = x2;
            this.y2 = y2;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {Rectangle2D}
         */
        Double.prototype.getBounds2D = function () {
            var left = Math.min(Math.min(this.x1, this.x2), Math.min(this.ctrlx1, this.ctrlx2));
            var top = Math.min(Math.min(this.y1, this.y2), Math.min(this.ctrly1, this.ctrly2));
            var right = Math.max(Math.max(this.x1, this.x2), Math.max(this.ctrlx1, this.ctrlx2));
            var bottom = Math.max(Math.max(this.y1, this.y2), Math.max(this.ctrly1, this.ctrly2));
            return new Rectangle2D.Double(left, top, right - left, bottom - top);
        };
        return Double;
    }(CubicCurve2D));
    Double.serialVersionUID = -4202960122839707295;
    CubicCurve2D.Double = Double;
    Double["__class"] = "CubicCurve2D.Double";
    Double["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
})(CubicCurve2D || (CubicCurve2D = {}));
/**
 * A utility class to iterate over the path segments of a cubic curve segment
 * through the PathIterator interface.
 *
 * @author Jim Graham
 */
var CubicIterator = (function () {
    function CubicIterator(q, at) {
        this.cubic = null;
        this.affine = null;
        this.index = 0;
        this.cubic = q;
        this.affine = at;
    }
    /**
     * Return the winding rule for determining the insideness of the path.
     *
     * @see #WIND_EVEN_ODD
     * @see #WIND_NON_ZERO
     * @return {number}
     */
    CubicIterator.prototype.getWindingRule = function () {
        return PathIterator.WIND_NON_ZERO;
    };
    /**
     * Tests if there are more points to read.
     *
     * @return {boolean} true if there are more points to read
     */
    CubicIterator.prototype.isDone = function () {
        return (this.index > 1);
    };
    /**
     * Moves the iterator to the next segment of the path forwards along the
     * primary direction of traversal as long as there are more points in that
     * direction.
     */
    CubicIterator.prototype.next = function () {
        this.index++;
    };
    /**
     * Returns the coordinates and type of the current path segment in the
     * iteration. The return value is the path segment type: SEG_MOVETO,
     * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
     * length 6 must be passed in and may be used to store the coordinates of
     * the point(s). Each point is stored as a pair of float x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
     * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
     * not return any points.
     *
     * @see #SEG_MOVETO
     * @see #SEG_LINETO
     * @see #SEG_QUADTO
     * @see #SEG_CUBICTO
     * @see #SEG_CLOSE
     * @param {Array} coords
     * @return {number}
     */
    CubicIterator.prototype.currentSegment$float_A = function (coords) {
        if (this.isDone()) {
            throw Object.defineProperty(new Error("cubic iterator iterator out of bounds"), '__class', { configurable: true, value: 'java.util.NoSuchElementException' });
        }
        var type;
        if (this.index === 0) {
            coords[0] = this.cubic.getX1();
            coords[1] = this.cubic.getY1();
            type = PathIterator.SEG_MOVETO;
        }
        else {
            coords[0] = this.cubic.getCtrlX1();
            coords[1] = this.cubic.getCtrlY1();
            coords[2] = this.cubic.getCtrlX2();
            coords[3] = this.cubic.getCtrlY2();
            coords[4] = this.cubic.getX2();
            coords[5] = this.cubic.getY2();
            type = PathIterator.SEG_CUBICTO;
        }
        if (this.affine != null) {
            this.affine.transform$float_A$int$float_A$int$int(coords, 0, coords, 0, this.index === 0 ? 1 : 3);
        }
        return type;
    };
    /**
     * Returns the coordinates and type of the current path segment in the
     * iteration. The return value is the path segment type: SEG_MOVETO,
     * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
     * length 6 must be passed in and may be used to store the coordinates of
     * the point(s). Each point is stored as a pair of float x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
     * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
     * not return any points.
     *
     * @see #SEG_MOVETO
     * @see #SEG_LINETO
     * @see #SEG_QUADTO
     * @see #SEG_CUBICTO
     * @see #SEG_CLOSE
     * @param {Array} coords
     * @return {number}
     */
    CubicIterator.prototype.currentSegment = function (coords) {
        if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
            return this.currentSegment$float_A(coords);
        }
        else if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
            return this.currentSegment$double_A(coords);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Returns the coordinates and type of the current path segment in the
     * iteration. The return value is the path segment type: SEG_MOVETO,
     * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A double array of
     * length 6 must be passed in and may be used to store the coordinates of
     * the point(s). Each point is stored as a pair of double x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
     * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
     * not return any points.
     *
     * @see #SEG_MOVETO
     * @see #SEG_LINETO
     * @see #SEG_QUADTO
     * @see #SEG_CUBICTO
     * @see #SEG_CLOSE
     * @param {Array} coords
     * @return {number}
     */
    CubicIterator.prototype.currentSegment$double_A = function (coords) {
        if (this.isDone()) {
            throw Object.defineProperty(new Error("cubic iterator iterator out of bounds"), '__class', { configurable: true, value: 'java.util.NoSuchElementException' });
        }
        var type;
        if (this.index === 0) {
            coords[0] = this.cubic.getX1();
            coords[1] = this.cubic.getY1();
            type = PathIterator.SEG_MOVETO;
        }
        else {
            coords[0] = this.cubic.getCtrlX1();
            coords[1] = this.cubic.getCtrlY1();
            coords[2] = this.cubic.getCtrlX2();
            coords[3] = this.cubic.getCtrlY2();
            coords[4] = this.cubic.getX2();
            coords[5] = this.cubic.getY2();
            type = PathIterator.SEG_CUBICTO;
        }
        if (this.affine != null) {
            this.affine.transform$double_A$int$double_A$int$int(coords, 0, coords, 0, this.index === 0 ? 1 : 3);
        }
        return type;
    };
    return CubicIterator;
}());
CubicIterator["__class"] = "CubicIterator";
CubicIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
/**
 * This is an abstract class that cannot be instantiated directly.
 * Type-specific implementation subclasses are available for instantiation
 * and provide a number of formats for storing the information necessary to
 * satisfy the various accessor methods below.
 *
 * @see java.awt.Dimension
 * @since 1.2
 * @class
 */
var Dimension2D = (function () {
    function Dimension2D() {
    }
    /**
     * Sets the size of this <code>Dimension</code> object to the specified
     * width and height. This method is included for completeness, to parallel
     * the {@link java.awt.Component#getSize} method of
     * {@link java.awt.Component}.
     *
     * @param {number} width
     * the new width for the <code>Dimension</code> object
     * @param {number} height
     * the new height for the <code>Dimension</code> object
     * @since 1.2
     */
    Dimension2D.prototype.setSize$double$double = function (width, height) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
    /**
     * Sets the size of this <code>Dimension</code> object to the specified
     * width and height. This method is included for completeness, to parallel
     * the {@link java.awt.Component#getSize} method of
     * {@link java.awt.Component}.
     *
     * @param {number} width
     * the new width for the <code>Dimension</code> object
     * @param {number} height
     * the new height for the <code>Dimension</code> object
     * @since 1.2
     */
    Dimension2D.prototype.setSize = function (width, height) {
        if (((typeof width === 'number') || width === null) && ((typeof height === 'number') || height === null)) {
            return this.setSize$double$double(width, height);
        }
        else if (((width != null && width instanceof Dimension2D) || width === null) && height === undefined) {
            return this.setSize$java_awt_geom_Dimension2D(width);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Sets the size of this <code>Dimension2D</code> object to match the
     * specified size. This method is included for completeness, to parallel the
     * <code>getSize</code> method of <code>Component</code>.
     *
     * @param {Dimension2D} d
     * the new size for the <code>Dimension2D</code> object
     * @since 1.2
     */
    Dimension2D.prototype.setSize$java_awt_geom_Dimension2D = function (d) {
        this.setSize$double$double(d.getWidth(), d.getHeight());
    };
    /**
     * Creates a new object of the same class as this object.
     *
     * @return {*} a clone of this instance.
     * @exception OutOfMemoryError
     * if there is not enough memory.
     * @see java.lang.Cloneable
     * @since 1.2
     */
    Dimension2D.prototype.clone = function () {
        try {
            return (function (o) { var clone = Object.create(o); for (var p in o) {
                if (o.hasOwnProperty(p))
                    clone[p] = o[p];
            } return clone; })(this);
        }
        catch (e) {
            throw Object.defineProperty(new Error(e.message), '__class', { configurable: true, value: 'java.lang.InternalError' });
        }
        ;
    };
    return Dimension2D;
}());
Dimension2D["__class"] = "Dimension2D";
Dimension2D["__interfaces"] = ["java.lang.Cloneable"];
/**
 * A utility class to iterate over the path segments of an ellipse through the
 * PathIterator interface.
 *
 * @author Jim Graham
 */
var EllipseIterator = (function () {
    function EllipseIterator(e, at) {
        this.x = 0;
        this.y = 0;
        this.w = 0;
        this.h = 0;
        this.affine = null;
        this.index = 0;
        this.x = e.getX();
        this.y = e.getY();
        this.w = e.getWidth();
        this.h = e.getHeight();
        this.affine = at;
        if (this.w < 0 || this.h < 0) {
            this.index = 6;
        }
    }
    /**
     * Return the winding rule for determining the insideness of the path.
     *
     * @see #WIND_EVEN_ODD
     * @see #WIND_NON_ZERO
     * @return {number}
     */
    EllipseIterator.prototype.getWindingRule = function () {
        return PathIterator.WIND_NON_ZERO;
    };
    /**
     * Tests if there are more points to read.
     *
     * @return {boolean} true if there are more points to read
     */
    EllipseIterator.prototype.isDone = function () {
        return this.index > 5;
    };
    /**
     * Moves the iterator to the next segment of the path forwards along the
     * primary direction of traversal as long as there are more points in that
     * direction.
     */
    EllipseIterator.prototype.next = function () {
        this.index++;
    };
    EllipseIterator.pcv_$LI$ = function () { if (EllipseIterator.pcv == null)
        EllipseIterator.pcv = 0.5 + EllipseIterator.CtrlVal * 0.5; return EllipseIterator.pcv; };
    ;
    EllipseIterator.ncv_$LI$ = function () { if (EllipseIterator.ncv == null)
        EllipseIterator.ncv = 0.5 - EllipseIterator.CtrlVal * 0.5; return EllipseIterator.ncv; };
    ;
    EllipseIterator.ctrlpts_$LI$ = function () { if (EllipseIterator.ctrlpts == null)
        EllipseIterator.ctrlpts = [[1.0, EllipseIterator.pcv_$LI$(), EllipseIterator.pcv_$LI$(), 1.0, 0.5, 1.0], [EllipseIterator.ncv_$LI$(), 1.0, 0.0, EllipseIterator.pcv_$LI$(), 0.0, 0.5], [0.0, EllipseIterator.ncv_$LI$(), EllipseIterator.ncv_$LI$(), 0.0, 0.5, 0.0], [EllipseIterator.pcv_$LI$(), 0.0, 1.0, EllipseIterator.ncv_$LI$(), 1.0, 0.5]]; return EllipseIterator.ctrlpts; };
    ;
    /**
     * Returns the coordinates and type of the current path segment in the
     * iteration. The return value is the path segment type: SEG_MOVETO,
     * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
     * length 6 must be passed in and may be used to store the coordinates of
     * the point(s). Each point is stored as a pair of float x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
     * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
     * not return any points.
     *
     * @see #SEG_MOVETO
     * @see #SEG_LINETO
     * @see #SEG_QUADTO
     * @see #SEG_CUBICTO
     * @see #SEG_CLOSE
     * @param {Array} coords
     * @return {number}
     */
    EllipseIterator.prototype.currentSegment$float_A = function (coords) {
        if (this.isDone()) {
            throw Object.defineProperty(new Error("ellipse iterator out of bounds"), '__class', { configurable: true, value: 'java.util.NoSuchElementException' });
        }
        if (this.index === 5) {
            return PathIterator.SEG_CLOSE;
        }
        if (this.index === 0) {
            var ctrls_1 = EllipseIterator.ctrlpts_$LI$()[3];
            coords[0] = (this.x + ctrls_1[4] * this.w);
            coords[1] = (this.y + ctrls_1[5] * this.h);
            if (this.affine != null) {
                this.affine.transform$float_A$int$float_A$int$int(coords, 0, coords, 0, 1);
            }
            return PathIterator.SEG_MOVETO;
        }
        var ctrls = EllipseIterator.ctrlpts_$LI$()[this.index - 1];
        coords[0] = (this.x + ctrls[0] * this.w);
        coords[1] = (this.y + ctrls[1] * this.h);
        coords[2] = (this.x + ctrls[2] * this.w);
        coords[3] = (this.y + ctrls[3] * this.h);
        coords[4] = (this.x + ctrls[4] * this.w);
        coords[5] = (this.y + ctrls[5] * this.h);
        if (this.affine != null) {
            this.affine.transform$float_A$int$float_A$int$int(coords, 0, coords, 0, 3);
        }
        return PathIterator.SEG_CUBICTO;
    };
    /**
     * Returns the coordinates and type of the current path segment in the
     * iteration. The return value is the path segment type: SEG_MOVETO,
     * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
     * length 6 must be passed in and may be used to store the coordinates of
     * the point(s). Each point is stored as a pair of float x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
     * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
     * not return any points.
     *
     * @see #SEG_MOVETO
     * @see #SEG_LINETO
     * @see #SEG_QUADTO
     * @see #SEG_CUBICTO
     * @see #SEG_CLOSE
     * @param {Array} coords
     * @return {number}
     */
    EllipseIterator.prototype.currentSegment = function (coords) {
        if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
            return this.currentSegment$float_A(coords);
        }
        else if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
            return this.currentSegment$double_A(coords);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Returns the coordinates and type of the current path segment in the
     * iteration. The return value is the path segment type: SEG_MOVETO,
     * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A double array of
     * length 6 must be passed in and may be used to store the coordinates of
     * the point(s). Each point is stored as a pair of double x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
     * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
     * not return any points.
     *
     * @see #SEG_MOVETO
     * @see #SEG_LINETO
     * @see #SEG_QUADTO
     * @see #SEG_CUBICTO
     * @see #SEG_CLOSE
     * @param {Array} coords
     * @return {number}
     */
    EllipseIterator.prototype.currentSegment$double_A = function (coords) {
        if (this.isDone()) {
            throw Object.defineProperty(new Error("ellipse iterator out of bounds"), '__class', { configurable: true, value: 'java.util.NoSuchElementException' });
        }
        if (this.index === 5) {
            return PathIterator.SEG_CLOSE;
        }
        if (this.index === 0) {
            var ctrls_2 = EllipseIterator.ctrlpts_$LI$()[3];
            coords[0] = this.x + ctrls_2[4] * this.w;
            coords[1] = this.y + ctrls_2[5] * this.h;
            if (this.affine != null) {
                this.affine.transform$double_A$int$double_A$int$int(coords, 0, coords, 0, 1);
            }
            return PathIterator.SEG_MOVETO;
        }
        var ctrls = EllipseIterator.ctrlpts_$LI$()[this.index - 1];
        coords[0] = this.x + ctrls[0] * this.w;
        coords[1] = this.y + ctrls[1] * this.h;
        coords[2] = this.x + ctrls[2] * this.w;
        coords[3] = this.y + ctrls[3] * this.h;
        coords[4] = this.x + ctrls[4] * this.w;
        coords[5] = this.y + ctrls[5] * this.h;
        if (this.affine != null) {
            this.affine.transform$double_A$int$double_A$int$int(coords, 0, coords, 0, 3);
        }
        return PathIterator.SEG_CUBICTO;
    };
    return EllipseIterator;
}());
EllipseIterator.CtrlVal = 0.5522847498307933;
EllipseIterator["__class"] = "EllipseIterator";
EllipseIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
/**
 * Constructs a new <code>FlatteningPathIterator</code> object that flattens
 * a path as it iterates over it. The <code>limit</code> parameter allows
 * you to control the maximum number of recursive subdivisions that the
 * iterator can make before it assumes that the curve is flat enough without
 * measuring against the <code>flatness</code> parameter. The flattened
 * iteration therefore never generates more than a maximum of
 * <code>(2^limit)</code> line segments per curve.
 *
 * @param {PathIterator} src
 * the original unflattened path being iterated over
 * @param {number} flatness
 * the maximum allowable distance between the control points and
 * the flattened curve
 * @param {number} limit
 * the maximum number of recursive subdivisions allowed for any
 * curved segment
 * @exception IllegalArgumentException
 * if <code>flatness</code> or <code>limit</code> is less
 * than zero
 * @class
 */
var FlatteningPathIterator = (function () {
    function FlatteningPathIterator(src, flatness, limit) {
        var _this = this;
        this.hold = (function (s) { var a = []; while (s-- > 0)
            a.push(0); return a; })(14);
        if (((src != null && (src["__interfaces"] != null && src["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || src.constructor != null && src.constructor["__interfaces"] != null && src.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || src === null) && ((typeof flatness === 'number') || flatness === null) && ((typeof limit === 'number') || limit === null)) {
            var __args = Array.prototype.slice.call(arguments);
            this.src = null;
            this.squareflat = 0;
            this.limit = 0;
            this.curx = 0;
            this.cury = 0;
            this.movx = 0;
            this.movy = 0;
            this.holdType = 0;
            this.holdEnd = 0;
            this.holdIndex = 0;
            this.levels = null;
            this.levelIndex = 0;
            this.done = false;
            this.hold = (function (s) { var a = []; while (s-- > 0)
                a.push(0); return a; })(14);
            this.src = null;
            this.squareflat = 0;
            this.limit = 0;
            this.curx = 0;
            this.cury = 0;
            this.movx = 0;
            this.movy = 0;
            this.holdType = 0;
            this.holdEnd = 0;
            this.holdIndex = 0;
            this.levels = null;
            this.levelIndex = 0;
            this.done = false;
            (function () {
                if (flatness < 0.0) {
                    throw Object.defineProperty(new Error("flatness must be >= 0"), '__class', { configurable: true, value: 'java.lang.IllegalArgumentException' });
                }
                if (limit < 0) {
                    throw Object.defineProperty(new Error("limit must be >= 0"), '__class', { configurable: true, value: 'java.lang.IllegalArgumentException' });
                }
                _this.src = src;
                _this.squareflat = flatness * flatness;
                _this.limit = limit;
                _this.levels = (function (s) { var a = []; while (s-- > 0)
                    a.push(0); return a; })(limit + 1);
                _this.next$boolean(false);
            })();
        }
        else if (((src != null && (src["__interfaces"] != null && src["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || src.constructor != null && src.constructor["__interfaces"] != null && src.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || src === null) && ((typeof flatness === 'number') || flatness === null) && limit === undefined) {
            var __args = Array.prototype.slice.call(arguments);
            {
                var __args_1 = Array.prototype.slice.call(arguments);
                var limit_1 = 10;
                this.src = null;
                this.squareflat = 0;
                this.limit = 0;
                this.curx = 0;
                this.cury = 0;
                this.movx = 0;
                this.movy = 0;
                this.holdType = 0;
                this.holdEnd = 0;
                this.holdIndex = 0;
                this.levels = null;
                this.levelIndex = 0;
                this.done = false;
                this.hold = (function (s) { var a = []; while (s-- > 0)
                    a.push(0); return a; })(14);
                this.src = null;
                this.squareflat = 0;
                this.limit = 0;
                this.curx = 0;
                this.cury = 0;
                this.movx = 0;
                this.movy = 0;
                this.holdType = 0;
                this.holdEnd = 0;
                this.holdIndex = 0;
                this.levels = null;
                this.levelIndex = 0;
                this.done = false;
                (function () {
                    if (flatness < 0.0) {
                        throw Object.defineProperty(new Error("flatness must be >= 0"), '__class', { configurable: true, value: 'java.lang.IllegalArgumentException' });
                    }
                    if (limit_1 < 0) {
                        throw Object.defineProperty(new Error("limit must be >= 0"), '__class', { configurable: true, value: 'java.lang.IllegalArgumentException' });
                    }
                    _this.src = src;
                    _this.squareflat = flatness * flatness;
                    _this.limit = limit_1;
                    _this.levels = (function (s) { var a = []; while (s-- > 0)
                        a.push(0); return a; })(limit_1 + 1);
                    _this.next$boolean(false);
                })();
            }
        }
        else
            throw new Error('invalid overload');
    }
    /**
     * Returns the flatness of this iterator.
     *
     * @return {number} the flatness of this <code>FlatteningPathIterator</code>.
     */
    FlatteningPathIterator.prototype.getFlatness = function () {
        return Math.sqrt(this.squareflat);
    };
    /**
     * Returns the recursion limit of this iterator.
     *
     * @return {number} the recursion limit of this <code>FlatteningPathIterator</code>.
     */
    FlatteningPathIterator.prototype.getRecursionLimit = function () {
        return this.limit;
    };
    /**
     * Returns the winding rule for determining the interior of the path.
     *
     * @return {number} the winding rule of the original unflattened path being iterated
     * over.
     * @see PathIterator#WIND_EVEN_ODD
     * @see PathIterator#WIND_NON_ZERO
     */
    FlatteningPathIterator.prototype.getWindingRule = function () {
        return this.src.getWindingRule();
    };
    /**
     * Tests if the iteration is complete.
     *
     * @return {boolean} <code>true</code> if all the segments have been read;
     * <code>false</code> otherwise.
     */
    FlatteningPathIterator.prototype.isDone = function () {
        return this.done;
    };
    FlatteningPathIterator.prototype.ensureHoldCapacity = function (want) {
        if (this.holdIndex - want < 0) {
            var have = this.hold.length - this.holdIndex;
            var newsize = this.hold.length + FlatteningPathIterator.GROW_SIZE;
            var newhold = (function (s) { var a = []; while (s-- > 0)
                a.push(0); return a; })(newsize);
            Helper.arraycopy(this.hold, this.holdIndex, newhold, this.holdIndex + FlatteningPathIterator.GROW_SIZE, have);
            this.hold = newhold;
            this.holdIndex += FlatteningPathIterator.GROW_SIZE;
            this.holdEnd += FlatteningPathIterator.GROW_SIZE;
        }
    };
    /**
     * Moves the iterator to the next segment of the path forwards along the
     * primary direction of traversal as long as there are more points in that
     * direction.
     */
    FlatteningPathIterator.prototype.next$ = function () {
        this.next$boolean(true);
    };
    FlatteningPathIterator.prototype.next$boolean = function (doNext) {
        var level;
        if (this.holdIndex >= this.holdEnd) {
            if (doNext) {
                this.src.next();
            }
            if (this.src.isDone()) {
                this.done = true;
                return;
            }
            this.holdType = this.src['currentSegment$double_A'](this.hold);
            this.levelIndex = 0;
            this.levels[0] = 0;
        }
        switch ((this.holdType)) {
            case PathIterator.SEG_MOVETO:
            case PathIterator.SEG_LINETO:
                this.curx = this.hold[0];
                this.cury = this.hold[1];
                if (this.holdType === PathIterator.SEG_MOVETO) {
                    this.movx = this.curx;
                    this.movy = this.cury;
                }
                this.holdIndex = 0;
                this.holdEnd = 0;
                break;
            case PathIterator.SEG_CLOSE:
                this.curx = this.movx;
                this.cury = this.movy;
                this.holdIndex = 0;
                this.holdEnd = 0;
                break;
            case PathIterator.SEG_QUADTO:
                if (this.holdIndex >= this.holdEnd) {
                    this.holdIndex = this.hold.length - 6;
                    this.holdEnd = this.hold.length - 2;
                    this.hold[this.holdIndex + 0] = this.curx;
                    this.hold[this.holdIndex + 1] = this.cury;
                    this.hold[this.holdIndex + 2] = this.hold[0];
                    this.hold[this.holdIndex + 3] = this.hold[1];
                    this.hold[this.holdIndex + 4] = this.curx = this.hold[2];
                    this.hold[this.holdIndex + 5] = this.cury = this.hold[3];
                }
                level = this.levels[this.levelIndex];
                while ((level < this.limit)) {
                    if (QuadCurve2D.getFlatnessSq$double_A$int(this.hold, this.holdIndex) < this.squareflat) {
                        break;
                    }
                    this.ensureHoldCapacity(4);
                    QuadCurve2D.subdivide$double_A$int$double_A$int$double_A$int(this.hold, this.holdIndex, this.hold, this.holdIndex - 4, this.hold, this.holdIndex);
                    this.holdIndex -= 4;
                    level++;
                    this.levels[this.levelIndex] = level;
                    this.levelIndex++;
                    this.levels[this.levelIndex] = level;
                }
                ;
                this.holdIndex += 4;
                this.levelIndex--;
                break;
            case PathIterator.SEG_CUBICTO:
                if (this.holdIndex >= this.holdEnd) {
                    this.holdIndex = this.hold.length - 8;
                    this.holdEnd = this.hold.length - 2;
                    this.hold[this.holdIndex + 0] = this.curx;
                    this.hold[this.holdIndex + 1] = this.cury;
                    this.hold[this.holdIndex + 2] = this.hold[0];
                    this.hold[this.holdIndex + 3] = this.hold[1];
                    this.hold[this.holdIndex + 4] = this.hold[2];
                    this.hold[this.holdIndex + 5] = this.hold[3];
                    this.hold[this.holdIndex + 6] = this.curx = this.hold[4];
                    this.hold[this.holdIndex + 7] = this.cury = this.hold[5];
                }
                level = this.levels[this.levelIndex];
                while ((level < this.limit)) {
                    if (CubicCurve2D.getFlatnessSq$double_A$int(this.hold, this.holdIndex) < this.squareflat) {
                        break;
                    }
                    this.ensureHoldCapacity(6);
                    CubicCurve2D.subdivide$double_A$int$double_A$int$double_A$int(this.hold, this.holdIndex, this.hold, this.holdIndex - 6, this.hold, this.holdIndex);
                    this.holdIndex -= 6;
                    level++;
                    this.levels[this.levelIndex] = level;
                    this.levelIndex++;
                    this.levels[this.levelIndex] = level;
                }
                ;
                this.holdIndex += 6;
                this.levelIndex--;
                break;
        }
    };
    FlatteningPathIterator.prototype.next = function (doNext) {
        if (((typeof doNext === 'boolean') || doNext === null)) {
            return this.next$boolean(doNext);
        }
        else if (doNext === undefined) {
            return this.next$();
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Returns the coordinates and type of the current path segment in the
     * iteration. The return value is the path segment type: SEG_MOVETO,
     * SEG_LINETO, or SEG_CLOSE. A float array of length 6 must be passed in and
     * can be used to store the coordinates of the point(s). Each point is
     * stored as a pair of float x,y coordinates. SEG_MOVETO and SEG_LINETO
     * types return one point, and SEG_CLOSE does not return any points.
     *
     * @param {Array} coords
     * an array that holds the data returned from this method
     * @return {number} the path segment type of the current path segment.
     * @exception NoSuchElementException
     * if there are no more elements in the flattening path to be
     * returned.
     * @see PathIterator#SEG_MOVETO
     * @see PathIterator#SEG_LINETO
     * @see PathIterator#SEG_CLOSE
     */
    FlatteningPathIterator.prototype.currentSegment$float_A = function (coords) {
        if (this.isDone()) {
            throw Object.defineProperty(new Error("flattening iterator out of bounds"), '__class', { configurable: true, value: 'java.util.NoSuchElementException' });
        }
        var type = this.holdType;
        if (type !== PathIterator.SEG_CLOSE) {
            coords[0] = this.hold[this.holdIndex + 0];
            coords[1] = this.hold[this.holdIndex + 1];
            if (type !== PathIterator.SEG_MOVETO) {
                type = PathIterator.SEG_LINETO;
            }
        }
        return type;
    };
    /**
     * Returns the coordinates and type of the current path segment in the
     * iteration. The return value is the path segment type: SEG_MOVETO,
     * SEG_LINETO, or SEG_CLOSE. A float array of length 6 must be passed in and
     * can be used to store the coordinates of the point(s). Each point is
     * stored as a pair of float x,y coordinates. SEG_MOVETO and SEG_LINETO
     * types return one point, and SEG_CLOSE does not return any points.
     *
     * @param {Array} coords
     * an array that holds the data returned from this method
     * @return {number} the path segment type of the current path segment.
     * @exception NoSuchElementException
     * if there are no more elements in the flattening path to be
     * returned.
     * @see PathIterator#SEG_MOVETO
     * @see PathIterator#SEG_LINETO
     * @see PathIterator#SEG_CLOSE
     */
    FlatteningPathIterator.prototype.currentSegment = function (coords) {
        if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
            return this.currentSegment$float_A(coords);
        }
        else if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
            return this.currentSegment$double_A(coords);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Returns the coordinates and type of the current path segment in the
     * iteration. The return value is the path segment type: SEG_MOVETO,
     * SEG_LINETO, or SEG_CLOSE. A double array of length 6 must be passed in
     * and can be used to store the coordinates of the point(s). Each point is
     * stored as a pair of double x,y coordinates. SEG_MOVETO and SEG_LINETO
     * types return one point, and SEG_CLOSE does not return any points.
     *
     * @param {Array} coords
     * an array that holds the data returned from this method
     * @return {number} the path segment type of the current path segment.
     * @exception NoSuchElementException
     * if there are no more elements in the flattening path to be
     * returned.
     * @see PathIterator#SEG_MOVETO
     * @see PathIterator#SEG_LINETO
     * @see PathIterator#SEG_CLOSE
     */
    FlatteningPathIterator.prototype.currentSegment$double_A = function (coords) {
        if (this.isDone()) {
            throw Object.defineProperty(new Error("flattening iterator out of bounds"), '__class', { configurable: true, value: 'java.util.NoSuchElementException' });
        }
        var type = this.holdType;
        if (type !== PathIterator.SEG_CLOSE) {
            coords[0] = this.hold[this.holdIndex + 0];
            coords[1] = this.hold[this.holdIndex + 1];
            if (type !== PathIterator.SEG_MOVETO) {
                type = PathIterator.SEG_LINETO;
            }
        }
        return type;
    };
    return FlatteningPathIterator;
}());
FlatteningPathIterator.GROW_SIZE = 24;
FlatteningPathIterator["__class"] = "FlatteningPathIterator";
FlatteningPathIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
var Helper = (function () {
    function Helper() {
    }
    Helper.unsafeClone = function (array, fromIndex, toIndex) {
        return array.slice(fromIndex, toIndex);
    };
    Helper.arraycopy = function (src, srcOfs, dest, destOfs, len) {
        var overwrite = true;
        if (src === dest) {
            src = Helper.unsafeClone(src, srcOfs, srcOfs + len);
            srcOfs = 0;
        }
        for (var batchStart = srcOfs, end = srcOfs + len; batchStart < end;) {
            var batchEnd = Math.min(batchStart + Helper.ARRAY_PROCESS_BATCH_SIZE, end);
            len = batchEnd - batchStart;
            Helper.applySplice(dest, destOfs, overwrite ? len : 0, Helper.unsafeClone(src, batchStart, batchEnd));
            batchStart = batchEnd;
            destOfs += len;
        }
    };
    Helper.applySplice = function (arrayObject, index, deleteCount, arrayToAdd) {
        Array.prototype.splice.apply(arrayObject, [index, deleteCount].concat(arrayToAdd));
    };
    return Helper;
}());
Helper.ARRAY_PROCESS_BATCH_SIZE = 10000;
Helper["__class"] = "Helper";
/**
 * Constructs an <code>IllegalPathStateException</code> with the
 * specified detail message.
 * @param   {string} s   the detail message
 * @since   1.2
 * @class
 */
var IllegalPathStateException = (function (_super) {
    __extends(IllegalPathStateException, _super);
    function IllegalPathStateException(s) {
        var _this = this;
        if (((typeof s === 'string') || s === null)) {
            var __args = Array.prototype.slice.call(arguments);
            _this = _super.call(this, s) || this;
            _this.message = s;
        }
        else if (s === undefined) {
            var __args = Array.prototype.slice.call(arguments);
            _this = _super.call(this) || this;
        }
        else
            throw new Error('invalid overload');
        return _this;
    }
    return IllegalPathStateException;
}(Error));
IllegalPathStateException["__class"] = "IllegalPathStateException";
IllegalPathStateException["__interfaces"] = ["java.io.Serializable"];
/**
 * This is an abstract class that cannot be instantiated directly.
 * Type-specific implementation subclasses are available for instantiation
 * and provide a number of formats for storing the information necessary to
 * satisfy the various accessory methods below.
 *
 * @see java.awt.geom.Line2D.Float
 * @see java.awt.geom.Line2D.Double
 * @since 1.2
 * @class
 */
var Line2D = (function () {
    function Line2D() {
    }
    /**
     * Sets the location of the end points of this <code>Line2D</code> to
     * the specified float coordinates.
     *
     * @param {number} x1
     * the X coordinate of the start point
     * @param {number} y1
     * the Y coordinate of the start point
     * @param {number} x2
     * the X coordinate of the end point
     * @param {number} y2
     * the Y coordinate of the end point
     * @since 1.2
     */
    Line2D.prototype.setLine = function (x1, y1, x2, y2) {
        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
            return this.setLine$double$double$double$double(x1, y1, x2, y2);
        }
        else if (((x1 != null && x1 instanceof Point2D) || x1 === null) && ((y1 != null && y1 instanceof Point2D) || y1 === null) && x2 === undefined && y2 === undefined) {
            return this.setLine$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1);
        }
        else if (((x1 != null && x1 instanceof Line2D) || x1 === null) && y1 === undefined && x2 === undefined && y2 === undefined) {
            return this.setLine$java_awt_geom_Line2D(x1);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Sets the location of the end points of this <code>Line2D</code> to the
     * specified double coordinates.
     *
     * @param {number} x1
     * the X coordinate of the start point
     * @param {number} y1
     * the Y coordinate of the start point
     * @param {number} x2
     * the X coordinate of the end point
     * @param {number} y2
     * the Y coordinate of the end point
     * @since 1.2
     */
    Line2D.prototype.setLine$double$double$double$double = function (x1, y1, x2, y2) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
    /**
     * Sets the location of the end points of this <code>Line2D</code> to the
     * specified <code>Point2D</code> coordinates.
     *
     * @param {Point2D} p1
     * the start <code>Point2D</code> of the line segment
     * @param {Point2D} p2
     * the end <code>Point2D</code> of the line segment
     * @since 1.2
     */
    Line2D.prototype.setLine$java_awt_geom_Point2D$java_awt_geom_Point2D = function (p1, p2) {
        this.setLine$double$double$double$double(p1.getX(), p1.getY(), p2.getX(), p2.getY());
    };
    /**
     * Sets the location of the end points of this <code>Line2D</code> to the
     * same as those end points of the specified <code>Line2D</code>.
     *
     * @param {Line2D} l
     * the specified <code>Line2D</code>
     * @since 1.2
     */
    Line2D.prototype.setLine$java_awt_geom_Line2D = function (l) {
        this.setLine$double$double$double$double(l.getX1(), l.getY1(), l.getX2(), l.getY2());
    };
    /**
     * Returns an indicator of where the specified point {@code (px,py)} lies
     * with respect to the line segment from {@code (x1,y1)} to {@code (x2,y2)}.
     * The return value can be either 1, -1, or 0 and indicates in which
     * direction the specified line must pivot around its first end point,
     * {@code (x1,y1)}, in order to point at the specified point {@code (px,py)}
     * .
     * <p>
     * A return value of 1 indicates that the line segment must turn in the
     * direction that takes the positive X axis towards the negative Y axis. In
     * the default coordinate system used by Java 2D, this direction is
     * counterclockwise.
     * <p>
     * A return value of -1 indicates that the line segment must turn in the
     * direction that takes the positive X axis towards the positive Y axis. In
     * the default coordinate system, this direction is clockwise.
     * <p>
     * A return value of 0 indicates that the point lies exactly on the line
     * segment. Note that an indicator value of 0 is rare and not useful for
     * determining collinearity because of floating point rounding issues.
     * <p>
     * If the point is colinear with the line segment, but not between the end
     * points, then the value will be -1 if the point lies
     * "beyond {@code (x1,y1)}" or 1 if the point lies "beyond {@code (x2,y2)}".
     *
     * @param {number} x1
     * the X coordinate of the start point of the specified line
     * segment
     * @param {number} y1
     * the Y coordinate of the start point of the specified line
     * segment
     * @param {number} x2
     * the X coordinate of the end point of the specified line
     * segment
     * @param {number} y2
     * the Y coordinate of the end point of the specified line
     * segment
     * @param {number} px
     * the X coordinate of the specified point to be compared with
     * the specified line segment
     * @param {number} py
     * the Y coordinate of the specified point to be compared with
     * the specified line segment
     * @return {number} an integer that indicates the position of the third specified
     * coordinates with respect to the line segment formed by the first
     * two specified coordinates.
     * @since 1.2
     */
    Line2D.relativeCCW = function (x1, y1, x2, y2, px, py) {
        x2 -= x1;
        y2 -= y1;
        px -= x1;
        py -= y1;
        var ccw = px * y2 - py * x2;
        if (ccw === 0.0) {
            ccw = px * x2 + py * y2;
            if (ccw > 0.0) {
                px -= x2;
                py -= y2;
                ccw = px * x2 + py * y2;
                if (ccw < 0.0) {
                    ccw = 0.0;
                }
            }
        }
        return (ccw < 0.0) ? -1 : ((ccw > 0.0) ? 1 : 0);
    };
    /**
     * Returns an indicator of where the specified point {@code (px,py)} lies
     * with respect to this line segment. See the method comments of
     * {@link #relativeCCW(double, double, double, double, double, double)} to
     * interpret the return value.
     *
     * @param {number} px
     * the X coordinate of the specified point to be compared with
     * this <code>Line2D</code>
     * @param {number} py
     * the Y coordinate of the specified point to be compared with
     * this <code>Line2D</code>
     * @return {number} an integer that indicates the position of the specified
     * coordinates with respect to this <code>Line2D</code>
     * @see #relativeCCW(double, double, double, double, double, double)
     * @since 1.2
     */
    Line2D.prototype.relativeCCW$double$double = function (px, py) {
        return Line2D.relativeCCW(this.getX1(), this.getY1(), this.getX2(), this.getY2(), px, py);
    };
    /**
     * Returns an indicator of where the specified point {@code (px,py)} lies
     * with respect to this line segment. See the method comments of
     * {@link #relativeCCW(double, double, double, double, double, double)} to
     * interpret the return value.
     *
     * @param {number} px
     * the X coordinate of the specified point to be compared with
     * this <code>Line2D</code>
     * @param {number} py
     * the Y coordinate of the specified point to be compared with
     * this <code>Line2D</code>
     * @return {number} an integer that indicates the position of the specified
     * coordinates with respect to this <code>Line2D</code>
     * @see #relativeCCW(double, double, double, double, double, double)
     * @since 1.2
     */
    Line2D.prototype.relativeCCW = function (px, py) {
        if (((typeof px === 'number') || px === null) && ((typeof py === 'number') || py === null)) {
            return this.relativeCCW$double$double(px, py);
        }
        else if (((px != null && px instanceof Point2D) || px === null) && py === undefined) {
            return this.relativeCCW$java_awt_geom_Point2D(px);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Returns an indicator of where the specified <code>Point2D</code> lies
     * with respect to this line segment. See the method comments of
     * {@link #relativeCCW(double, double, double, double, double, double)} to
     * interpret the return value.
     *
     * @param {Point2D} p
     * the specified <code>Point2D</code> to be compared with this
     * <code>Line2D</code>
     * @return {number} an integer that indicates the position of the specified
     * <code>Point2D</code> with respect to this <code>Line2D</code>
     * @see #relativeCCW(double, double, double, double, double, double)
     * @since 1.2
     */
    Line2D.prototype.relativeCCW$java_awt_geom_Point2D = function (p) {
        return Line2D.relativeCCW(this.getX1(), this.getY1(), this.getX2(), this.getY2(), p.getX(), p.getY());
    };
    /**
     * Tests if the line segment from {@code (x1,y1)} to {@code (x2,y2)}
     * intersects the line segment from {@code (x3,y3)} to {@code (x4,y4)}.
     *
     * @param {number} x1
     * the X coordinate of the start point of the first specified
     * line segment
     * @param {number} y1
     * the Y coordinate of the start point of the first specified
     * line segment
     * @param {number} x2
     * the X coordinate of the end point of the first specified line
     * segment
     * @param {number} y2
     * the Y coordinate of the end point of the first specified line
     * segment
     * @param {number} x3
     * the X coordinate of the start point of the second specified
     * line segment
     * @param {number} y3
     * the Y coordinate of the start point of the second specified
     * line segment
     * @param {number} x4
     * the X coordinate of the end point of the second specified line
     * segment
     * @param {number} y4
     * the Y coordinate of the end point of the second specified line
     * segment
     * @return {boolean} <code>true</code> if the first specified line segment and the
     * second specified line segment intersect each other;
     * <code>false</code> otherwise.
     * @since 1.2
     */
    Line2D.linesIntersect = function (x1, y1, x2, y2, x3, y3, x4, y4) {
        return ((Line2D.relativeCCW(x1, y1, x2, y2, x3, y3) * Line2D.relativeCCW(x1, y1, x2, y2, x4, y4) <= 0) && (Line2D.relativeCCW(x3, y3, x4, y4, x1, y1) * Line2D.relativeCCW(x3, y3, x4, y4, x2, y2) <= 0));
    };
    /**
     * Tests if the line segment from {@code (x1,y1)} to {@code (x2,y2)}
     * intersects this line segment.
     *
     * @param {number} x1
     * the X coordinate of the start point of the specified line
     * segment
     * @param {number} y1
     * the Y coordinate of the start point of the specified line
     * segment
     * @param {number} x2
     * the X coordinate of the end point of the specified line
     * segment
     * @param {number} y2
     * the Y coordinate of the end point of the specified line
     * segment
     * @return {boolean} {@code <true>} if this line segment and the specified line
     * segment intersect each other; <code>false</code> otherwise.
     * @since 1.2
     */
    Line2D.prototype.intersectsLine$double$double$double$double = function (x1, y1, x2, y2) {
        return Line2D.linesIntersect(x1, y1, x2, y2, this.getX1(), this.getY1(), this.getX2(), this.getY2());
    };
    /**
     * Tests if the line segment from {@code (x1,y1)} to {@code (x2,y2)}
     * intersects this line segment.
     *
     * @param {number} x1
     * the X coordinate of the start point of the specified line
     * segment
     * @param {number} y1
     * the Y coordinate of the start point of the specified line
     * segment
     * @param {number} x2
     * the X coordinate of the end point of the specified line
     * segment
     * @param {number} y2
     * the Y coordinate of the end point of the specified line
     * segment
     * @return {boolean} {@code <true>} if this line segment and the specified line
     * segment intersect each other; <code>false</code> otherwise.
     * @since 1.2
     */
    Line2D.prototype.intersectsLine = function (x1, y1, x2, y2) {
        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
            return this.intersectsLine$double$double$double$double(x1, y1, x2, y2);
        }
        else if (((x1 != null && x1 instanceof Line2D) || x1 === null) && y1 === undefined && x2 === undefined && y2 === undefined) {
            return this.intersectsLine$java_awt_geom_Line2D(x1);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Tests if the specified line segment intersects this line segment.
     *
     * @param {Line2D} l
     * the specified <code>Line2D</code>
     * @return {boolean} <code>true</code> if this line segment and the specified line
     * segment intersect each other; <code>false</code> otherwise.
     * @since 1.2
     */
    Line2D.prototype.intersectsLine$java_awt_geom_Line2D = function (l) {
        return Line2D.linesIntersect(l.getX1(), l.getY1(), l.getX2(), l.getY2(), this.getX1(), this.getY1(), this.getX2(), this.getY2());
    };
    /**
     * Returns the square of the distance from a point to a line segment. The
     * distance measured is the distance between the specified point and the
     * closest point between the specified end points. If the specified point
     * intersects the line segment in between the end points, this method
     * returns 0.0.
     *
     * @param {number} x1
     * the X coordinate of the start point of the specified line
     * segment
     * @param {number} y1
     * the Y coordinate of the start point of the specified line
     * segment
     * @param {number} x2
     * the X coordinate of the end point of the specified line
     * segment
     * @param {number} y2
     * the Y coordinate of the end point of the specified line
     * segment
     * @param {number} px
     * the X coordinate of the specified point being measured against
     * the specified line segment
     * @param {number} py
     * the Y coordinate of the specified point being measured against
     * the specified line segment
     * @return {number} a double value that is the square of the distance from the
     * specified point to the specified line segment.
     * @see #ptLineDistSq(double, double, double, double, double, double)
     * @since 1.2
     */
    Line2D.ptSegDistSq = function (x1, y1, x2, y2, px, py) {
        x2 -= x1;
        y2 -= y1;
        px -= x1;
        py -= y1;
        var dotprod = px * x2 + py * y2;
        var projlenSq;
        if (dotprod <= 0.0) {
            projlenSq = 0.0;
        }
        else {
            px = x2 - px;
            py = y2 - py;
            dotprod = px * x2 + py * y2;
            if (dotprod <= 0.0) {
                projlenSq = 0.0;
            }
            else {
                projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);
            }
        }
        var lenSq = px * px + py * py - projlenSq;
        if (lenSq < 0) {
            lenSq = 0;
        }
        return lenSq;
    };
    /**
     * Returns the distance from a point to a line segment. The distance
     * measured is the distance between the specified point and the closest
     * point between the specified end points. If the specified point intersects
     * the line segment in between the end points, this method returns 0.0.
     *
     * @param {number} x1
     * the X coordinate of the start point of the specified line
     * segment
     * @param {number} y1
     * the Y coordinate of the start point of the specified line
     * segment
     * @param {number} x2
     * the X coordinate of the end point of the specified line
     * segment
     * @param {number} y2
     * the Y coordinate of the end point of the specified line
     * segment
     * @param {number} px
     * the X coordinate of the specified point being measured against
     * the specified line segment
     * @param {number} py
     * the Y coordinate of the specified point being measured against
     * the specified line segment
     * @return {number} a double value that is the distance from the specified point to
     * the specified line segment.
     * @see #ptLineDist(double, double, double, double, double, double)
     * @since 1.2
     */
    Line2D.ptSegDist = function (x1, y1, x2, y2, px, py) {
        return Math.sqrt(Line2D.ptSegDistSq(x1, y1, x2, y2, px, py));
    };
    /**
     * Returns the square of the distance from a point to this line segment. The
     * distance measured is the distance between the specified point and the
     * closest point between the current line's end points. If the specified
     * point intersects the line segment in between the end points, this method
     * returns 0.0.
     *
     * @param {number} px
     * the X coordinate of the specified point being measured against
     * this line segment
     * @param {number} py
     * the Y coordinate of the specified point being measured against
     * this line segment
     * @return {number} a double value that is the square of the distance from the
     * specified point to the current line segment.
     * @see #ptLineDistSq(double, double)
     * @since 1.2
     */
    Line2D.prototype.ptSegDistSq$double$double = function (px, py) {
        return Line2D.ptSegDistSq(this.getX1(), this.getY1(), this.getX2(), this.getY2(), px, py);
    };
    /**
     * Returns the square of the distance from a point to this line segment. The
     * distance measured is the distance between the specified point and the
     * closest point between the current line's end points. If the specified
     * point intersects the line segment in between the end points, this method
     * returns 0.0.
     *
     * @param {number} px
     * the X coordinate of the specified point being measured against
     * this line segment
     * @param {number} py
     * the Y coordinate of the specified point being measured against
     * this line segment
     * @return {number} a double value that is the square of the distance from the
     * specified point to the current line segment.
     * @see #ptLineDistSq(double, double)
     * @since 1.2
     */
    Line2D.prototype.ptSegDistSq = function (px, py) {
        if (((typeof px === 'number') || px === null) && ((typeof py === 'number') || py === null)) {
            return this.ptSegDistSq$double$double(px, py);
        }
        else if (((px != null && px instanceof Point2D) || px === null) && py === undefined) {
            return this.ptSegDistSq$java_awt_geom_Point2D(px);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Returns the square of the distance from a <code>Point2D</code> to this
     * line segment. The distance measured is the distance between the specified
     * point and the closest point between the current line's end points. If the
     * specified point intersects the line segment in between the end points,
     * this method returns 0.0.
     *
     * @param {Point2D} pt
     * the specified <code>Point2D</code> being measured against this
     * line segment.
     * @return {number} a double value that is the square of the distance from the
     * specified <code>Point2D</code> to the current line segment.
     * @see #ptLineDistSq(Point2D)
     * @since 1.2
     */
    Line2D.prototype.ptSegDistSq$java_awt_geom_Point2D = function (pt) {
        return Line2D.ptSegDistSq(this.getX1(), this.getY1(), this.getX2(), this.getY2(), pt.getX(), pt.getY());
    };
    /**
     * Returns the distance from a point to this line segment. The distance
     * measured is the distance between the specified point and the closest
     * point between the current line's end points. If the specified point
     * intersects the line segment in between the end points, this method
     * returns 0.0.
     *
     * @param {number} px
     * the X coordinate of the specified point being measured against
     * this line segment
     * @param {number} py
     * the Y coordinate of the specified point being measured against
     * this line segment
     * @return {number} a double value that is the distance from the specified point to
     * the current line segment.
     * @see #ptLineDist(double, double)
     * @since 1.2
     */
    Line2D.prototype.ptSegDist$double$double = function (px, py) {
        return Line2D.ptSegDist(this.getX1(), this.getY1(), this.getX2(), this.getY2(), px, py);
    };
    /**
     * Returns the distance from a point to this line segment. The distance
     * measured is the distance between the specified point and the closest
     * point between the current line's end points. If the specified point
     * intersects the line segment in between the end points, this method
     * returns 0.0.
     *
     * @param {number} px
     * the X coordinate of the specified point being measured against
     * this line segment
     * @param {number} py
     * the Y coordinate of the specified point being measured against
     * this line segment
     * @return {number} a double value that is the distance from the specified point to
     * the current line segment.
     * @see #ptLineDist(double, double)
     * @since 1.2
     */
    Line2D.prototype.ptSegDist = function (px, py) {
        if (((typeof px === 'number') || px === null) && ((typeof py === 'number') || py === null)) {
            return this.ptSegDist$double$double(px, py);
        }
        else if (((px != null && px instanceof Point2D) || px === null) && py === undefined) {
            return this.ptSegDist$java_awt_geom_Point2D(px);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Returns the distance from a <code>Point2D</code> to this line segment.
     * The distance measured is the distance between the specified point and the
     * closest point between the current line's end points. If the specified
     * point intersects the line segment in between the end points, this method
     * returns 0.0.
     *
     * @param {Point2D} pt
     * the specified <code>Point2D</code> being measured against this
     * line segment
     * @return {number} a double value that is the distance from the specified
     * <code>Point2D</code> to the current line segment.
     * @see #ptLineDist(Point2D)
     * @since 1.2
     */
    Line2D.prototype.ptSegDist$java_awt_geom_Point2D = function (pt) {
        return Line2D.ptSegDist(this.getX1(), this.getY1(), this.getX2(), this.getY2(), pt.getX(), pt.getY());
    };
    /**
     * Returns the square of the distance from a point to a line. The distance
     * measured is the distance between the specified point and the closest
     * point on the infinitely-extended line defined by the specified
     * coordinates. If the specified point intersects the line, this method
     * returns 0.0.
     *
     * @param {number} x1
     * the X coordinate of the start point of the specified line
     * @param {number} y1
     * the Y coordinate of the start point of the specified line
     * @param {number} x2
     * the X coordinate of the end point of the specified line
     * @param {number} y2
     * the Y coordinate of the end point of the specified line
     * @param {number} px
     * the X coordinate of the specified point being measured against
     * the specified line
     * @param {number} py
     * the Y coordinate of the specified point being measured against
     * the specified line
     * @return {number} a double value that is the square of the distance from the
     * specified point to the specified line.
     * @see #ptSegDistSq(double, double, double, double, double, double)
     * @since 1.2
     */
    Line2D.ptLineDistSq = function (x1, y1, x2, y2, px, py) {
        x2 -= x1;
        y2 -= y1;
        px -= x1;
        py -= y1;
        var dotprod = px * x2 + py * y2;
        var projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);
        var lenSq = px * px + py * py - projlenSq;
        if (lenSq < 0) {
            lenSq = 0;
        }
        return lenSq;
    };
    /**
     * Returns the distance from a point to a line. The distance measured is the
     * distance between the specified point and the closest point on the
     * infinitely-extended line defined by the specified coordinates. If the
     * specified point intersects the line, this method returns 0.0.
     *
     * @param {number} x1
     * the X coordinate of the start point of the specified line
     * @param {number} y1
     * the Y coordinate of the start point of the specified line
     * @param {number} x2
     * the X coordinate of the end point of the specified line
     * @param {number} y2
     * the Y coordinate of the end point of the specified line
     * @param {number} px
     * the X coordinate of the specified point being measured against
     * the specified line
     * @param {number} py
     * the Y coordinate of the specified point being measured against
     * the specified line
     * @return {number} a double value that is the distance from the specified point to
     * the specified line.
     * @see #ptSegDist(double, double, double, double, double, double)
     * @since 1.2
     */
    Line2D.ptLineDist = function (x1, y1, x2, y2, px, py) {
        return Math.sqrt(Line2D.ptLineDistSq(x1, y1, x2, y2, px, py));
    };
    /**
     * Returns the square of the distance from a point to this line. The
     * distance measured is the distance between the specified point and the
     * closest point on the infinitely-extended line defined by this
     * <code>Line2D</code>. If the specified point intersects the line, this
     * method returns 0.0.
     *
     * @param {number} px
     * the X coordinate of the specified point being measured against
     * this line
     * @param {number} py
     * the Y coordinate of the specified point being measured against
     * this line
     * @return {number} a double value that is the square of the distance from a
     * specified point to the current line.
     * @see #ptSegDistSq(double, double)
     * @since 1.2
     */
    Line2D.prototype.ptLineDistSq$double$double = function (px, py) {
        return Line2D.ptLineDistSq(this.getX1(), this.getY1(), this.getX2(), this.getY2(), px, py);
    };
    /**
     * Returns the square of the distance from a point to this line. The
     * distance measured is the distance between the specified point and the
     * closest point on the infinitely-extended line defined by this
     * <code>Line2D</code>. If the specified point intersects the line, this
     * method returns 0.0.
     *
     * @param {number} px
     * the X coordinate of the specified point being measured against
     * this line
     * @param {number} py
     * the Y coordinate of the specified point being measured against
     * this line
     * @return {number} a double value that is the square of the distance from a
     * specified point to the current line.
     * @see #ptSegDistSq(double, double)
     * @since 1.2
     */
    Line2D.prototype.ptLineDistSq = function (px, py) {
        if (((typeof px === 'number') || px === null) && ((typeof py === 'number') || py === null)) {
            return this.ptLineDistSq$double$double(px, py);
        }
        else if (((px != null && px instanceof Point2D) || px === null) && py === undefined) {
            return this.ptLineDistSq$java_awt_geom_Point2D(px);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Returns the square of the distance from a specified <code>Point2D</code>
     * to this line. The distance measured is the distance between the specified
     * point and the closest point on the infinitely-extended line defined by
     * this <code>Line2D</code>. If the specified point intersects the line,
     * this method returns 0.0.
     *
     * @param {Point2D} pt
     * the specified <code>Point2D</code> being measured against this
     * line
     * @return {number} a double value that is the square of the distance from a
     * specified <code>Point2D</code> to the current line.
     * @see #ptSegDistSq(Point2D)
     * @since 1.2
     */
    Line2D.prototype.ptLineDistSq$java_awt_geom_Point2D = function (pt) {
        return Line2D.ptLineDistSq(this.getX1(), this.getY1(), this.getX2(), this.getY2(), pt.getX(), pt.getY());
    };
    /**
     * Returns the distance from a point to this line. The distance measured is
     * the distance between the specified point and the closest point on the
     * infinitely-extended line defined by this <code>Line2D</code>. If the
     * specified point intersects the line, this method returns 0.0.
     *
     * @param {number} px
     * the X coordinate of the specified point being measured against
     * this line
     * @param {number} py
     * the Y coordinate of the specified point being measured against
     * this line
     * @return {number} a double value that is the distance from a specified point to the
     * current line.
     * @see #ptSegDist(double, double)
     * @since 1.2
     */
    Line2D.prototype.ptLineDist$double$double = function (px, py) {
        return Line2D.ptLineDist(this.getX1(), this.getY1(), this.getX2(), this.getY2(), px, py);
    };
    /**
     * Returns the distance from a point to this line. The distance measured is
     * the distance between the specified point and the closest point on the
     * infinitely-extended line defined by this <code>Line2D</code>. If the
     * specified point intersects the line, this method returns 0.0.
     *
     * @param {number} px
     * the X coordinate of the specified point being measured against
     * this line
     * @param {number} py
     * the Y coordinate of the specified point being measured against
     * this line
     * @return {number} a double value that is the distance from a specified point to the
     * current line.
     * @see #ptSegDist(double, double)
     * @since 1.2
     */
    Line2D.prototype.ptLineDist = function (px, py) {
        if (((typeof px === 'number') || px === null) && ((typeof py === 'number') || py === null)) {
            return this.ptLineDist$double$double(px, py);
        }
        else if (((px != null && px instanceof Point2D) || px === null) && py === undefined) {
            return this.ptLineDist$java_awt_geom_Point2D(px);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Returns the distance from a <code>Point2D</code> to this line. The
     * distance measured is the distance between the specified point and the
     * closest point on the infinitely-extended line defined by this
     * <code>Line2D</code>. If the specified point intersects the line, this
     * method returns 0.0.
     *
     * @param {Point2D} pt
     * the specified <code>Point2D</code> being measured
     * @return {number} a double value that is the distance from a specified
     * <code>Point2D</code> to the current line.
     * @see #ptSegDist(Point2D)
     * @since 1.2
     */
    Line2D.prototype.ptLineDist$java_awt_geom_Point2D = function (pt) {
        return Line2D.ptLineDist(this.getX1(), this.getY1(), this.getX2(), this.getY2(), pt.getX(), pt.getY());
    };
    /**
     * Tests if a specified coordinate is inside the boundary of this
     * <code>Line2D</code>. This method is required to implement the
     * {@link Shape} interface, but in the case of <code>Line2D</code> objects
     * it always returns <code>false</code> since a line contains no area.
     *
     * @param {number} x
     * the X coordinate of the specified point to be tested
     * @param {number} y
     * the Y coordinate of the specified point to be tested
     * @return {boolean} <code>false</code> because a <code>Line2D</code> contains no
     * area.
     * @since 1.2
     */
    Line2D.prototype.contains$double$double = function (x, y) {
        return false;
    };
    /**
     * Tests if a given <code>Point2D</code> is inside the boundary of this
     * <code>Line2D</code>. This method is required to implement the
     * {@link Shape} interface, but in the case of <code>Line2D</code> objects
     * it always returns <code>false</code> since a line contains no area.
     *
     * @param {Point2D} p
     * the specified <code>Point2D</code> to be tested
     * @return {boolean} <code>false</code> because a <code>Line2D</code> contains no
     * area.
     * @since 1.2
     */
    Line2D.prototype.contains$java_awt_geom_Point2D = function (p) {
        return false;
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @return {boolean}
     */
    Line2D.prototype.intersects$double$double$double$double = function (x, y, w, h) {
        return this.intersects$java_awt_geom_Rectangle2D(new Rectangle2D.Double(x, y, w, h));
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @return {boolean}
     */
    Line2D.prototype.intersects = function (x, y, w, h) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
            return this.intersects$double$double$double$double(x, y, w, h);
        }
        else if (((x != null && x instanceof Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
            return this.intersects$java_awt_geom_Rectangle2D(x);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {Rectangle2D} r
     * @return {boolean}
     */
    Line2D.prototype.intersects$java_awt_geom_Rectangle2D = function (r) {
        return r.intersectsLine$double$double$double$double(this.getX1(), this.getY1(), this.getX2(), this.getY2());
    };
    /**
     * Tests if the interior of this <code>Line2D</code> entirely contains the
     * specified set of rectangular coordinates. This method is required to
     * implement the <code>Shape</code> interface, but in the case of
     * <code>Line2D</code> objects it always returns false since a line contains
     * no area.
     *
     * @param {number} x
     * the X coordinate of the upper-left corner of the specified
     * rectangular area
     * @param {number} y
     * the Y coordinate of the upper-left corner of the specified
     * rectangular area
     * @param {number} w
     * the width of the specified rectangular area
     * @param {number} h
     * the height of the specified rectangular area
     * @return {boolean} <code>false</code> because a <code>Line2D</code> contains no
     * area.
     * @since 1.2
     */
    Line2D.prototype.contains$double$double$double$double = function (x, y, w, h) {
        return false;
    };
    /**
     * Tests if the interior of this <code>Line2D</code> entirely contains the
     * specified set of rectangular coordinates. This method is required to
     * implement the <code>Shape</code> interface, but in the case of
     * <code>Line2D</code> objects it always returns false since a line contains
     * no area.
     *
     * @param {number} x
     * the X coordinate of the upper-left corner of the specified
     * rectangular area
     * @param {number} y
     * the Y coordinate of the upper-left corner of the specified
     * rectangular area
     * @param {number} w
     * the width of the specified rectangular area
     * @param {number} h
     * the height of the specified rectangular area
     * @return {boolean} <code>false</code> because a <code>Line2D</code> contains no
     * area.
     * @since 1.2
     */
    Line2D.prototype.contains = function (x, y, w, h) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
            return this.contains$double$double$double$double(x, y, w, h);
        }
        else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined) {
            return this.contains$double$double(x, y);
        }
        else if (((x != null && x instanceof Point2D) || x === null) && y === undefined && w === undefined && h === undefined) {
            return this.contains$java_awt_geom_Point2D(x);
        }
        else if (((x != null && x instanceof Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
            return this.contains$java_awt_geom_Rectangle2D(x);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Tests if the interior of this <code>Line2D</code> entirely contains the
     * specified <code>Rectangle2D</code>. This method is required to implement
     * the <code>Shape</code> interface, but in the case of <code>Line2D</code>
     * objects it always returns <code>false</code> since a line contains no
     * area.
     *
     * @param {Rectangle2D} r
     * the specified <code>Rectangle2D</code> to be tested
     * @return {boolean} <code>false</code> because a <code>Line2D</code> contains no
     * area.
     * @since 1.2
     */
    Line2D.prototype.contains$java_awt_geom_Rectangle2D = function (r) {
        return false;
    };
    /**
     * Returns an iteration object that defines the boundary of this
     * <code>Line2D</code>. The iterator for this class is not multi-threaded
     * safe, which means that this <code>Line2D</code> class does not guarantee
     * that modifications to the geometry of this <code>Line2D</code> object do
     * not affect any iterations of that geometry that are already in process.
     *
     * @param {AffineTransform} at
     * the specified {@link AffineTransform}
     * @return {PathIterator} a {@link PathIterator} that defines the boundary of this
     * <code>Line2D</code>.
     * @since 1.2
     */
    Line2D.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
        return new LineIterator(this, at);
    };
    /**
     * Returns an iteration object that defines the boundary of this flattened
     * <code>Line2D</code>. The iterator for this class is not multi-threaded
     * safe, which means that this <code>Line2D</code> class does not guarantee
     * that modifications to the geometry of this <code>Line2D</code> object do
     * not affect any iterations of that geometry that are already in process.
     *
     * @param {AffineTransform} at
     * the specified <code>AffineTransform</code>
     * @param {number} flatness
     * the maximum amount that the control points for a given curve
     * can vary from colinear before a subdivided curve is replaced
     * by a straight line connecting the end points. Since a
     * <code>Line2D</code> object is always flat, this parameter is
     * ignored.
     * @return {PathIterator} a <code>PathIterator</code> that defines the boundary of the
     * flattened <code>Line2D</code>
     * @since 1.2
     */
    Line2D.prototype.getPathIterator$java_awt_geom_AffineTransform$double = function (at, flatness) {
        return new LineIterator(this, at);
    };
    /**
     * Returns an iteration object that defines the boundary of this flattened
     * <code>Line2D</code>. The iterator for this class is not multi-threaded
     * safe, which means that this <code>Line2D</code> class does not guarantee
     * that modifications to the geometry of this <code>Line2D</code> object do
     * not affect any iterations of that geometry that are already in process.
     *
     * @param {AffineTransform} at
     * the specified <code>AffineTransform</code>
     * @param {number} flatness
     * the maximum amount that the control points for a given curve
     * can vary from colinear before a subdivided curve is replaced
     * by a straight line connecting the end points. Since a
     * <code>Line2D</code> object is always flat, this parameter is
     * ignored.
     * @return {PathIterator} a <code>PathIterator</code> that defines the boundary of the
     * flattened <code>Line2D</code>
     * @since 1.2
     */
    Line2D.prototype.getPathIterator = function (at, flatness) {
        if (((at != null && at instanceof AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
            return this.getPathIterator$java_awt_geom_AffineTransform$double(at, flatness);
        }
        else if (((at != null && at instanceof AffineTransform) || at === null) && flatness === undefined) {
            return this.getPathIterator$java_awt_geom_AffineTransform(at);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Creates a new object of the same class as this object.
     *
     * @return {*} a clone of this instance.
     * @exception OutOfMemoryError
     * if there is not enough memory.
     * @see java.lang.Cloneable
     * @since 1.2
     */
    Line2D.prototype.clone = function () {
        try {
            return (function (o) { var clone = Object.create(o); for (var p in o) {
                if (o.hasOwnProperty(p))
                    clone[p] = o[p];
            } return clone; })(this);
        }
        catch (e) {
            throw Object.defineProperty(new Error(e.message), '__class', { configurable: true, value: 'java.lang.InternalError' });
        }
        ;
    };
    return Line2D;
}());
Line2D["__class"] = "Line2D";
Line2D["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable"];
(function (Line2D) {
    /**
     * Constructs and initializes a Line from the specified coordinates.
     *
     * @param {number} x1
     * the X coordinate of the start point
     * @param {number} y1
     * the Y coordinate of the start point
     * @param {number} x2
     * the X coordinate of the end point
     * @param {number} y2
     * the Y coordinate of the end point
     * @since 1.2
     * @class
     */
    var Float = (function (_super) {
        __extends(Float, _super);
        function Float(x1, y1, x2, y2) {
            var _this = this;
            if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this) || this;
                _this.x1 = 0;
                _this.y1 = 0;
                _this.x2 = 0;
                _this.y2 = 0;
                _this.x1 = 0;
                _this.y1 = 0;
                _this.x2 = 0;
                _this.y2 = 0;
                (function () {
                    _this.setLine$double$double$double$double(x1, y1, x2, y2);
                })();
            }
            else if (((x1 != null && x1 instanceof Point2D) || x1 === null) && ((y1 != null && y1 instanceof Point2D) || y1 === null) && x2 === undefined && y2 === undefined) {
                var __args = Array.prototype.slice.call(arguments);
                var p1_1 = __args[0];
                var p2_1 = __args[1];
                _this = _super.call(this) || this;
                _this.x1 = 0;
                _this.y1 = 0;
                _this.x2 = 0;
                _this.y2 = 0;
                _this.x1 = 0;
                _this.y1 = 0;
                _this.x2 = 0;
                _this.y2 = 0;
                (function () {
                    _this.setLine$java_awt_geom_Point2D$java_awt_geom_Point2D(p1_1, p2_1);
                })();
            }
            else if (x1 === undefined && y1 === undefined && x2 === undefined && y2 === undefined) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this) || this;
                _this.x1 = 0;
                _this.y1 = 0;
                _this.x2 = 0;
                _this.y2 = 0;
                _this.x1 = 0;
                _this.y1 = 0;
                _this.x2 = 0;
                _this.y2 = 0;
            }
            else
                throw new Error('invalid overload');
            return _this;
        }
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getX1 = function () {
            return this.x1;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getY1 = function () {
            return this.y1;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {Point2D}
         */
        Float.prototype.getP1 = function () {
            return new Point2D.Float(this.x1, this.y1);
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getX2 = function () {
            return this.x2;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getY2 = function () {
            return this.y2;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {Point2D}
         */
        Float.prototype.getP2 = function () {
            return new Point2D.Float(this.x2, this.y2);
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @param {number} x1
         * @param {number} y1
         * @param {number} x2
         * @param {number} y2
         */
        Float.prototype.setLine$double$double$double$double = function (x1, y1, x2, y2) {
            this.x1 = x1;
            this.y1 = y1;
            this.x2 = x2;
            this.y2 = y2;
        };
        /**
         * Sets the location of the end points of this <code>Line2D</code> to
         * the specified float coordinates.
         *
         * @param {number} x1
         * the X coordinate of the start point
         * @param {number} y1
         * the Y coordinate of the start point
         * @param {number} x2
         * the X coordinate of the end point
         * @param {number} y2
         * the Y coordinate of the end point
         * @since 1.2
         */
        Float.prototype.setLine$float$float$float$float = function (x1, y1, x2, y2) {
            this.x1 = x1;
            this.y1 = y1;
            this.x2 = x2;
            this.y2 = y2;
        };
        /**
         * Sets the location of the end points of this <code>Line2D</code> to
         * the specified float coordinates.
         *
         * @param {number} x1
         * the X coordinate of the start point
         * @param {number} y1
         * the Y coordinate of the start point
         * @param {number} x2
         * the X coordinate of the end point
         * @param {number} y2
         * the Y coordinate of the end point
         * @since 1.2
         */
        Float.prototype.setLine = function (x1, y1, x2, y2) {
            if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                return this.setLine$float$float$float$float(x1, y1, x2, y2);
            }
            else if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                return this.setLine$double$double$double$double(x1, y1, x2, y2);
            }
            else if (((x1 != null && x1 instanceof Point2D) || x1 === null) && ((y1 != null && y1 instanceof Point2D) || y1 === null) && x2 === undefined && y2 === undefined) {
                return this.setLine$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1);
            }
            else if (((x1 != null && x1 instanceof Line2D) || x1 === null) && y1 === undefined && x2 === undefined && y2 === undefined) {
                return this.setLine$java_awt_geom_Line2D(x1);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {Rectangle2D}
         */
        Float.prototype.getBounds2D = function () {
            var x;
            var y;
            var w;
            var h;
            if (this.x1 < this.x2) {
                x = this.x1;
                w = this.x2 - this.x1;
            }
            else {
                x = this.x2;
                w = this.x1 - this.x2;
            }
            if (this.y1 < this.y2) {
                y = this.y1;
                h = this.y2 - this.y1;
            }
            else {
                y = this.y2;
                h = this.y1 - this.y2;
            }
            return new Rectangle2D.Float(x, y, w, h);
        };
        return Float;
    }(Line2D));
    Float.serialVersionUID = 6161772511649436349;
    Line2D.Float = Float;
    Float["__class"] = "Line2D.Float";
    Float["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
    /**
     * Constructs and initializes a <code>Line2D</code> from the specified
     * coordinates.
     *
     * @param {number} x1
     * the X coordinate of the start point
     * @param {number} y1
     * the Y coordinate of the start point
     * @param {number} x2
     * the X coordinate of the end point
     * @param {number} y2
     * the Y coordinate of the end point
     * @since 1.2
     * @class
     */
    var Double = (function (_super) {
        __extends(Double, _super);
        function Double(x1, y1, x2, y2) {
            var _this = this;
            if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this) || this;
                _this.x1 = 0;
                _this.y1 = 0;
                _this.x2 = 0;
                _this.y2 = 0;
                _this.x1 = 0;
                _this.y1 = 0;
                _this.x2 = 0;
                _this.y2 = 0;
                (function () {
                    _this.setLine$double$double$double$double(x1, y1, x2, y2);
                })();
            }
            else if (((x1 != null && x1 instanceof Point2D) || x1 === null) && ((y1 != null && y1 instanceof Point2D) || y1 === null) && x2 === undefined && y2 === undefined) {
                var __args = Array.prototype.slice.call(arguments);
                var p1_2 = __args[0];
                var p2_2 = __args[1];
                _this = _super.call(this) || this;
                _this.x1 = 0;
                _this.y1 = 0;
                _this.x2 = 0;
                _this.y2 = 0;
                _this.x1 = 0;
                _this.y1 = 0;
                _this.x2 = 0;
                _this.y2 = 0;
                (function () {
                    _this.setLine$java_awt_geom_Point2D$java_awt_geom_Point2D(p1_2, p2_2);
                })();
            }
            else if (x1 === undefined && y1 === undefined && x2 === undefined && y2 === undefined) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this) || this;
                _this.x1 = 0;
                _this.y1 = 0;
                _this.x2 = 0;
                _this.y2 = 0;
                _this.x1 = 0;
                _this.y1 = 0;
                _this.x2 = 0;
                _this.y2 = 0;
            }
            else
                throw new Error('invalid overload');
            return _this;
        }
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getX1 = function () {
            return this.x1;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getY1 = function () {
            return this.y1;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {Point2D}
         */
        Double.prototype.getP1 = function () {
            return new Point2D.Double(this.x1, this.y1);
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getX2 = function () {
            return this.x2;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getY2 = function () {
            return this.y2;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {Point2D}
         */
        Double.prototype.getP2 = function () {
            return new Point2D.Double(this.x2, this.y2);
        };
        /**
         * Sets the location of the end points of this <code>Line2D</code> to
         * the specified float coordinates.
         *
         * @param {number} x1
         * the X coordinate of the start point
         * @param {number} y1
         * the Y coordinate of the start point
         * @param {number} x2
         * the X coordinate of the end point
         * @param {number} y2
         * the Y coordinate of the end point
         * @since 1.2
         */
        Double.prototype.setLine = function (x1, y1, x2, y2) {
            if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                return this.setLine$double$double$double$double(x1, y1, x2, y2);
            }
            else if (((x1 != null && x1 instanceof Point2D) || x1 === null) && ((y1 != null && y1 instanceof Point2D) || y1 === null) && x2 === undefined && y2 === undefined) {
                return this.setLine$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1);
            }
            else if (((x1 != null && x1 instanceof Line2D) || x1 === null) && y1 === undefined && x2 === undefined && y2 === undefined) {
                return this.setLine$java_awt_geom_Line2D(x1);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @param {number} x1
         * @param {number} y1
         * @param {number} x2
         * @param {number} y2
         */
        Double.prototype.setLine$double$double$double$double = function (x1, y1, x2, y2) {
            this.x1 = x1;
            this.y1 = y1;
            this.x2 = x2;
            this.y2 = y2;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {Rectangle2D}
         */
        Double.prototype.getBounds2D = function () {
            var x;
            var y;
            var w;
            var h;
            if (this.x1 < this.x2) {
                x = this.x1;
                w = this.x2 - this.x1;
            }
            else {
                x = this.x2;
                w = this.x1 - this.x2;
            }
            if (this.y1 < this.y2) {
                y = this.y1;
                h = this.y2 - this.y1;
            }
            else {
                y = this.y2;
                h = this.y1 - this.y2;
            }
            return new Rectangle2D.Double(x, y, w, h);
        };
        return Double;
    }(Line2D));
    Double.serialVersionUID = 7979627399746467499;
    Line2D.Double = Double;
    Double["__class"] = "Line2D.Double";
    Double["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
})(Line2D || (Line2D = {}));
/**
 * A utility class to iterate over the path segments of a line segment through
 * the PathIterator interface.
 *
 * @author Jim Graham
 */
var LineIterator = (function () {
    function LineIterator(l, at) {
        this.line = null;
        this.affine = null;
        this.index = 0;
        this.line = l;
        this.affine = at;
    }
    /**
     * Return the winding rule for determining the insideness of the path.
     *
     * @see #WIND_EVEN_ODD
     * @see #WIND_NON_ZERO
     * @return {number}
     */
    LineIterator.prototype.getWindingRule = function () {
        return PathIterator.WIND_NON_ZERO;
    };
    /**
     * Tests if there are more points to read.
     *
     * @return {boolean} true if there are more points to read
     */
    LineIterator.prototype.isDone = function () {
        return (this.index > 1);
    };
    LineIterator.prototype.next = function (doNext) {
        if (doNext === undefined) {
            return this.next$();
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Moves the iterator to the next segment of the path forwards along the
     * primary direction of traversal as long as there are more points in that
     * direction.
     */
    LineIterator.prototype.next$ = function () {
        this.index++;
    };
    /**
     * Returns the coordinates and type of the current path segment in the
     * iteration. The return value is the path segment type: SEG_MOVETO,
     * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
     * length 6 must be passed in and may be used to store the coordinates of
     * the point(s). Each point is stored as a pair of float x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
     * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
     * not return any points.
     *
     * @see #SEG_MOVETO
     * @see #SEG_LINETO
     * @see #SEG_QUADTO
     * @see #SEG_CUBICTO
     * @see #SEG_CLOSE
     * @param {Array} coords
     * @return {number}
     */
    LineIterator.prototype.currentSegment$float_A = function (coords) {
        if (this.isDone()) {
            throw Object.defineProperty(new Error("line iterator out of bounds"), '__class', { configurable: true, value: 'java.util.NoSuchElementException' });
        }
        var type;
        if (this.index === 0) {
            coords[0] = this.line.getX1();
            coords[1] = this.line.getY1();
            type = PathIterator.SEG_MOVETO;
        }
        else {
            coords[0] = this.line.getX2();
            coords[1] = this.line.getY2();
            type = PathIterator.SEG_LINETO;
        }
        if (this.affine != null) {
            this.affine.transform$float_A$int$float_A$int$int(coords, 0, coords, 0, 1);
        }
        return type;
    };
    /**
     * Returns the coordinates and type of the current path segment in the
     * iteration. The return value is the path segment type: SEG_MOVETO,
     * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
     * length 6 must be passed in and may be used to store the coordinates of
     * the point(s). Each point is stored as a pair of float x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
     * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
     * not return any points.
     *
     * @see #SEG_MOVETO
     * @see #SEG_LINETO
     * @see #SEG_QUADTO
     * @see #SEG_CUBICTO
     * @see #SEG_CLOSE
     * @param {Array} coords
     * @return {number}
     */
    LineIterator.prototype.currentSegment = function (coords) {
        if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
            return this.currentSegment$float_A(coords);
        }
        else if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
            return this.currentSegment$double_A(coords);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Returns the coordinates and type of the current path segment in the
     * iteration. The return value is the path segment type: SEG_MOVETO,
     * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A double array of
     * length 6 must be passed in and may be used to store the coordinates of
     * the point(s). Each point is stored as a pair of double x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
     * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
     * not return any points.
     *
     * @see #SEG_MOVETO
     * @see #SEG_LINETO
     * @see #SEG_QUADTO
     * @see #SEG_CUBICTO
     * @see #SEG_CLOSE
     * @param {Array} coords
     * @return {number}
     */
    LineIterator.prototype.currentSegment$double_A = function (coords) {
        if (this.isDone()) {
            throw Object.defineProperty(new Error("line iterator out of bounds"), '__class', { configurable: true, value: 'java.util.NoSuchElementException' });
        }
        var type;
        if (this.index === 0) {
            coords[0] = this.line.getX1();
            coords[1] = this.line.getY1();
            type = PathIterator.SEG_MOVETO;
        }
        else {
            coords[0] = this.line.getX2();
            coords[1] = this.line.getY2();
            type = PathIterator.SEG_LINETO;
        }
        if (this.affine != null) {
            this.affine.transform$double_A$int$double_A$int$int(coords, 0, coords, 0, 1);
        }
        return type;
    };
    return LineIterator;
}());
LineIterator["__class"] = "LineIterator";
LineIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
/**
 * Constructs an instance of <code>NoninvertibleTransformException</code>
 * with the specified detail message.
 *
 * @param {string} s
 * the detail message
 * @since 1.2
 * @class
 */
var NoninvertibleTransformException = (function (_super) {
    __extends(NoninvertibleTransformException, _super);
    function NoninvertibleTransformException(s) {
        var _this = _super.call(this, s) || this;
        _this.message = s;
        return _this;
    }
    return NoninvertibleTransformException;
}(Error));
NoninvertibleTransformException["__class"] = "NoninvertibleTransformException";
NoninvertibleTransformException["__interfaces"] = ["java.io.Serializable"];
var PathIterator;
(function (PathIterator) {
    /**
     * The winding rule constant for specifying an even-odd rule for determining
     * the interior of a path. The even-odd rule specifies that a point lies
     * inside the path if a ray drawn in any direction from that point to
     * infinity is crossed by path segments an odd number of times.
     */
    PathIterator.WIND_EVEN_ODD = 0;
    /**
     * The winding rule constant for specifying a non-zero rule for determining
     * the interior of a path. The non-zero rule specifies that a point lies
     * inside the path if a ray drawn in any direction from that point to
     * infinity is crossed by path segments a different number of times in the
     * counter-clockwise direction than the clockwise direction.
     */
    PathIterator.WIND_NON_ZERO = 1;
    /**
     * The segment type constant for a point that specifies the starting
     * location for a new subpath.
     */
    PathIterator.SEG_MOVETO = 0;
    /**
     * The segment type constant for a point that specifies the end point of a
     * line to be drawn from the most recently specified point.
     */
    PathIterator.SEG_LINETO = 1;
    /**
     * The segment type constant for the pair of points that specify a quadratic
     * parametric curve to be drawn from the most recently specified point. The
     * curve is interpolated by solving the parametric control equation in the
     * range <code>(t=[0..1])</code> using the most recently specified (current)
     * point (CP), the first control point (P1), and the final interpolated
     * control point (P2). The parametric control equation for this curve is:
     *
     * <pre>
     * P(t) = B(2,0)*CP + B(2,1)*P1 + B(2,2)*P2
     * 0 &lt;= t &lt;= 1
     *
     * B(n,m) = mth coefficient of nth degree Bernstein polynomial
     * = C(n,m) * t^(m) * (1 - t)^(n-m)
     * C(n,m) = Combinations of n things, taken m at a time
     * = n! / (m! * (n-m)!)
     * </pre>
     */
    PathIterator.SEG_QUADTO = 2;
    /**
     * The segment type constant for the set of 3 points that specify a cubic
     * parametric curve to be drawn from the most recently specified point. The
     * curve is interpolated by solving the parametric control equation in the
     * range <code>(t=[0..1])</code> using the most recently specified (current)
     * point (CP), the first control point (P1), the second control point (P2),
     * and the final interpolated control point (P3). The parametric control
     * equation for this curve is:
     *
     * <pre>
     * P(t) = B(3,0)*CP + B(3,1)*P1 + B(3,2)*P2 + B(3,3)*P3
     * 0 &lt;= t &lt;= 1
     *
     * B(n,m) = mth coefficient of nth degree Bernstein polynomial
     * = C(n,m) * t^(m) * (1 - t)^(n-m)
     * C(n,m) = Combinations of n things, taken m at a time
     * = n! / (m! * (n-m)!)
     * </pre>
     *
     * This form of curve is commonly known as a B&eacute;zier curve.
     */
    PathIterator.SEG_CUBICTO = 3;
    /**
     * The segment type constant that specifies that the preceding subpath
     * should be closed by appending a line segment back to the point
     * corresponding to the most recent SEG_MOVETO.
     */
    PathIterator.SEG_CLOSE = 4;
})(PathIterator || (PathIterator = {}));
/**
 * This is an abstract class that cannot be instantiated directly.
 * Type-specific implementation subclasses are available for instantiation
 * and provide a number of formats for storing the information necessary to
 * satisfy the various accessor methods below.
 *
 * @see java.awt.geom.Point2D.Float
 * @see java.awt.geom.Point2D.Double
 * @see java.awt.Point
 * @since 1.2
 * @class
 */
var Point2D = (function () {
    function Point2D() {
    }
    /**
     * Sets the location of this <code>Point2D</code> to the specified
     * <code>float</code> coordinates.
     *
     * @param {number} x
     * the new X coordinate of this {@code Point2D}
     * @param {number} y
     * the new Y coordinate of this {@code Point2D}
     * @since 1.2
     */
    Point2D.prototype.setLocation = function (x, y) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
            return this.setLocation$double$double(x, y);
        }
        else if (((x != null && x instanceof Point2D) || x === null) && y === undefined) {
            return this.setLocation$java_awt_geom_Point2D(x);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Sets the location of this <code>Point2D</code> to the specified
     * <code>double</code> coordinates.
     *
     * @param {number} x
     * the new X coordinate of this {@code Point2D}
     * @param {number} y
     * the new Y coordinate of this {@code Point2D}
     * @since 1.2
     */
    Point2D.prototype.setLocation$double$double = function (x, y) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
    /**
     * Sets the location of this <code>Point2D</code> to the same coordinates as
     * the specified <code>Point2D</code> object.
     *
     * @param {Point2D} p
     * the specified <code>Point2D</code> to which to set this
     * <code>Point2D</code>
     * @since 1.2
     */
    Point2D.prototype.setLocation$java_awt_geom_Point2D = function (p) {
        this.setLocation$double$double(p.getX(), p.getY());
    };
    /**
     * Returns the square of the distance between two points.
     *
     * @param {number} x1
     * the X coordinate of the first specified point
     * @param {number} y1
     * the Y coordinate of the first specified point
     * @param {number} x2
     * the X coordinate of the second specified point
     * @param {number} y2
     * the Y coordinate of the second specified point
     * @return {number} the square of the distance between the two sets of specified
     * coordinates.
     * @since 1.2
     */
    Point2D.distanceSq = function (x1, y1, x2, y2) {
        x1 -= x2;
        y1 -= y2;
        return (x1 * x1 + y1 * y1);
    };
    /**
     * Returns the distance between two points.
     *
     * @param {number} x1
     * the X coordinate of the first specified point
     * @param {number} y1
     * the Y coordinate of the first specified point
     * @param {number} x2
     * the X coordinate of the second specified point
     * @param {number} y2
     * the Y coordinate of the second specified point
     * @return {number} the distance between the two sets of specified coordinates.
     * @since 1.2
     */
    Point2D.distance = function (x1, y1, x2, y2) {
        x1 -= x2;
        y1 -= y2;
        return Math.sqrt(x1 * x1 + y1 * y1);
    };
    /**
     * Returns the square of the distance from this <code>Point2D</code> to a
     * specified point.
     *
     * @param {number} px
     * the X coordinate of the specified point to be measured against
     * this <code>Point2D</code>
     * @param {number} py
     * the Y coordinate of the specified point to be measured against
     * this <code>Point2D</code>
     * @return {number} the square of the distance between this <code>Point2D</code> and
     * the specified point.
     * @since 1.2
     */
    Point2D.prototype.distanceSq$double$double = function (px, py) {
        px -= this.getX();
        py -= this.getY();
        return (px * px + py * py);
    };
    /**
     * Returns the square of the distance from this <code>Point2D</code> to a
     * specified point.
     *
     * @param {number} px
     * the X coordinate of the specified point to be measured against
     * this <code>Point2D</code>
     * @param {number} py
     * the Y coordinate of the specified point to be measured against
     * this <code>Point2D</code>
     * @return {number} the square of the distance between this <code>Point2D</code> and
     * the specified point.
     * @since 1.2
     */
    Point2D.prototype.distanceSq = function (px, py) {
        if (((typeof px === 'number') || px === null) && ((typeof py === 'number') || py === null)) {
            return this.distanceSq$double$double(px, py);
        }
        else if (((px != null && px instanceof Point2D) || px === null) && py === undefined) {
            return this.distanceSq$java_awt_geom_Point2D(px);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Returns the square of the distance from this <code>Point2D</code> to a
     * specified <code>Point2D</code>.
     *
     * @param {Point2D} pt
     * the specified point to be measured against this
     * <code>Point2D</code>
     * @return {number} the square of the distance between this <code>Point2D</code> to a
     * specified <code>Point2D</code>.
     * @since 1.2
     */
    Point2D.prototype.distanceSq$java_awt_geom_Point2D = function (pt) {
        var px = pt.getX() - this.getX();
        var py = pt.getY() - this.getY();
        return (px * px + py * py);
    };
    /**
     * Returns the distance from this <code>Point2D</code> to a specified point.
     *
     * @param {number} px
     * the X coordinate of the specified point to be measured against
     * this <code>Point2D</code>
     * @param {number} py
     * the Y coordinate of the specified point to be measured against
     * this <code>Point2D</code>
     * @return {number} the distance between this <code>Point2D</code> and a specified
     * point.
     * @since 1.2
     */
    Point2D.prototype.distance$double$double = function (px, py) {
        px -= this.getX();
        py -= this.getY();
        return Math.sqrt(px * px + py * py);
    };
    /**
     * Returns the distance from this <code>Point2D</code> to a specified point.
     *
     * @param {number} px
     * the X coordinate of the specified point to be measured against
     * this <code>Point2D</code>
     * @param {number} py
     * the Y coordinate of the specified point to be measured against
     * this <code>Point2D</code>
     * @return {number} the distance between this <code>Point2D</code> and a specified
     * point.
     * @since 1.2
     */
    Point2D.prototype.distance = function (px, py) {
        if (((typeof px === 'number') || px === null) && ((typeof py === 'number') || py === null)) {
            return this.distance$double$double(px, py);
        }
        else if (((px != null && px instanceof Point2D) || px === null) && py === undefined) {
            return this.distance$java_awt_geom_Point2D(px);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Returns the distance from this <code>Point2D</code> to a specified
     * <code>Point2D</code>.
     *
     * @param {Point2D} pt
     * the specified point to be measured against this
     * <code>Point2D</code>
     * @return {number} the distance between this <code>Point2D</code> and the specified
     * <code>Point2D</code>.
     * @since 1.2
     */
    Point2D.prototype.distance$java_awt_geom_Point2D = function (pt) {
        var px = pt.getX() - this.getX();
        var py = pt.getY() - this.getY();
        return Math.sqrt(px * px + py * py);
    };
    /**
     * Creates a new object of the same class and with the same contents as this
     * object.
     *
     * @return {*} a clone of this instance.
     * @exception OutOfMemoryError
     * if there is not enough memory.
     * @see java.lang.Cloneable
     * @since 1.2
     */
    Point2D.prototype.clone = function () {
        try {
            return (function (o) { var clone = Object.create(o); for (var p in o) {
                if (o.hasOwnProperty(p))
                    clone[p] = o[p];
            } return clone; })(this);
        }
        catch (e) {
            throw Object.defineProperty(new Error(e.message), '__class', { configurable: true, value: 'java.lang.InternalError' });
        }
        ;
    };
    /**
     * Determines whether or not two points are equal. Two instances of
     * <code>Point2D</code> are equal if the values of their <code>x</code> and
     * <code>y</code> member fields, representing their position in the
     * coordinate space, are the same.
     *
     * @param {*} obj
     * an object to be compared with this <code>Point2D</code>
     * @return {boolean} <code>true</code> if the object to be compared is an instance of
     * <code>Point2D</code> and has the same values; <code>false</code>
     * otherwise.
     * @since 1.2
     */
    Point2D.prototype.equals = function (obj) {
        if (obj != null && obj instanceof Point2D) {
            var p2d = obj;
            return (this.getX() === p2d.getX()) && (this.getY() === p2d.getY());
        }
        return (this === obj);
    };
    return Point2D;
}());
Point2D["__class"] = "Point2D";
Point2D["__interfaces"] = ["java.lang.Cloneable"];
(function (Point2D) {
    /**
     * Constructs and initializes a <code>Point2D</code> with the specified
     * coordinates.
     *
     * @param {number} x
     * the X coordinate of the newly constructed
     * <code>Point2D</code>
     * @param {number} y
     * the Y coordinate of the newly constructed
     * <code>Point2D</code>
     * @since 1.2
     * @class
     */
    var Float = (function (_super) {
        __extends(Float, _super);
        function Float(x, y) {
            var _this = this;
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this) || this;
                _this.x = 0;
                _this.y = 0;
                _this.x = 0;
                _this.y = 0;
                (function () {
                    _this.x = x;
                    _this.y = y;
                })();
            }
            else if (x === undefined && y === undefined) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this) || this;
                _this.x = 0;
                _this.y = 0;
                _this.x = 0;
                _this.y = 0;
            }
            else
                throw new Error('invalid overload');
            return _this;
        }
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getX = function () {
            return this.x;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getY = function () {
            return this.y;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @param {number} x
         * @param {number} y
         */
        Float.prototype.setLocation$double$double = function (x, y) {
            this.x = x;
            this.y = y;
        };
        /**
         * Sets the location of this <code>Point2D</code> to the specified
         * <code>float</code> coordinates.
         *
         * @param {number} x
         * the new X coordinate of this {@code Point2D}
         * @param {number} y
         * the new Y coordinate of this {@code Point2D}
         * @since 1.2
         */
        Float.prototype.setLocation$float$float = function (x, y) {
            this.x = x;
            this.y = y;
        };
        /**
         * Sets the location of this <code>Point2D</code> to the specified
         * <code>float</code> coordinates.
         *
         * @param {number} x
         * the new X coordinate of this {@code Point2D}
         * @param {number} y
         * the new Y coordinate of this {@code Point2D}
         * @since 1.2
         */
        Float.prototype.setLocation = function (x, y) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.setLocation$float$float(x, y);
            }
            else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.setLocation$double$double(x, y);
            }
            else if (((x != null && x instanceof Point2D) || x === null) && y === undefined) {
                return this.setLocation$java_awt_geom_Point2D(x);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * Returns a <code>String</code> that represents the value of this
         * <code>Point2D</code>.
         *
         * @return {string} a string representation of this <code>Point2D</code>.
         * @since 1.2
         */
        Float.prototype.toString = function () {
            return "Point2D.Float[" + this.x + ", " + this.y + "]";
        };
        return Float;
    }(Point2D));
    Float.serialVersionUID = -2870572449815403710;
    Point2D.Float = Float;
    Float["__class"] = "Point2D.Float";
    Float["__interfaces"] = ["java.lang.Cloneable", "java.io.Serializable"];
    /**
     * Constructs and initializes a <code>Point2D</code> with the specified
     * coordinates.
     *
     * @param {number} x
     * the X coordinate of the newly constructed
     * <code>Point2D</code>
     * @param {number} y
     * the Y coordinate of the newly constructed
     * <code>Point2D</code>
     * @since 1.2
     * @class
     */
    var Double = (function (_super) {
        __extends(Double, _super);
        function Double(x, y) {
            var _this = this;
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this) || this;
                _this.x = 0;
                _this.y = 0;
                _this.x = 0;
                _this.y = 0;
                (function () {
                    _this.x = x;
                    _this.y = y;
                })();
            }
            else if (x === undefined && y === undefined) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this) || this;
                _this.x = 0;
                _this.y = 0;
                _this.x = 0;
                _this.y = 0;
            }
            else
                throw new Error('invalid overload');
            return _this;
        }
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getX = function () {
            return this.x;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getY = function () {
            return this.y;
        };
        /**
         * Sets the location of this <code>Point2D</code> to the specified
         * <code>float</code> coordinates.
         *
         * @param {number} x
         * the new X coordinate of this {@code Point2D}
         * @param {number} y
         * the new Y coordinate of this {@code Point2D}
         * @since 1.2
         */
        Double.prototype.setLocation = function (x, y) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.setLocation$double$double(x, y);
            }
            else if (((x != null && x instanceof Point2D) || x === null) && y === undefined) {
                return this.setLocation$java_awt_geom_Point2D(x);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @param {number} x
         * @param {number} y
         */
        Double.prototype.setLocation$double$double = function (x, y) {
            this.x = x;
            this.y = y;
        };
        /**
         * Returns a <code>String</code> that represents the value of this
         * <code>Point2D</code>.
         *
         * @return {string} a string representation of this <code>Point2D</code>.
         * @since 1.2
         */
        Double.prototype.toString = function () {
            return "Point2D.Double[" + this.x + ", " + this.y + "]";
        };
        return Double;
    }(Point2D));
    Double.serialVersionUID = 6150783262733311327;
    Point2D.Double = Double;
    Double["__class"] = "Point2D.Double";
    Double["__interfaces"] = ["java.lang.Cloneable", "java.io.Serializable"];
})(Point2D || (Point2D = {}));
/**
 * This is an abstract class that cannot be instantiated directly.
 * Type-specific implementation subclasses are available for instantiation
 * and provide a number of formats for storing the information necessary to
 * satisfy the various accessor methods below.
 *
 * @see java.awt.geom.QuadCurve2D.Float
 * @see java.awt.geom.QuadCurve2D.Double
 * @since 1.2
 * @class
 */
var QuadCurve2D = (function () {
    function QuadCurve2D() {
    }
    /**
     * Sets the location of the end points and control point of this curve
     * to the specified {@code float} coordinates.
     *
     * @param {number} x1
     * the X coordinate of the start point
     * @param {number} y1
     * the Y coordinate of the start point
     * @param {number} ctrlx
     * the X coordinate of the control point
     * @param {number} ctrly
     * the Y coordinate of the control point
     * @param {number} x2
     * the X coordinate of the end point
     * @param {number} y2
     * the Y coordinate of the end point
     * @since 1.2
     */
    QuadCurve2D.prototype.setCurve = function (x1, y1, ctrlx, ctrly, x2, y2) {
        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
            return this.setCurve$double$double$double$double$double$double(x1, y1, ctrlx, ctrly, x2, y2);
        }
        else if (((x1 != null && x1 instanceof Point2D) || x1 === null) && ((y1 != null && y1 instanceof Point2D) || y1 === null) && ((ctrlx != null && ctrlx instanceof Point2D) || ctrlx === null) && ctrly === undefined && x2 === undefined && y2 === undefined) {
            return this.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1, ctrlx);
        }
        else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (typeof x1[0] === 'number'))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
            return this.setCurve$double_A$int(x1, y1);
        }
        else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (x1[0] != null && x1[0] instanceof Point2D))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
            return this.setCurve$java_awt_geom_Point2D_A$int(x1, y1);
        }
        else if (((x1 != null && x1 instanceof QuadCurve2D) || x1 === null) && y1 === undefined && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
            return this.setCurve$java_awt_geom_QuadCurve2D(x1);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Sets the location of the end points and control point of this curve to
     * the specified <code>double</code> coordinates.
     *
     * @param {number} x1
     * the X coordinate of the start point
     * @param {number} y1
     * the Y coordinate of the start point
     * @param {number} ctrlx
     * the X coordinate of the control point
     * @param {number} ctrly
     * the Y coordinate of the control point
     * @param {number} x2
     * the X coordinate of the end point
     * @param {number} y2
     * the Y coordinate of the end point
     * @since 1.2
     */
    QuadCurve2D.prototype.setCurve$double$double$double$double$double$double = function (x1, y1, ctrlx, ctrly, x2, y2) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
    /**
     * Sets the location of the end points and control points of this
     * <code>QuadCurve2D</code> to the <code>double</code> coordinates at the
     * specified offset in the specified array.
     *
     * @param {Array} coords
     * the array containing coordinate values
     * @param {number} offset
     * the index into the array from which to start getting the
     * coordinate values and assigning them to this
     * <code>QuadCurve2D</code>
     * @since 1.2
     */
    QuadCurve2D.prototype.setCurve$double_A$int = function (coords, offset) {
        this.setCurve$double$double$double$double$double$double(coords[offset + 0], coords[offset + 1], coords[offset + 2], coords[offset + 3], coords[offset + 4], coords[offset + 5]);
    };
    /**
     * Sets the location of the end points and control point of this
     * <code>QuadCurve2D</code> to the specified <code>Point2D</code>
     * coordinates.
     *
     * @param {Point2D} p1
     * the start point
     * @param {Point2D} cp
     * the control point
     * @param {Point2D} p2
     * the end point
     * @since 1.2
     */
    QuadCurve2D.prototype.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D = function (p1, cp, p2) {
        this.setCurve$double$double$double$double$double$double(p1.getX(), p1.getY(), cp.getX(), cp.getY(), p2.getX(), p2.getY());
    };
    /**
     * Sets the location of the end points and control points of this
     * <code>QuadCurve2D</code> to the coordinates of the <code>Point2D</code>
     * objects at the specified offset in the specified array.
     *
     * @param {Array} pts
     * an array containing <code>Point2D</code> that define
     * coordinate values
     * @param {number} offset
     * the index into <code>pts</code> from which to start getting
     * the coordinate values and assigning them to this
     * <code>QuadCurve2D</code>
     * @since 1.2
     */
    QuadCurve2D.prototype.setCurve$java_awt_geom_Point2D_A$int = function (pts, offset) {
        this.setCurve$double$double$double$double$double$double(pts[offset + 0].getX(), pts[offset + 0].getY(), pts[offset + 1].getX(), pts[offset + 1].getY(), pts[offset + 2].getX(), pts[offset + 2].getY());
    };
    /**
     * Sets the location of the end points and control point of this
     * <code>QuadCurve2D</code> to the same as those in the specified
     * <code>QuadCurve2D</code>.
     *
     * @param {QuadCurve2D} c
     * the specified <code>QuadCurve2D</code>
     * @since 1.2
     */
    QuadCurve2D.prototype.setCurve$java_awt_geom_QuadCurve2D = function (c) {
        this.setCurve$double$double$double$double$double$double(c.getX1(), c.getY1(), c.getCtrlX(), c.getCtrlY(), c.getX2(), c.getY2());
    };
    /**
     * Returns the square of the flatness, or maximum distance of a control
     * point from the line connecting the end points, of the quadratic curve
     * specified by the indicated control points.
     *
     * @param {number} x1
     * the X coordinate of the start point
     * @param {number} y1
     * the Y coordinate of the start point
     * @param {number} ctrlx
     * the X coordinate of the control point
     * @param {number} ctrly
     * the Y coordinate of the control point
     * @param {number} x2
     * the X coordinate of the end point
     * @param {number} y2
     * the Y coordinate of the end point
     * @return {number} the square of the flatness of the quadratic curve defined by the
     * specified coordinates.
     * @since 1.2
     */
    QuadCurve2D.getFlatnessSq$double$double$double$double$double$double = function (x1, y1, ctrlx, ctrly, x2, y2) {
        return Line2D.ptSegDistSq(x1, y1, x2, y2, ctrlx, ctrly);
    };
    /**
     * Returns the square of the flatness, or maximum distance of a control
     * point from the line connecting the end points, of the quadratic curve
     * specified by the indicated control points.
     *
     * @param {number} x1
     * the X coordinate of the start point
     * @param {number} y1
     * the Y coordinate of the start point
     * @param {number} ctrlx
     * the X coordinate of the control point
     * @param {number} ctrly
     * the Y coordinate of the control point
     * @param {number} x2
     * the X coordinate of the end point
     * @param {number} y2
     * the Y coordinate of the end point
     * @return {number} the square of the flatness of the quadratic curve defined by the
     * specified coordinates.
     * @since 1.2
     */
    QuadCurve2D.getFlatnessSq = function (x1, y1, ctrlx, ctrly, x2, y2) {
        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
            return QuadCurve2D.getFlatnessSq$double$double$double$double$double$double(x1, y1, ctrlx, ctrly, x2, y2);
        }
        else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (typeof x1[0] === 'number'))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
            return QuadCurve2D.getFlatnessSq$double_A$int(x1, y1);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Returns the flatness, or maximum distance of a control point from the
     * line connecting the end points, of the quadratic curve specified by the
     * indicated control points.
     *
     * @param {number} x1
     * the X coordinate of the start point
     * @param {number} y1
     * the Y coordinate of the start point
     * @param {number} ctrlx
     * the X coordinate of the control point
     * @param {number} ctrly
     * the Y coordinate of the control point
     * @param {number} x2
     * the X coordinate of the end point
     * @param {number} y2
     * the Y coordinate of the end point
     * @return {number} the flatness of the quadratic curve defined by the specified
     * coordinates.
     * @since 1.2
     */
    QuadCurve2D.getFlatness$double$double$double$double$double$double = function (x1, y1, ctrlx, ctrly, x2, y2) {
        return Line2D.ptSegDist(x1, y1, x2, y2, ctrlx, ctrly);
    };
    /**
     * Returns the flatness, or maximum distance of a control point from the
     * line connecting the end points, of the quadratic curve specified by the
     * indicated control points.
     *
     * @param {number} x1
     * the X coordinate of the start point
     * @param {number} y1
     * the Y coordinate of the start point
     * @param {number} ctrlx
     * the X coordinate of the control point
     * @param {number} ctrly
     * the Y coordinate of the control point
     * @param {number} x2
     * the X coordinate of the end point
     * @param {number} y2
     * the Y coordinate of the end point
     * @return {number} the flatness of the quadratic curve defined by the specified
     * coordinates.
     * @since 1.2
     */
    QuadCurve2D.getFlatness = function (x1, y1, ctrlx, ctrly, x2, y2) {
        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
            return QuadCurve2D.getFlatness$double$double$double$double$double$double(x1, y1, ctrlx, ctrly, x2, y2);
        }
        else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (typeof x1[0] === 'number'))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
            return QuadCurve2D.getFlatness$double_A$int(x1, y1);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Returns the square of the flatness, or maximum distance of a control
     * point from the line connecting the end points, of the quadratic curve
     * specified by the control points stored in the indicated array at the
     * indicated index.
     *
     * @param {Array} coords
     * an array containing coordinate values
     * @param {number} offset
     * the index into <code>coords</code> from which to to start
     * getting the values from the array
     * @return {number} the flatness of the quadratic curve that is defined by the values
     * in the specified array at the specified index.
     * @since 1.2
     */
    QuadCurve2D.getFlatnessSq$double_A$int = function (coords, offset) {
        return Line2D.ptSegDistSq(coords[offset + 0], coords[offset + 1], coords[offset + 4], coords[offset + 5], coords[offset + 2], coords[offset + 3]);
    };
    /**
     * Returns the flatness, or maximum distance of a control point from the
     * line connecting the end points, of the quadratic curve specified by the
     * control points stored in the indicated array at the indicated index.
     *
     * @param {Array} coords
     * an array containing coordinate values
     * @param {number} offset
     * the index into <code>coords</code> from which to start getting
     * the coordinate values
     * @return {number} the flatness of a quadratic curve defined by the specified array
     * at the specified offset.
     * @since 1.2
     */
    QuadCurve2D.getFlatness$double_A$int = function (coords, offset) {
        return Line2D.ptSegDist(coords[offset + 0], coords[offset + 1], coords[offset + 4], coords[offset + 5], coords[offset + 2], coords[offset + 3]);
    };
    /**
     * Returns the square of the flatness, or maximum distance of a control
     * point from the line connecting the end points, of this
     * <code>QuadCurve2D</code>.
     *
     * @return {number} the square of the flatness of this <code>QuadCurve2D</code>.
     * @since 1.2
     */
    QuadCurve2D.prototype.getFlatnessSq = function () {
        return Line2D.ptSegDistSq(this.getX1(), this.getY1(), this.getX2(), this.getY2(), this.getCtrlX(), this.getCtrlY());
    };
    /**
     * Returns the flatness, or maximum distance of a control point from the
     * line connecting the end points, of this <code>QuadCurve2D</code>.
     *
     * @return {number} the flatness of this <code>QuadCurve2D</code>.
     * @since 1.2
     */
    QuadCurve2D.prototype.getFlatness = function () {
        return Line2D.ptSegDist(this.getX1(), this.getY1(), this.getX2(), this.getY2(), this.getCtrlX(), this.getCtrlY());
    };
    /**
     * Subdivides this <code>QuadCurve2D</code> and stores the resulting two
     * subdivided curves into the <code>left</code> and <code>right</code> curve
     * parameters. Either or both of the <code>left</code> and
     * <code>right</code> objects can be the same as this
     * <code>QuadCurve2D</code> or <code>null</code>.
     *
     * @param {QuadCurve2D} left
     * the <code>QuadCurve2D</code> object for storing the left or
     * first half of the subdivided curve
     * @param {QuadCurve2D} right
     * the <code>QuadCurve2D</code> object for storing the right or
     * second half of the subdivided curve
     * @since 1.2
     */
    QuadCurve2D.prototype.subdivide = function (left, right) {
        QuadCurve2D.subdivide$java_awt_geom_QuadCurve2D$java_awt_geom_QuadCurve2D$java_awt_geom_QuadCurve2D(this, left, right);
    };
    /**
     * Subdivides the quadratic curve specified by the <code>src</code>
     * parameter and stores the resulting two subdivided curves into the
     * <code>left</code> and <code>right</code> curve parameters. Either or both
     * of the <code>left</code> and <code>right</code> objects can be the same
     * as the <code>src</code> object or <code>null</code>.
     *
     * @param {QuadCurve2D} src
     * the quadratic curve to be subdivided
     * @param {QuadCurve2D} left
     * the <code>QuadCurve2D</code> object for storing the left or
     * first half of the subdivided curve
     * @param {QuadCurve2D} right
     * the <code>QuadCurve2D</code> object for storing the right or
     * second half of the subdivided curve
     * @since 1.2
     */
    QuadCurve2D.subdivide$java_awt_geom_QuadCurve2D$java_awt_geom_QuadCurve2D$java_awt_geom_QuadCurve2D = function (src, left, right) {
        var x1 = src.getX1();
        var y1 = src.getY1();
        var ctrlx = src.getCtrlX();
        var ctrly = src.getCtrlY();
        var x2 = src.getX2();
        var y2 = src.getY2();
        var ctrlx1 = (x1 + ctrlx) / 2.0;
        var ctrly1 = (y1 + ctrly) / 2.0;
        var ctrlx2 = (x2 + ctrlx) / 2.0;
        var ctrly2 = (y2 + ctrly) / 2.0;
        ctrlx = (ctrlx1 + ctrlx2) / 2.0;
        ctrly = (ctrly1 + ctrly2) / 2.0;
        if (left != null) {
            left.setCurve$double$double$double$double$double$double(x1, y1, ctrlx1, ctrly1, ctrlx, ctrly);
        }
        if (right != null) {
            right.setCurve$double$double$double$double$double$double(ctrlx, ctrly, ctrlx2, ctrly2, x2, y2);
        }
    };
    /**
     * Subdivides the quadratic curve specified by the coordinates stored in the
     * <code>src</code> array at indices <code>srcoff</code> through
     * <code>srcoff</code>&nbsp;+&nbsp;5 and stores the resulting two subdivided
     * curves into the two result arrays at the corresponding indices. Either or
     * both of the <code>left</code> and <code>right</code> arrays can be
     * <code>null</code> or a reference to the same array and offset as the
     * <code>src</code> array. Note that the last point in the first subdivided
     * curve is the same as the first point in the second subdivided curve.
     * Thus, it is possible to pass the same array for <code>left</code> and
     * <code>right</code> and to use offsets such that <code>rightoff</code>
     * equals <code>leftoff</code> + 4 in order to avoid allocating extra
     * storage for this common point.
     *
     * @param {Array} src
     * the array holding the coordinates for the source curve
     * @param {number} srcoff
     * the offset into the array of the beginning of the the 6 source
     * coordinates
     * @param {Array} left
     * the array for storing the coordinates for the first half of
     * the subdivided curve
     * @param {number} leftoff
     * the offset into the array of the beginning of the the 6 left
     * coordinates
     * @param {Array} right
     * the array for storing the coordinates for the second half of
     * the subdivided curve
     * @param {number} rightoff
     * the offset into the array of the beginning of the the 6 right
     * coordinates
     * @since 1.2
     */
    QuadCurve2D.subdivide$double_A$int$double_A$int$double_A$int = function (src, srcoff, left, leftoff, right, rightoff) {
        var x1 = src[srcoff + 0];
        var y1 = src[srcoff + 1];
        var ctrlx = src[srcoff + 2];
        var ctrly = src[srcoff + 3];
        var x2 = src[srcoff + 4];
        var y2 = src[srcoff + 5];
        if (left != null) {
            left[leftoff + 0] = x1;
            left[leftoff + 1] = y1;
        }
        if (right != null) {
            right[rightoff + 4] = x2;
            right[rightoff + 5] = y2;
        }
        x1 = (x1 + ctrlx) / 2.0;
        y1 = (y1 + ctrly) / 2.0;
        x2 = (x2 + ctrlx) / 2.0;
        y2 = (y2 + ctrly) / 2.0;
        ctrlx = (x1 + x2) / 2.0;
        ctrly = (y1 + y2) / 2.0;
        if (left != null) {
            left[leftoff + 2] = x1;
            left[leftoff + 3] = y1;
            left[leftoff + 4] = ctrlx;
            left[leftoff + 5] = ctrly;
        }
        if (right != null) {
            right[rightoff + 0] = ctrlx;
            right[rightoff + 1] = ctrly;
            right[rightoff + 2] = x2;
            right[rightoff + 3] = y2;
        }
    };
    /**
     * Subdivides the quadratic curve specified by the coordinates stored in the
     * <code>src</code> array at indices <code>srcoff</code> through
     * <code>srcoff</code>&nbsp;+&nbsp;5 and stores the resulting two subdivided
     * curves into the two result arrays at the corresponding indices. Either or
     * both of the <code>left</code> and <code>right</code> arrays can be
     * <code>null</code> or a reference to the same array and offset as the
     * <code>src</code> array. Note that the last point in the first subdivided
     * curve is the same as the first point in the second subdivided curve.
     * Thus, it is possible to pass the same array for <code>left</code> and
     * <code>right</code> and to use offsets such that <code>rightoff</code>
     * equals <code>leftoff</code> + 4 in order to avoid allocating extra
     * storage for this common point.
     *
     * @param {Array} src
     * the array holding the coordinates for the source curve
     * @param {number} srcoff
     * the offset into the array of the beginning of the the 6 source
     * coordinates
     * @param {Array} left
     * the array for storing the coordinates for the first half of
     * the subdivided curve
     * @param {number} leftoff
     * the offset into the array of the beginning of the the 6 left
     * coordinates
     * @param {Array} right
     * the array for storing the coordinates for the second half of
     * the subdivided curve
     * @param {number} rightoff
     * the offset into the array of the beginning of the the 6 right
     * coordinates
     * @since 1.2
     */
    QuadCurve2D.subdivide = function (src, srcoff, left, leftoff, right, rightoff) {
        if (((src != null && src instanceof Array && (src.length == 0 || src[0] == null || (typeof src[0] === 'number'))) || src === null) && ((typeof srcoff === 'number') || srcoff === null) && ((left != null && left instanceof Array && (left.length == 0 || left[0] == null || (typeof left[0] === 'number'))) || left === null) && ((typeof leftoff === 'number') || leftoff === null) && ((right != null && right instanceof Array && (right.length == 0 || right[0] == null || (typeof right[0] === 'number'))) || right === null) && ((typeof rightoff === 'number') || rightoff === null)) {
            return QuadCurve2D.subdivide$double_A$int$double_A$int$double_A$int(src, srcoff, left, leftoff, right, rightoff);
        }
        else if (((src != null && src instanceof QuadCurve2D) || src === null) && ((srcoff != null && srcoff instanceof QuadCurve2D) || srcoff === null) && ((left != null && left instanceof QuadCurve2D) || left === null) && leftoff === undefined && right === undefined && rightoff === undefined) {
            return QuadCurve2D.subdivide$java_awt_geom_QuadCurve2D$java_awt_geom_QuadCurve2D$java_awt_geom_QuadCurve2D(src, srcoff, left);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Solves the quadratic whose coefficients are in the <code>eqn</code> array
     * and places the non-complex roots back into the same array, returning the
     * number of roots. The quadratic solved is represented by the equation:
     *
     * <pre>
     * eqn = {C, B, A};
     * ax^2 + bx + c = 0
     * </pre>
     *
     * A return value of <code>-1</code> is used to distinguish a constant
     * equation, which might be always 0 or never 0, from an equation that has
     * no zeroes.
     *
     * @param {Array} eqn
     * the array that contains the quadratic coefficients
     * @return {number} the number of roots, or <code>-1</code> if the equation is a
     * constant
     * @since 1.2
     */
    QuadCurve2D.solveQuadratic$double_A = function (eqn) {
        return QuadCurve2D.solveQuadratic$double_A$double_A(eqn, eqn);
    };
    /**
     * Solves the quadratic whose coefficients are in the <code>eqn</code> array
     * and places the non-complex roots into the <code>res</code> array,
     * returning the number of roots. The quadratic solved is represented by the
     * equation:
     *
     * <pre>
     * eqn = {C, B, A};
     * ax^2 + bx + c = 0
     * </pre>
     *
     * A return value of <code>-1</code> is used to distinguish a constant
     * equation, which might be always 0 or never 0, from an equation that has
     * no zeroes.
     *
     * @param {Array} eqn
     * the specified array of coefficients to use to solve the
     * quadratic equation
     * @param {Array} res
     * the array that contains the non-complex roots resulting from
     * the solution of the quadratic equation
     * @return {number} the number of roots, or <code>-1</code> if the equation is a
     * constant.
     * @since 1.3
     */
    QuadCurve2D.solveQuadratic$double_A$double_A = function (eqn, res) {
        var a = eqn[2];
        var b = eqn[1];
        var c = eqn[0];
        var roots = 0;
        if (a === 0.0) {
            if (b === 0.0) {
                return -1;
            }
            res[roots++] = -c / b;
        }
        else {
            var d = b * b - 4.0 * a * c;
            if (d < 0.0) {
                return 0;
            }
            d = Math.sqrt(d);
            if (b < 0.0) {
                d = -d;
            }
            var q = (b + d) / -2.0;
            res[roots++] = q / a;
            if (q !== 0.0) {
                res[roots++] = c / q;
            }
        }
        return roots;
    };
    /**
     * Solves the quadratic whose coefficients are in the <code>eqn</code> array
     * and places the non-complex roots into the <code>res</code> array,
     * returning the number of roots. The quadratic solved is represented by the
     * equation:
     *
     * <pre>
     * eqn = {C, B, A};
     * ax^2 + bx + c = 0
     * </pre>
     *
     * A return value of <code>-1</code> is used to distinguish a constant
     * equation, which might be always 0 or never 0, from an equation that has
     * no zeroes.
     *
     * @param {Array} eqn
     * the specified array of coefficients to use to solve the
     * quadratic equation
     * @param {Array} res
     * the array that contains the non-complex roots resulting from
     * the solution of the quadratic equation
     * @return {number} the number of roots, or <code>-1</code> if the equation is a
     * constant.
     * @since 1.3
     */
    QuadCurve2D.solveQuadratic = function (eqn, res) {
        if (((eqn != null && eqn instanceof Array && (eqn.length == 0 || eqn[0] == null || (typeof eqn[0] === 'number'))) || eqn === null) && ((res != null && res instanceof Array && (res.length == 0 || res[0] == null || (typeof res[0] === 'number'))) || res === null)) {
            return QuadCurve2D.solveQuadratic$double_A$double_A(eqn, res);
        }
        else if (((eqn != null && eqn instanceof Array && (eqn.length == 0 || eqn[0] == null || (typeof eqn[0] === 'number'))) || eqn === null) && res === undefined) {
            return QuadCurve2D.solveQuadratic$double_A(eqn);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @return {boolean}
     */
    QuadCurve2D.prototype.contains$double$double = function (x, y) {
        var x1 = this.getX1();
        var y1 = this.getY1();
        var xc = this.getCtrlX();
        var yc = this.getCtrlY();
        var x2 = this.getX2();
        var y2 = this.getY2();
        var kx = x1 - 2 * xc + x2;
        var ky = y1 - 2 * yc + y2;
        var dx = x - x1;
        var dy = y - y1;
        var dxl = x2 - x1;
        var dyl = y2 - y1;
        var t0 = (dx * ky - dy * kx) / (dxl * ky - dyl * kx);
        if (t0 < 0 || t0 > 1 || t0 !== t0) {
            return false;
        }
        var xb = kx * t0 * t0 + 2 * (xc - x1) * t0 + x1;
        var yb = ky * t0 * t0 + 2 * (yc - y1) * t0 + y1;
        var xl = dxl * t0 + x1;
        var yl = dyl * t0 + y1;
        return (x >= xb && x < xl) || (x >= xl && x < xb) || (y >= yb && y < yl) || (y >= yl && y < yb);
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {Point2D} p
     * @return {boolean}
     */
    QuadCurve2D.prototype.contains$java_awt_geom_Point2D = function (p) {
        return this.contains$double$double(p.getX(), p.getY());
    };
    /**
     * Fill an array with the coefficients of the parametric equation in t,
     * ready for solving against val with solveQuadratic. We currently have: val
     * = Py(t) = C1*(1-t)^2 + 2*CP*t*(1-t) + C2*t^2 = C1 - 2*C1*t + C1*t^2 +
     * 2*CP*t - 2*CP*t^2 + C2*t^2 = C1 + (2*CP - 2*C1)*t + (C1 - 2*CP + C2)*t^2
     * 0 = (C1 - val) + (2*CP - 2*C1)*t + (C1 - 2*CP + C2)*t^2 0 = C + Bt + At^2
     * C = C1 - val B = 2*CP - 2*C1 A = C1 - 2*CP + C2
     * @param {Array} eqn
     * @param {number} val
     * @param {number} c1
     * @param {number} cp
     * @param {number} c2
     * @private
     */
    QuadCurve2D.fillEqn = function (eqn, val, c1, cp, c2) {
        eqn[0] = c1 - val;
        eqn[1] = cp + cp - c1 - c1;
        eqn[2] = c1 - cp - cp + c2;
        return;
    };
    /**
     * Evaluate the t values in the first num slots of the vals[] array and
     * place the evaluated values back into the same array. Only evaluate t
     * values that are within the range &lt;0, 1&gt;, including the 0 and 1 ends
     * of the range iff the include0 or include1 booleans are true. If an
     * "inflection" equation is handed in, then any points which represent a
     * point of inflection for that quadratic equation are also ignored.
     * @param {Array} vals
     * @param {number} num
     * @param {boolean} include0
     * @param {boolean} include1
     * @param {Array} inflect
     * @param {number} c1
     * @param {number} ctrl
     * @param {number} c2
     * @return {number}
     * @private
     */
    QuadCurve2D.evalQuadratic = function (vals, num, include0, include1, inflect, c1, ctrl, c2) {
        var j = 0;
        for (var i = 0; i < num; i++) {
            var t = vals[i];
            if ((include0 ? t >= 0 : t > 0) && (include1 ? t <= 1 : t < 1) && (inflect == null || inflect[1] + 2 * inflect[2] * t !== 0)) {
                var u = 1 - t;
                vals[j++] = c1 * u * u + 2 * ctrl * t * u + c2 * t * t;
            }
        }
        return j;
    };
    /**
     * Determine where coord lies with respect to the range from low to high. It
     * is assumed that low &lt;= high. The return value is one of the 5 values
     * BELOW, LOWEDGE, INSIDE, HIGHEDGE, or ABOVE.
     * @param {number} coord
     * @param {number} low
     * @param {number} high
     * @return {number}
     * @private
     */
    QuadCurve2D.getTag = function (coord, low, high) {
        if (coord <= low) {
            return (coord < low ? QuadCurve2D.BELOW : QuadCurve2D.LOWEDGE);
        }
        if (coord >= high) {
            return (coord > high ? QuadCurve2D.ABOVE : QuadCurve2D.HIGHEDGE);
        }
        return QuadCurve2D.INSIDE;
    };
    /**
     * Determine if the pttag represents a coordinate that is already in its
     * test range, or is on the border with either of the two opttags
     * representing another coordinate that is "towards the inside" of that test
     * range. In other words, are either of the two "opt" points
     * "drawing the pt inward"?
     * @param {number} pttag
     * @param {number} opt1tag
     * @param {number} opt2tag
     * @return {boolean}
     * @private
     */
    QuadCurve2D.inwards = function (pttag, opt1tag, opt2tag) {
        switch ((pttag)) {
            case QuadCurve2D.BELOW:
            case QuadCurve2D.ABOVE:
            default:
                return false;
            case QuadCurve2D.LOWEDGE:
                return (opt1tag >= QuadCurve2D.INSIDE || opt2tag >= QuadCurve2D.INSIDE);
            case QuadCurve2D.INSIDE:
                return true;
            case QuadCurve2D.HIGHEDGE:
                return (opt1tag <= QuadCurve2D.INSIDE || opt2tag <= QuadCurve2D.INSIDE);
        }
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @return {boolean}
     */
    QuadCurve2D.prototype.intersects$double$double$double$double = function (x, y, w, h) {
        if (w <= 0 || h <= 0) {
            return false;
        }
        var x1 = this.getX1();
        var y1 = this.getY1();
        var x1tag = QuadCurve2D.getTag(x1, x, x + w);
        var y1tag = QuadCurve2D.getTag(y1, y, y + h);
        if (x1tag === QuadCurve2D.INSIDE && y1tag === QuadCurve2D.INSIDE) {
            return true;
        }
        var x2 = this.getX2();
        var y2 = this.getY2();
        var x2tag = QuadCurve2D.getTag(x2, x, x + w);
        var y2tag = QuadCurve2D.getTag(y2, y, y + h);
        if (x2tag === QuadCurve2D.INSIDE && y2tag === QuadCurve2D.INSIDE) {
            return true;
        }
        var ctrlx = this.getCtrlX();
        var ctrly = this.getCtrlY();
        var ctrlxtag = QuadCurve2D.getTag(ctrlx, x, x + w);
        var ctrlytag = QuadCurve2D.getTag(ctrly, y, y + h);
        if (x1tag < QuadCurve2D.INSIDE && x2tag < QuadCurve2D.INSIDE && ctrlxtag < QuadCurve2D.INSIDE) {
            return false;
        }
        if (y1tag < QuadCurve2D.INSIDE && y2tag < QuadCurve2D.INSIDE && ctrlytag < QuadCurve2D.INSIDE) {
            return false;
        }
        if (x1tag > QuadCurve2D.INSIDE && x2tag > QuadCurve2D.INSIDE && ctrlxtag > QuadCurve2D.INSIDE) {
            return false;
        }
        if (y1tag > QuadCurve2D.INSIDE && y2tag > QuadCurve2D.INSIDE && ctrlytag > QuadCurve2D.INSIDE) {
            return false;
        }
        if (QuadCurve2D.inwards(x1tag, x2tag, ctrlxtag) && QuadCurve2D.inwards(y1tag, y2tag, ctrlytag)) {
            return true;
        }
        if (QuadCurve2D.inwards(x2tag, x1tag, ctrlxtag) && QuadCurve2D.inwards(y2tag, y1tag, ctrlytag)) {
            return true;
        }
        var xoverlap = (x1tag * x2tag <= 0);
        var yoverlap = (y1tag * y2tag <= 0);
        if (x1tag === QuadCurve2D.INSIDE && x2tag === QuadCurve2D.INSIDE && yoverlap) {
            return true;
        }
        if (y1tag === QuadCurve2D.INSIDE && y2tag === QuadCurve2D.INSIDE && xoverlap) {
            return true;
        }
        var eqn = [0, 0, 0];
        var res = [0, 0, 0];
        if (!yoverlap) {
            QuadCurve2D.fillEqn(eqn, (y1tag < QuadCurve2D.INSIDE ? y : y + h), y1, ctrly, y2);
            return (QuadCurve2D.solveQuadratic$double_A$double_A(eqn, res) === 2 && QuadCurve2D.evalQuadratic(res, 2, true, true, null, x1, ctrlx, x2) === 2 && QuadCurve2D.getTag(res[0], x, x + w) * QuadCurve2D.getTag(res[1], x, x + w) <= 0);
        }
        if (!xoverlap) {
            QuadCurve2D.fillEqn(eqn, (x1tag < QuadCurve2D.INSIDE ? x : x + w), x1, ctrlx, x2);
            return (QuadCurve2D.solveQuadratic$double_A$double_A(eqn, res) === 2 && QuadCurve2D.evalQuadratic(res, 2, true, true, null, y1, ctrly, y2) === 2 && QuadCurve2D.getTag(res[0], y, y + h) * QuadCurve2D.getTag(res[1], y, y + h) <= 0);
        }
        var dx = x2 - x1;
        var dy = y2 - y1;
        var k = y2 * x1 - x2 * y1;
        var c1tag;
        var c2tag;
        if (y1tag === QuadCurve2D.INSIDE) {
            c1tag = x1tag;
        }
        else {
            c1tag = QuadCurve2D.getTag((k + dx * (y1tag < QuadCurve2D.INSIDE ? y : y + h)) / dy, x, x + w);
        }
        if (y2tag === QuadCurve2D.INSIDE) {
            c2tag = x2tag;
        }
        else {
            c2tag = QuadCurve2D.getTag((k + dx * (y2tag < QuadCurve2D.INSIDE ? y : y + h)) / dy, x, x + w);
        }
        if (c1tag * c2tag <= 0) {
            return true;
        }
        c1tag = ((c1tag * x1tag <= 0) ? y1tag : y2tag);
        QuadCurve2D.fillEqn(eqn, (c2tag < QuadCurve2D.INSIDE ? x : x + w), x1, ctrlx, x2);
        var num = QuadCurve2D.solveQuadratic$double_A$double_A(eqn, res);
        QuadCurve2D.evalQuadratic(res, num, true, true, null, y1, ctrly, y2);
        c2tag = QuadCurve2D.getTag(res[0], y, y + h);
        return (c1tag * c2tag <= 0);
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @return {boolean}
     */
    QuadCurve2D.prototype.intersects = function (x, y, w, h) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
            return this.intersects$double$double$double$double(x, y, w, h);
        }
        else if (((x != null && x instanceof Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
            return this.intersects$java_awt_geom_Rectangle2D(x);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {Rectangle2D} r
     * @return {boolean}
     */
    QuadCurve2D.prototype.intersects$java_awt_geom_Rectangle2D = function (r) {
        return this.intersects$double$double$double$double(r.getX(), r.getY(), r.getWidth(), r.getHeight());
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @return {boolean}
     */
    QuadCurve2D.prototype.contains$double$double$double$double = function (x, y, w, h) {
        if (w <= 0 || h <= 0) {
            return false;
        }
        return (this.contains$double$double(x, y) && this.contains$double$double(x + w, y) && this.contains$double$double(x + w, y + h) && this.contains$double$double(x, y + h));
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @return {boolean}
     */
    QuadCurve2D.prototype.contains = function (x, y, w, h) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
            return this.contains$double$double$double$double(x, y, w, h);
        }
        else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined) {
            return this.contains$double$double(x, y);
        }
        else if (((x != null && x instanceof Point2D) || x === null) && y === undefined && w === undefined && h === undefined) {
            return this.contains$java_awt_geom_Point2D(x);
        }
        else if (((x != null && x instanceof Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
            return this.contains$java_awt_geom_Rectangle2D(x);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {Rectangle2D} r
     * @return {boolean}
     */
    QuadCurve2D.prototype.contains$java_awt_geom_Rectangle2D = function (r) {
        return this.contains$double$double$double$double(r.getX(), r.getY(), r.getWidth(), r.getHeight());
    };
    /**
     * Returns an iteration object that defines the boundary of the shape of
     * this <code>QuadCurve2D</code>. The iterator for this class is not
     * multi-threaded safe, which means that this <code>QuadCurve2D</code> class
     * does not guarantee that modifications to the geometry of this
     * <code>QuadCurve2D</code> object do not affect any iterations of that
     * geometry that are already in process.
     *
     * @param {AffineTransform} at
     * an optional {@link AffineTransform} to apply to the shape
     * boundary
     * @return {PathIterator} a {@link PathIterator} object that defines the boundary of the
     * shape.
     * @since 1.2
     */
    QuadCurve2D.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
        return new QuadIterator(this, at);
    };
    /**
     * Returns an iteration object that defines the boundary of the flattened
     * shape of this <code>QuadCurve2D</code>. The iterator for this class is
     * not multi-threaded safe, which means that this <code>QuadCurve2D</code>
     * class does not guarantee that modifications to the geometry of this
     * <code>QuadCurve2D</code> object do not affect any iterations of that
     * geometry that are already in process.
     *
     * @param {AffineTransform} at
     * an optional <code>AffineTransform</code> to apply to the
     * boundary of the shape
     * @param {number} flatness
     * the maximum distance that the control points for a subdivided
     * curve can be with respect to a line connecting the end points
     * of this curve before this curve is replaced by a straight line
     * connecting the end points.
     * @return {PathIterator} a <code>PathIterator</code> object that defines the flattened
     * boundary of the shape.
     * @since 1.2
     */
    QuadCurve2D.prototype.getPathIterator$java_awt_geom_AffineTransform$double = function (at, flatness) {
        return new FlatteningPathIterator(this.getPathIterator$java_awt_geom_AffineTransform(at), flatness);
    };
    /**
     * Returns an iteration object that defines the boundary of the flattened
     * shape of this <code>QuadCurve2D</code>. The iterator for this class is
     * not multi-threaded safe, which means that this <code>QuadCurve2D</code>
     * class does not guarantee that modifications to the geometry of this
     * <code>QuadCurve2D</code> object do not affect any iterations of that
     * geometry that are already in process.
     *
     * @param {AffineTransform} at
     * an optional <code>AffineTransform</code> to apply to the
     * boundary of the shape
     * @param {number} flatness
     * the maximum distance that the control points for a subdivided
     * curve can be with respect to a line connecting the end points
     * of this curve before this curve is replaced by a straight line
     * connecting the end points.
     * @return {PathIterator} a <code>PathIterator</code> object that defines the flattened
     * boundary of the shape.
     * @since 1.2
     */
    QuadCurve2D.prototype.getPathIterator = function (at, flatness) {
        if (((at != null && at instanceof AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
            return this.getPathIterator$java_awt_geom_AffineTransform$double(at, flatness);
        }
        else if (((at != null && at instanceof AffineTransform) || at === null) && flatness === undefined) {
            return this.getPathIterator$java_awt_geom_AffineTransform(at);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Creates a new object of the same class and with the same contents as this
     * object.
     *
     * @return {*} a clone of this instance.
     * @exception OutOfMemoryError
     * if there is not enough memory.
     * @see java.lang.Cloneable
     * @since 1.2
     */
    QuadCurve2D.prototype.clone = function () {
        try {
            return (function (o) { var clone = Object.create(o); for (var p in o) {
                if (o.hasOwnProperty(p))
                    clone[p] = o[p];
            } return clone; })(this);
        }
        catch (e) {
            throw Object.defineProperty(new Error(e.message), '__class', { configurable: true, value: 'java.lang.InternalError' });
        }
        ;
    };
    return QuadCurve2D;
}());
QuadCurve2D.BELOW = -2;
QuadCurve2D.LOWEDGE = -1;
QuadCurve2D.INSIDE = 0;
QuadCurve2D.HIGHEDGE = 1;
QuadCurve2D.ABOVE = 2;
QuadCurve2D["__class"] = "QuadCurve2D";
QuadCurve2D["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable"];
(function (QuadCurve2D) {
    /**
     * Constructs and initializes a <code>QuadCurve2D</code> from the
     * specified {@code float} coordinates.
     *
     * @param {number} x1
     * the X coordinate of the start point
     * @param {number} y1
     * the Y coordinate of the start point
     * @param {number} ctrlx
     * the X coordinate of the control point
     * @param {number} ctrly
     * the Y coordinate of the control point
     * @param {number} x2
     * the X coordinate of the end point
     * @param {number} y2
     * the Y coordinate of the end point
     * @since 1.2
     * @class
     */
    var Float = (function (_super) {
        __extends(Float, _super);
        function Float(x1, y1, ctrlx, ctrly, x2, y2) {
            var _this = this;
            if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this) || this;
                _this.x1 = 0;
                _this.y1 = 0;
                _this.ctrlx = 0;
                _this.ctrly = 0;
                _this.x2 = 0;
                _this.y2 = 0;
                _this.x1 = 0;
                _this.y1 = 0;
                _this.ctrlx = 0;
                _this.ctrly = 0;
                _this.x2 = 0;
                _this.y2 = 0;
                (function () {
                    _this.setCurve$double$double$double$double$double$double(x1, y1, ctrlx, ctrly, x2, y2);
                })();
            }
            else if (x1 === undefined && y1 === undefined && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this) || this;
                _this.x1 = 0;
                _this.y1 = 0;
                _this.ctrlx = 0;
                _this.ctrly = 0;
                _this.x2 = 0;
                _this.y2 = 0;
                _this.x1 = 0;
                _this.y1 = 0;
                _this.ctrlx = 0;
                _this.ctrly = 0;
                _this.x2 = 0;
                _this.y2 = 0;
            }
            else
                throw new Error('invalid overload');
            return _this;
        }
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getX1 = function () {
            return this.x1;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getY1 = function () {
            return this.y1;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {Point2D}
         */
        Float.prototype.getP1 = function () {
            return new Point2D.Float(this.x1, this.y1);
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getCtrlX = function () {
            return this.ctrlx;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getCtrlY = function () {
            return this.ctrly;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {Point2D}
         */
        Float.prototype.getCtrlPt = function () {
            return new Point2D.Float(this.ctrlx, this.ctrly);
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getX2 = function () {
            return this.x2;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getY2 = function () {
            return this.y2;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {Point2D}
         */
        Float.prototype.getP2 = function () {
            return new Point2D.Float(this.x2, this.y2);
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @param {number} x1
         * @param {number} y1
         * @param {number} ctrlx
         * @param {number} ctrly
         * @param {number} x2
         * @param {number} y2
         */
        Float.prototype.setCurve$double$double$double$double$double$double = function (x1, y1, ctrlx, ctrly, x2, y2) {
            this.x1 = x1;
            this.y1 = y1;
            this.ctrlx = ctrlx;
            this.ctrly = ctrly;
            this.x2 = x2;
            this.y2 = y2;
        };
        /**
         * Sets the location of the end points and control point of this curve
         * to the specified {@code float} coordinates.
         *
         * @param {number} x1
         * the X coordinate of the start point
         * @param {number} y1
         * the Y coordinate of the start point
         * @param {number} ctrlx
         * the X coordinate of the control point
         * @param {number} ctrly
         * the Y coordinate of the control point
         * @param {number} x2
         * the X coordinate of the end point
         * @param {number} y2
         * the Y coordinate of the end point
         * @since 1.2
         */
        Float.prototype.setCurve$float$float$float$float$float$float = function (x1, y1, ctrlx, ctrly, x2, y2) {
            this.x1 = x1;
            this.y1 = y1;
            this.ctrlx = ctrlx;
            this.ctrly = ctrly;
            this.x2 = x2;
            this.y2 = y2;
        };
        /**
         * Sets the location of the end points and control point of this curve
         * to the specified {@code float} coordinates.
         *
         * @param {number} x1
         * the X coordinate of the start point
         * @param {number} y1
         * the Y coordinate of the start point
         * @param {number} ctrlx
         * the X coordinate of the control point
         * @param {number} ctrly
         * the Y coordinate of the control point
         * @param {number} x2
         * the X coordinate of the end point
         * @param {number} y2
         * the Y coordinate of the end point
         * @since 1.2
         */
        Float.prototype.setCurve = function (x1, y1, ctrlx, ctrly, x2, y2) {
            if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                return this.setCurve$float$float$float$float$float$float(x1, y1, ctrlx, ctrly, x2, y2);
            }
            else if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                return this.setCurve$double$double$double$double$double$double(x1, y1, ctrlx, ctrly, x2, y2);
            }
            else if (((x1 != null && x1 instanceof Point2D) || x1 === null) && ((y1 != null && y1 instanceof Point2D) || y1 === null) && ((ctrlx != null && ctrlx instanceof Point2D) || ctrlx === null) && ctrly === undefined && x2 === undefined && y2 === undefined) {
                return this.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1, ctrlx);
            }
            else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (typeof x1[0] === 'number'))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                return this.setCurve$double_A$int(x1, y1);
            }
            else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (x1[0] != null && x1[0] instanceof Point2D))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                return this.setCurve$java_awt_geom_Point2D_A$int(x1, y1);
            }
            else if (((x1 != null && x1 instanceof QuadCurve2D) || x1 === null) && y1 === undefined && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                return this.setCurve$java_awt_geom_QuadCurve2D(x1);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {Rectangle2D}
         */
        Float.prototype.getBounds2D = function () {
            var left = Math.min(Math.min(this.x1, this.x2), this.ctrlx);
            var top = Math.min(Math.min(this.y1, this.y2), this.ctrly);
            var right = Math.max(Math.max(this.x1, this.x2), this.ctrlx);
            var bottom = Math.max(Math.max(this.y1, this.y2), this.ctrly);
            return new Rectangle2D.Float(left, top, right - left, bottom - top);
        };
        return Float;
    }(QuadCurve2D));
    Float.serialVersionUID = -8511188402130719609;
    QuadCurve2D.Float = Float;
    Float["__class"] = "QuadCurve2D.Float";
    Float["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
    /**
     * Constructs and initializes a <code>QuadCurve2D</code> from the
     * specified {@code double} coordinates.
     *
     * @param {number} x1
     * the X coordinate of the start point
     * @param {number} y1
     * the Y coordinate of the start point
     * @param {number} ctrlx
     * the X coordinate of the control point
     * @param {number} ctrly
     * the Y coordinate of the control point
     * @param {number} x2
     * the X coordinate of the end point
     * @param {number} y2
     * the Y coordinate of the end point
     * @since 1.2
     * @class
     */
    var Double = (function (_super) {
        __extends(Double, _super);
        function Double(x1, y1, ctrlx, ctrly, x2, y2) {
            var _this = this;
            if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this) || this;
                _this.x1 = 0;
                _this.y1 = 0;
                _this.ctrlx = 0;
                _this.ctrly = 0;
                _this.x2 = 0;
                _this.y2 = 0;
                _this.x1 = 0;
                _this.y1 = 0;
                _this.ctrlx = 0;
                _this.ctrly = 0;
                _this.x2 = 0;
                _this.y2 = 0;
                (function () {
                    _this.setCurve$double$double$double$double$double$double(x1, y1, ctrlx, ctrly, x2, y2);
                })();
            }
            else if (x1 === undefined && y1 === undefined && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this) || this;
                _this.x1 = 0;
                _this.y1 = 0;
                _this.ctrlx = 0;
                _this.ctrly = 0;
                _this.x2 = 0;
                _this.y2 = 0;
                _this.x1 = 0;
                _this.y1 = 0;
                _this.ctrlx = 0;
                _this.ctrly = 0;
                _this.x2 = 0;
                _this.y2 = 0;
            }
            else
                throw new Error('invalid overload');
            return _this;
        }
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getX1 = function () {
            return this.x1;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getY1 = function () {
            return this.y1;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {Point2D}
         */
        Double.prototype.getP1 = function () {
            return new Point2D.Double(this.x1, this.y1);
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getCtrlX = function () {
            return this.ctrlx;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getCtrlY = function () {
            return this.ctrly;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {Point2D}
         */
        Double.prototype.getCtrlPt = function () {
            return new Point2D.Double(this.ctrlx, this.ctrly);
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getX2 = function () {
            return this.x2;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getY2 = function () {
            return this.y2;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {Point2D}
         */
        Double.prototype.getP2 = function () {
            return new Point2D.Double(this.x2, this.y2);
        };
        /**
         * Sets the location of the end points and control point of this curve
         * to the specified {@code float} coordinates.
         *
         * @param {number} x1
         * the X coordinate of the start point
         * @param {number} y1
         * the Y coordinate of the start point
         * @param {number} ctrlx
         * the X coordinate of the control point
         * @param {number} ctrly
         * the Y coordinate of the control point
         * @param {number} x2
         * the X coordinate of the end point
         * @param {number} y2
         * the Y coordinate of the end point
         * @since 1.2
         */
        Double.prototype.setCurve = function (x1, y1, ctrlx, ctrly, x2, y2) {
            if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                return this.setCurve$double$double$double$double$double$double(x1, y1, ctrlx, ctrly, x2, y2);
            }
            else if (((x1 != null && x1 instanceof Point2D) || x1 === null) && ((y1 != null && y1 instanceof Point2D) || y1 === null) && ((ctrlx != null && ctrlx instanceof Point2D) || ctrlx === null) && ctrly === undefined && x2 === undefined && y2 === undefined) {
                return this.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1, ctrlx);
            }
            else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (typeof x1[0] === 'number'))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                return this.setCurve$double_A$int(x1, y1);
            }
            else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (x1[0] != null && x1[0] instanceof Point2D))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                return this.setCurve$java_awt_geom_Point2D_A$int(x1, y1);
            }
            else if (((x1 != null && x1 instanceof QuadCurve2D) || x1 === null) && y1 === undefined && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                return this.setCurve$java_awt_geom_QuadCurve2D(x1);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @param {number} x1
         * @param {number} y1
         * @param {number} ctrlx
         * @param {number} ctrly
         * @param {number} x2
         * @param {number} y2
         */
        Double.prototype.setCurve$double$double$double$double$double$double = function (x1, y1, ctrlx, ctrly, x2, y2) {
            this.x1 = x1;
            this.y1 = y1;
            this.ctrlx = ctrlx;
            this.ctrly = ctrly;
            this.x2 = x2;
            this.y2 = y2;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {Rectangle2D}
         */
        Double.prototype.getBounds2D = function () {
            var left = Math.min(Math.min(this.x1, this.x2), this.ctrlx);
            var top = Math.min(Math.min(this.y1, this.y2), this.ctrly);
            var right = Math.max(Math.max(this.x1, this.x2), this.ctrlx);
            var bottom = Math.max(Math.max(this.y1, this.y2), this.ctrly);
            return new Rectangle2D.Double(left, top, right - left, bottom - top);
        };
        return Double;
    }(QuadCurve2D));
    Double.serialVersionUID = 4217149928428559721;
    QuadCurve2D.Double = Double;
    Double["__class"] = "QuadCurve2D.Double";
    Double["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
})(QuadCurve2D || (QuadCurve2D = {}));
/**
 * A utility class to iterate over the path segments of a quadratic curve
 * segment through the PathIterator interface.
 *
 * @author Jim Graham
 */
var QuadIterator = (function () {
    function QuadIterator(q, at) {
        this.quad = null;
        this.affine = null;
        this.index = 0;
        this.quad = q;
        this.affine = at;
    }
    /**
     * Return the winding rule for determining the insideness of the path.
     *
     * @see #WIND_EVEN_ODD
     * @see #WIND_NON_ZERO
     * @return {number}
     */
    QuadIterator.prototype.getWindingRule = function () {
        return PathIterator.WIND_NON_ZERO;
    };
    /**
     * Tests if there are more points to read.
     *
     * @return {boolean} true if there are more points to read
     */
    QuadIterator.prototype.isDone = function () {
        return (this.index > 1);
    };
    QuadIterator.prototype.next = function (doNext) {
        if (doNext === undefined) {
            return this.next$();
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Moves the iterator to the next segment of the path forwards along the
     * primary direction of traversal as long as there are more points in that
     * direction.
     */
    QuadIterator.prototype.next$ = function () {
        this.index++;
    };
    /**
     * Returns the coordinates and type of the current path segment in the
     * iteration. The return value is the path segment type: SEG_MOVETO,
     * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
     * length 6 must be passed in and may be used to store the coordinates of
     * the point(s). Each point is stored as a pair of float x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
     * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
     * not return any points.
     *
     * @see #SEG_MOVETO
     * @see #SEG_LINETO
     * @see #SEG_QUADTO
     * @see #SEG_CUBICTO
     * @see #SEG_CLOSE
     * @param {Array} coords
     * @return {number}
     */
    QuadIterator.prototype.currentSegment$float_A = function (coords) {
        if (this.isDone()) {
            throw Object.defineProperty(new Error("quad iterator iterator out of bounds"), '__class', { configurable: true, value: 'java.util.NoSuchElementException' });
        }
        var type;
        if (this.index === 0) {
            coords[0] = this.quad.getX1();
            coords[1] = this.quad.getY1();
            type = PathIterator.SEG_MOVETO;
        }
        else {
            coords[0] = this.quad.getCtrlX();
            coords[1] = this.quad.getCtrlY();
            coords[2] = this.quad.getX2();
            coords[3] = this.quad.getY2();
            type = PathIterator.SEG_QUADTO;
        }
        if (this.affine != null) {
            this.affine.transform$float_A$int$float_A$int$int(coords, 0, coords, 0, this.index === 0 ? 1 : 2);
        }
        return type;
    };
    /**
     * Returns the coordinates and type of the current path segment in the
     * iteration. The return value is the path segment type: SEG_MOVETO,
     * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
     * length 6 must be passed in and may be used to store the coordinates of
     * the point(s). Each point is stored as a pair of float x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
     * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
     * not return any points.
     *
     * @see #SEG_MOVETO
     * @see #SEG_LINETO
     * @see #SEG_QUADTO
     * @see #SEG_CUBICTO
     * @see #SEG_CLOSE
     * @param {Array} coords
     * @return {number}
     */
    QuadIterator.prototype.currentSegment = function (coords) {
        if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
            return this.currentSegment$float_A(coords);
        }
        else if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
            return this.currentSegment$double_A(coords);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Returns the coordinates and type of the current path segment in the
     * iteration. The return value is the path segment type: SEG_MOVETO,
     * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A double array of
     * length 6 must be passed in and may be used to store the coordinates of
     * the point(s). Each point is stored as a pair of double x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
     * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
     * not return any points.
     *
     * @see #SEG_MOVETO
     * @see #SEG_LINETO
     * @see #SEG_QUADTO
     * @see #SEG_CUBICTO
     * @see #SEG_CLOSE
     * @param {Array} coords
     * @return {number}
     */
    QuadIterator.prototype.currentSegment$double_A = function (coords) {
        if (this.isDone()) {
            throw Object.defineProperty(new Error("quad iterator iterator out of bounds"), '__class', { configurable: true, value: 'java.util.NoSuchElementException' });
        }
        var type;
        if (this.index === 0) {
            coords[0] = this.quad.getX1();
            coords[1] = this.quad.getY1();
            type = PathIterator.SEG_MOVETO;
        }
        else {
            coords[0] = this.quad.getCtrlX();
            coords[1] = this.quad.getCtrlY();
            coords[2] = this.quad.getX2();
            coords[3] = this.quad.getY2();
            type = PathIterator.SEG_QUADTO;
        }
        if (this.affine != null) {
            this.affine.transform$double_A$int$double_A$int$int(coords, 0, coords, 0, this.index === 0 ? 1 : 2);
        }
        return type;
    };
    return QuadIterator;
}());
QuadIterator["__class"] = "QuadIterator";
QuadIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
/**
 * This is an abstract class that cannot be instantiated directly.
 *
 * @see Arc2D
 * @see Ellipse2D
 * @see Rectangle2D
 * @see RoundRectangle2D
 * @since 1.2
 * @class
 */
var RectangularShape = (function () {
    function RectangularShape() {
    }
    /**
     * Returns the smallest X coordinate of the framing rectangle of the
     * <code>Shape</code> in <code>double</code> precision.
     *
     * @return {number} the smallest X coordinate of the framing rectangle of the
     * <code>Shape</code>.
     * @since 1.2
     */
    RectangularShape.prototype.getMinX = function () {
        return this.getX();
    };
    /**
     * Returns the smallest Y coordinate of the framing rectangle of the
     * <code>Shape</code> in <code>double</code> precision.
     *
     * @return {number} the smallest Y coordinate of the framing rectangle of the
     * <code>Shape</code>.
     * @since 1.2
     */
    RectangularShape.prototype.getMinY = function () {
        return this.getY();
    };
    /**
     * Returns the largest X coordinate of the framing rectangle of the
     * <code>Shape</code> in <code>double</code> precision.
     *
     * @return {number} the largest X coordinate of the framing rectangle of the
     * <code>Shape</code>.
     * @since 1.2
     */
    RectangularShape.prototype.getMaxX = function () {
        return this.getX() + this.getWidth();
    };
    /**
     * Returns the largest Y coordinate of the framing rectangle of the
     * <code>Shape</code> in <code>double</code> precision.
     *
     * @return {number} the largest Y coordinate of the framing rectangle of the
     * <code>Shape</code>.
     * @since 1.2
     */
    RectangularShape.prototype.getMaxY = function () {
        return this.getY() + this.getHeight();
    };
    /**
     * Returns the X coordinate of the center of the framing rectangle of the
     * <code>Shape</code> in <code>double</code> precision.
     *
     * @return {number} the X coordinate of the center of the framing rectangle of the
     * <code>Shape</code>.
     * @since 1.2
     */
    RectangularShape.prototype.getCenterX = function () {
        return this.getX() + this.getWidth() / 2.0;
    };
    /**
     * Returns the Y coordinate of the center of the framing rectangle of the
     * <code>Shape</code> in <code>double</code> precision.
     *
     * @return {number} the Y coordinate of the center of the framing rectangle of the
     * <code>Shape</code>.
     * @since 1.2
     */
    RectangularShape.prototype.getCenterY = function () {
        return this.getY() + this.getHeight() / 2.0;
    };
    /**
     * Returns the framing {@link Rectangle2D} that defines the overall shape of
     * this object.
     *
     * @return {Rectangle2D} a <code>Rectangle2D</code>, specified in <code>double</code>
     * coordinates.
     * @see #setFrame(double, double, double, double)
     * @see #setFrame(Point2D, Dimension2D)
     * @see #setFrame(Rectangle2D)
     * @since 1.2
     */
    RectangularShape.prototype.getFrame = function () {
        return new Rectangle2D.Double(this.getX(), this.getY(), this.getWidth(), this.getHeight());
    };
    RectangularShape.prototype.setFrame = function (x, y, w, h) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
            return this.setFrame$double$double$double$double(x, y, w, h);
        }
        else if (((x != null && x instanceof Point2D) || x === null) && ((y != null && y instanceof Dimension2D) || y === null) && w === undefined && h === undefined) {
            return this.setFrame$java_awt_geom_Point2D$java_awt_geom_Dimension2D(x, y);
        }
        else if (((x != null && x instanceof Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
            return this.setFrame$java_awt_geom_Rectangle2D(x);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Sets the location and size of the framing rectangle of this
     * <code>Shape</code> to the specified rectangular values.
     *
     * @param {number} x
     * the X coordinate of the upper-left corner of the specified
     * rectangular shape
     * @param {number} y
     * the Y coordinate of the upper-left corner of the specified
     * rectangular shape
     * @param {number} w
     * the width of the specified rectangular shape
     * @param {number} h
     * the height of the specified rectangular shape
     * @see #getFrame
     * @since 1.2
     */
    RectangularShape.prototype.setFrame$double$double$double$double = function (x, y, w, h) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
    /**
     * Sets the location and size of the framing rectangle of this
     * <code>Shape</code> to the specified {@link Point2D} and
     * {@link Dimension2D}, respectively. The framing rectangle is used by the
     * subclasses of <code>RectangularShape</code> to define their geometry.
     *
     * @param {Point2D} loc
     * the specified <code>Point2D</code>
     * @param {Dimension2D} size
     * the specified <code>Dimension2D</code>
     * @see #getFrame
     * @since 1.2
     */
    RectangularShape.prototype.setFrame$java_awt_geom_Point2D$java_awt_geom_Dimension2D = function (loc, size) {
        this.setFrame$double$double$double$double(loc.getX(), loc.getY(), size.getWidth(), size.getHeight());
    };
    /**
     * Sets the framing rectangle of this <code>Shape</code> to be the specified
     * <code>Rectangle2D</code>. The framing rectangle is used by the subclasses
     * of <code>RectangularShape</code> to define their geometry.
     *
     * @param {Rectangle2D} r
     * the specified <code>Rectangle2D</code>
     * @see #getFrame
     * @since 1.2
     */
    RectangularShape.prototype.setFrame$java_awt_geom_Rectangle2D = function (r) {
        this.setFrame$double$double$double$double(r.getX(), r.getY(), r.getWidth(), r.getHeight());
    };
    /**
     * Sets the diagonal of the framing rectangle of this <code>Shape</code>
     * based on the two specified coordinates. The framing rectangle is used by
     * the subclasses of <code>RectangularShape</code> to define their geometry.
     *
     * @param {number} x1
     * the X coordinate of the start point of the specified diagonal
     * @param {number} y1
     * the Y coordinate of the start point of the specified diagonal
     * @param {number} x2
     * the X coordinate of the end point of the specified diagonal
     * @param {number} y2
     * the Y coordinate of the end point of the specified diagonal
     * @since 1.2
     */
    RectangularShape.prototype.setFrameFromDiagonal$double$double$double$double = function (x1, y1, x2, y2) {
        if (x2 < x1) {
            var t = x1;
            x1 = x2;
            x2 = t;
        }
        if (y2 < y1) {
            var t = y1;
            y1 = y2;
            y2 = t;
        }
        this.setFrame$double$double$double$double(x1, y1, x2 - x1, y2 - y1);
    };
    /**
     * Sets the diagonal of the framing rectangle of this <code>Shape</code>
     * based on the two specified coordinates. The framing rectangle is used by
     * the subclasses of <code>RectangularShape</code> to define their geometry.
     *
     * @param {number} x1
     * the X coordinate of the start point of the specified diagonal
     * @param {number} y1
     * the Y coordinate of the start point of the specified diagonal
     * @param {number} x2
     * the X coordinate of the end point of the specified diagonal
     * @param {number} y2
     * the Y coordinate of the end point of the specified diagonal
     * @since 1.2
     */
    RectangularShape.prototype.setFrameFromDiagonal = function (x1, y1, x2, y2) {
        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
            return this.setFrameFromDiagonal$double$double$double$double(x1, y1, x2, y2);
        }
        else if (((x1 != null && x1 instanceof Point2D) || x1 === null) && ((y1 != null && y1 instanceof Point2D) || y1 === null) && x2 === undefined && y2 === undefined) {
            return this.setFrameFromDiagonal$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Sets the diagonal of the framing rectangle of this <code>Shape</code>
     * based on two specified <code>Point2D</code> objects. The framing
     * rectangle is used by the subclasses of <code>RectangularShape</code> to
     * define their geometry.
     *
     * @param {Point2D} p1
     * the start <code>Point2D</code> of the specified diagonal
     * @param {Point2D} p2
     * the end <code>Point2D</code> of the specified diagonal
     * @since 1.2
     */
    RectangularShape.prototype.setFrameFromDiagonal$java_awt_geom_Point2D$java_awt_geom_Point2D = function (p1, p2) {
        this.setFrameFromDiagonal$double$double$double$double(p1.getX(), p1.getY(), p2.getX(), p2.getY());
    };
    /**
     * Sets the framing rectangle of this <code>Shape</code> based on the
     * specified center point coordinates and corner point coordinates. The
     * framing rectangle is used by the subclasses of
     * <code>RectangularShape</code> to define their geometry.
     *
     * @param {number} centerX
     * the X coordinate of the specified center point
     * @param {number} centerY
     * the Y coordinate of the specified center point
     * @param {number} cornerX
     * the X coordinate of the specified corner point
     * @param {number} cornerY
     * the Y coordinate of the specified corner point
     * @since 1.2
     */
    RectangularShape.prototype.setFrameFromCenter$double$double$double$double = function (centerX, centerY, cornerX, cornerY) {
        var halfW = Math.abs(cornerX - centerX);
        var halfH = Math.abs(cornerY - centerY);
        this.setFrame$double$double$double$double(centerX - halfW, centerY - halfH, halfW * 2.0, halfH * 2.0);
    };
    /**
     * Sets the framing rectangle of this <code>Shape</code> based on the
     * specified center point coordinates and corner point coordinates. The
     * framing rectangle is used by the subclasses of
     * <code>RectangularShape</code> to define their geometry.
     *
     * @param {number} centerX
     * the X coordinate of the specified center point
     * @param {number} centerY
     * the Y coordinate of the specified center point
     * @param {number} cornerX
     * the X coordinate of the specified corner point
     * @param {number} cornerY
     * the Y coordinate of the specified corner point
     * @since 1.2
     */
    RectangularShape.prototype.setFrameFromCenter = function (centerX, centerY, cornerX, cornerY) {
        if (((typeof centerX === 'number') || centerX === null) && ((typeof centerY === 'number') || centerY === null) && ((typeof cornerX === 'number') || cornerX === null) && ((typeof cornerY === 'number') || cornerY === null)) {
            return this.setFrameFromCenter$double$double$double$double(centerX, centerY, cornerX, cornerY);
        }
        else if (((centerX != null && centerX instanceof Point2D) || centerX === null) && ((centerY != null && centerY instanceof Point2D) || centerY === null) && cornerX === undefined && cornerY === undefined) {
            return this.setFrameFromCenter$java_awt_geom_Point2D$java_awt_geom_Point2D(centerX, centerY);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Sets the framing rectangle of this <code>Shape</code> based on a
     * specified center <code>Point2D</code> and corner <code>Point2D</code>.
     * The framing rectangle is used by the subclasses of
     * <code>RectangularShape</code> to define their geometry.
     *
     * @param {Point2D} center
     * the specified center <code>Point2D</code>
     * @param {Point2D} corner
     * the specified corner <code>Point2D</code>
     * @since 1.2
     */
    RectangularShape.prototype.setFrameFromCenter$java_awt_geom_Point2D$java_awt_geom_Point2D = function (center, corner) {
        this.setFrameFromCenter$double$double$double$double(center.getX(), center.getY(), corner.getX(), corner.getY());
    };
    RectangularShape.prototype.contains = function (x, y, w, h, origrect) {
        if (((x != null && x instanceof Point2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
            return this.contains$java_awt_geom_Point2D(x);
        }
        else if (((x != null && x instanceof Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
            return this.contains$java_awt_geom_Rectangle2D(x);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {Point2D} p
     * @return {boolean}
     */
    RectangularShape.prototype.contains$java_awt_geom_Point2D = function (p) {
        return this['contains$double$double'](p.getX(), p.getY());
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {Rectangle2D} r
     * @return {boolean}
     */
    RectangularShape.prototype.intersects$java_awt_geom_Rectangle2D = function (r) {
        return this['intersects$double$double$double$double'](r.getX(), r.getY(), r.getWidth(), r.getHeight());
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {Rectangle2D} r
     * @return {boolean}
     */
    RectangularShape.prototype.contains$java_awt_geom_Rectangle2D = function (r) {
        return this['contains$double$double$double$double'](r.getX(), r.getY(), r.getWidth(), r.getHeight());
    };
    /**
     * Returns an iterator object that iterates along the <code>Shape</code>
     * object's boundary and provides access to a flattened view of the outline
     * of the <code>Shape</code> object's geometry.
     * <p>
     * Only SEG_MOVETO, SEG_LINETO, and SEG_CLOSE point types will be returned
     * by the iterator.
     * <p>
     * The amount of subdivision of the curved segments is controlled by the
     * <code>flatness</code> parameter, which specifies the maximum distance
     * that any point on the unflattened transformed curve can deviate from the
     * returned flattened path segments. An optional {@link AffineTransform} can
     * be specified so that the coordinates returned in the iteration are
     * transformed accordingly.
     *
     * @param {AffineTransform} at
     * an optional <code>AffineTransform</code> to be applied to the
     * coordinates as they are returned in the iteration, or
     * <code>null</code> if untransformed coordinates are desired.
     * @param {number} flatness
     * the maximum distance that the line segments used to
     * approximate the curved segments are allowed to deviate from
     * any point on the original curve
     * @return {PathIterator} a <code>PathIterator</code> object that provides access to the
     * <code>Shape</code> object's flattened geometry.
     * @since 1.2
     */
    RectangularShape.prototype.getPathIterator$java_awt_geom_AffineTransform$double = function (at, flatness) {
        return new FlatteningPathIterator(this['getPathIterator$java_awt_geom_AffineTransform'](at), flatness);
    };
    /**
     * Returns an iterator object that iterates along the <code>Shape</code>
     * object's boundary and provides access to a flattened view of the outline
     * of the <code>Shape</code> object's geometry.
     * <p>
     * Only SEG_MOVETO, SEG_LINETO, and SEG_CLOSE point types will be returned
     * by the iterator.
     * <p>
     * The amount of subdivision of the curved segments is controlled by the
     * <code>flatness</code> parameter, which specifies the maximum distance
     * that any point on the unflattened transformed curve can deviate from the
     * returned flattened path segments. An optional {@link AffineTransform} can
     * be specified so that the coordinates returned in the iteration are
     * transformed accordingly.
     *
     * @param {AffineTransform} at
     * an optional <code>AffineTransform</code> to be applied to the
     * coordinates as they are returned in the iteration, or
     * <code>null</code> if untransformed coordinates are desired.
     * @param {number} flatness
     * the maximum distance that the line segments used to
     * approximate the curved segments are allowed to deviate from
     * any point on the original curve
     * @return {PathIterator} a <code>PathIterator</code> object that provides access to the
     * <code>Shape</code> object's flattened geometry.
     * @since 1.2
     */
    RectangularShape.prototype.getPathIterator = function (at, flatness) {
        if (((at != null && at instanceof AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
            return this.getPathIterator$java_awt_geom_AffineTransform$double(at, flatness);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Creates a new object of the same class and with the same contents as this
     * object.
     *
     * @return {*} a clone of this instance.
     * @exception OutOfMemoryError
     * if there is not enough memory.
     * @see java.lang.Cloneable
     * @since 1.2
     */
    RectangularShape.prototype.clone = function () {
        try {
            return (function (o) { var clone = Object.create(o); for (var p in o) {
                if (o.hasOwnProperty(p))
                    clone[p] = o[p];
            } return clone; })(this);
        }
        catch (e) {
            throw Object.defineProperty(new Error(e.message), '__class', { configurable: true, value: 'java.lang.InternalError' });
        }
        ;
    };
    return RectangularShape;
}());
RectangularShape["__class"] = "RectangularShape";
RectangularShape["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable"];
/**
 * A utility class to iterate over the path segments of a rectangle through the
 * PathIterator interface.
 *
 * @author Jim Graham
 */
var RectIterator = (function () {
    function RectIterator(r, at) {
        this.x = 0;
        this.y = 0;
        this.w = 0;
        this.h = 0;
        this.affine = null;
        this.index = 0;
        this.x = r.getX();
        this.y = r.getY();
        this.w = r.getWidth();
        this.h = r.getHeight();
        this.affine = at;
        if (this.w < 0 || this.h < 0) {
            this.index = 6;
        }
    }
    /**
     * Return the winding rule for determining the insideness of the path.
     *
     * @see #WIND_EVEN_ODD
     * @see #WIND_NON_ZERO
     * @return {number}
     */
    RectIterator.prototype.getWindingRule = function () {
        return PathIterator.WIND_NON_ZERO;
    };
    /**
     * Tests if there are more points to read.
     *
     * @return {boolean} true if there are more points to read
     */
    RectIterator.prototype.isDone = function () {
        return this.index > 5;
    };
    RectIterator.prototype.next = function (doNext) {
        if (doNext === undefined) {
            return this.next$();
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Moves the iterator to the next segment of the path forwards along the
     * primary direction of traversal as long as there are more points in that
     * direction.
     */
    RectIterator.prototype.next$ = function () {
        this.index++;
    };
    /**
     * Returns the coordinates and type of the current path segment in the
     * iteration. The return value is the path segment type: SEG_MOVETO,
     * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
     * length 6 must be passed in and may be used to store the coordinates of
     * the point(s). Each point is stored as a pair of float x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
     * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
     * not return any points.
     *
     * @see #SEG_MOVETO
     * @see #SEG_LINETO
     * @see #SEG_QUADTO
     * @see #SEG_CUBICTO
     * @see #SEG_CLOSE
     * @param {Array} coords
     * @return {number}
     */
    RectIterator.prototype.currentSegment$float_A = function (coords) {
        if (this.isDone()) {
            throw Object.defineProperty(new Error("rect iterator out of bounds"), '__class', { configurable: true, value: 'java.util.NoSuchElementException' });
        }
        if (this.index === 5) {
            return PathIterator.SEG_CLOSE;
        }
        coords[0] = this.x;
        coords[1] = this.y;
        if (this.index === 1 || this.index === 2) {
            coords[0] += this.w;
        }
        if (this.index === 2 || this.index === 3) {
            coords[1] += this.h;
        }
        if (this.affine != null) {
            this.affine.transform$float_A$int$float_A$int$int(coords, 0, coords, 0, 1);
        }
        return (this.index === 0 ? PathIterator.SEG_MOVETO : PathIterator.SEG_LINETO);
    };
    /**
     * Returns the coordinates and type of the current path segment in the
     * iteration. The return value is the path segment type: SEG_MOVETO,
     * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
     * length 6 must be passed in and may be used to store the coordinates of
     * the point(s). Each point is stored as a pair of float x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
     * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
     * not return any points.
     *
     * @see #SEG_MOVETO
     * @see #SEG_LINETO
     * @see #SEG_QUADTO
     * @see #SEG_CUBICTO
     * @see #SEG_CLOSE
     * @param {Array} coords
     * @return {number}
     */
    RectIterator.prototype.currentSegment = function (coords) {
        if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
            return this.currentSegment$float_A(coords);
        }
        else if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
            return this.currentSegment$double_A(coords);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Returns the coordinates and type of the current path segment in the
     * iteration. The return value is the path segment type: SEG_MOVETO,
     * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A double array of
     * length 6 must be passed in and may be used to store the coordinates of
     * the point(s). Each point is stored as a pair of double x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
     * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
     * not return any points.
     *
     * @see #SEG_MOVETO
     * @see #SEG_LINETO
     * @see #SEG_QUADTO
     * @see #SEG_CUBICTO
     * @see #SEG_CLOSE
     * @param {Array} coords
     * @return {number}
     */
    RectIterator.prototype.currentSegment$double_A = function (coords) {
        if (this.isDone()) {
            throw Object.defineProperty(new Error("rect iterator out of bounds"), '__class', { configurable: true, value: 'java.util.NoSuchElementException' });
        }
        if (this.index === 5) {
            return PathIterator.SEG_CLOSE;
        }
        coords[0] = this.x;
        coords[1] = this.y;
        if (this.index === 1 || this.index === 2) {
            coords[0] += this.w;
        }
        if (this.index === 2 || this.index === 3) {
            coords[1] += this.h;
        }
        if (this.affine != null) {
            this.affine.transform$double_A$int$double_A$int$int(coords, 0, coords, 0, 1);
        }
        return (this.index === 0 ? PathIterator.SEG_MOVETO : PathIterator.SEG_LINETO);
    };
    return RectIterator;
}());
RectIterator["__class"] = "RectIterator";
RectIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
/**
 * A utility class to iterate over the path segments of an rounded rectangle
 * through the PathIterator interface.
 *
 * @author Jim Graham
 */
var RoundRectIterator = (function () {
    function RoundRectIterator(rr, at) {
        this.x = 0;
        this.y = 0;
        this.w = 0;
        this.h = 0;
        this.aw = 0;
        this.ah = 0;
        this.affine = null;
        this.index = 0;
        this.x = rr.getX();
        this.y = rr.getY();
        this.w = rr.getWidth();
        this.h = rr.getHeight();
        this.aw = Math.min(this.w, Math.abs(rr.getArcWidth()));
        this.ah = Math.min(this.h, Math.abs(rr.getArcHeight()));
        this.affine = at;
        if (this.aw < 0 || this.ah < 0) {
            this.index = RoundRectIterator.ctrlpts_$LI$().length;
        }
    }
    /**
     * Return the winding rule for determining the insideness of the path.
     *
     * @see #WIND_EVEN_ODD
     * @see #WIND_NON_ZERO
     * @return {number}
     */
    RoundRectIterator.prototype.getWindingRule = function () {
        return PathIterator.WIND_NON_ZERO;
    };
    /**
     * Tests if there are more points to read.
     *
     * @return {boolean} true if there are more points to read
     */
    RoundRectIterator.prototype.isDone = function () {
        return this.index >= RoundRectIterator.ctrlpts_$LI$().length;
    };
    RoundRectIterator.prototype.next = function (doNext) {
        if (doNext === undefined) {
            return this.next$();
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Moves the iterator to the next segment of the path forwards along the
     * primary direction of traversal as long as there are more points in that
     * direction.
     */
    RoundRectIterator.prototype.next$ = function () {
        this.index++;
    };
    RoundRectIterator.angle_$LI$ = function () { if (RoundRectIterator.angle == null)
        RoundRectIterator.angle = Math.PI / 4.0; return RoundRectIterator.angle; };
    ;
    RoundRectIterator.a_$LI$ = function () { if (RoundRectIterator.a == null)
        RoundRectIterator.a = 1.0 - Math.cos(RoundRectIterator.angle_$LI$()); return RoundRectIterator.a; };
    ;
    RoundRectIterator.b_$LI$ = function () { if (RoundRectIterator.b == null)
        RoundRectIterator.b = Math.tan(RoundRectIterator.angle_$LI$()); return RoundRectIterator.b; };
    ;
    RoundRectIterator.c_$LI$ = function () { if (RoundRectIterator.c == null)
        RoundRectIterator.c = Math.sqrt(1.0 + RoundRectIterator.b_$LI$() * RoundRectIterator.b_$LI$()) - 1 + RoundRectIterator.a_$LI$(); return RoundRectIterator.c; };
    ;
    RoundRectIterator.cv_$LI$ = function () { if (RoundRectIterator.cv == null)
        RoundRectIterator.cv = 4.0 / 3.0 * RoundRectIterator.a_$LI$() * RoundRectIterator.b_$LI$() / RoundRectIterator.c_$LI$(); return RoundRectIterator.cv; };
    ;
    RoundRectIterator.acv_$LI$ = function () { if (RoundRectIterator.acv == null)
        RoundRectIterator.acv = (1.0 - RoundRectIterator.cv_$LI$()) / 2.0; return RoundRectIterator.acv; };
    ;
    RoundRectIterator.ctrlpts_$LI$ = function () { if (RoundRectIterator.ctrlpts == null)
        RoundRectIterator.ctrlpts = [[0.0, 0.0, 0.0, 0.5], [0.0, 0.0, 1.0, -0.5], [0.0, 0.0, 1.0, -RoundRectIterator.acv_$LI$(), 0.0, RoundRectIterator.acv_$LI$(), 1.0, 0.0, 0.0, 0.5, 1.0, 0.0], [1.0, -0.5, 1.0, 0.0], [1.0, -RoundRectIterator.acv_$LI$(), 1.0, 0.0, 1.0, 0.0, 1.0, -RoundRectIterator.acv_$LI$(), 1.0, 0.0, 1.0, -0.5], [1.0, 0.0, 0.0, 0.5], [1.0, 0.0, 0.0, RoundRectIterator.acv_$LI$(), 1.0, -RoundRectIterator.acv_$LI$(), 0.0, 0.0, 1.0, -0.5, 0.0, 0.0], [0.0, 0.5, 0.0, 0.0], [0.0, RoundRectIterator.acv_$LI$(), 0.0, 0.0, 0.0, 0.0, 0.0, RoundRectIterator.acv_$LI$(), 0.0, 0.0, 0.0, 0.5], []]; return RoundRectIterator.ctrlpts; };
    ;
    RoundRectIterator.types_$LI$ = function () { if (RoundRectIterator.types == null)
        RoundRectIterator.types = [PathIterator.SEG_MOVETO, PathIterator.SEG_LINETO, PathIterator.SEG_CUBICTO, PathIterator.SEG_LINETO, PathIterator.SEG_CUBICTO, PathIterator.SEG_LINETO, PathIterator.SEG_CUBICTO, PathIterator.SEG_LINETO, PathIterator.SEG_CUBICTO, PathIterator.SEG_CLOSE]; return RoundRectIterator.types; };
    ;
    /**
     * Returns the coordinates and type of the current path segment in the
     * iteration. The return value is the path segment type: SEG_MOVETO,
     * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
     * length 6 must be passed in and may be used to store the coordinates of
     * the point(s). Each point is stored as a pair of float x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
     * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
     * not return any points.
     *
     * @see #SEG_MOVETO
     * @see #SEG_LINETO
     * @see #SEG_QUADTO
     * @see #SEG_CUBICTO
     * @see #SEG_CLOSE
     * @param {Array} coords
     * @return {number}
     */
    RoundRectIterator.prototype.currentSegment$float_A = function (coords) {
        if (this.isDone()) {
            throw Object.defineProperty(new Error("roundrect iterator out of bounds"), '__class', { configurable: true, value: 'java.util.NoSuchElementException' });
        }
        var ctrls = RoundRectIterator.ctrlpts_$LI$()[this.index];
        var nc = 0;
        for (var i = 0; i < ctrls.length; i += 4) {
            coords[nc++] = (this.x + ctrls[i + 0] * this.w + ctrls[i + 1] * this.aw);
            coords[nc++] = (this.y + ctrls[i + 2] * this.h + ctrls[i + 3] * this.ah);
        }
        if (this.affine != null) {
            this.affine.transform$float_A$int$float_A$int$int(coords, 0, coords, 0, (nc / 2 | 0));
        }
        return RoundRectIterator.types_$LI$()[this.index];
    };
    /**
     * Returns the coordinates and type of the current path segment in the
     * iteration. The return value is the path segment type: SEG_MOVETO,
     * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
     * length 6 must be passed in and may be used to store the coordinates of
     * the point(s). Each point is stored as a pair of float x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
     * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
     * not return any points.
     *
     * @see #SEG_MOVETO
     * @see #SEG_LINETO
     * @see #SEG_QUADTO
     * @see #SEG_CUBICTO
     * @see #SEG_CLOSE
     * @param {Array} coords
     * @return {number}
     */
    RoundRectIterator.prototype.currentSegment = function (coords) {
        if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
            return this.currentSegment$float_A(coords);
        }
        else if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
            return this.currentSegment$double_A(coords);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Returns the coordinates and type of the current path segment in the
     * iteration. The return value is the path segment type: SEG_MOVETO,
     * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A double array of
     * length 6 must be passed in and may be used to store the coordinates of
     * the point(s). Each point is stored as a pair of double x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
     * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
     * not return any points.
     *
     * @see #SEG_MOVETO
     * @see #SEG_LINETO
     * @see #SEG_QUADTO
     * @see #SEG_CUBICTO
     * @see #SEG_CLOSE
     * @param {Array} coords
     * @return {number}
     */
    RoundRectIterator.prototype.currentSegment$double_A = function (coords) {
        if (this.isDone()) {
            throw Object.defineProperty(new Error("roundrect iterator out of bounds"), '__class', { configurable: true, value: 'java.util.NoSuchElementException' });
        }
        var ctrls = RoundRectIterator.ctrlpts_$LI$()[this.index];
        var nc = 0;
        for (var i = 0; i < ctrls.length; i += 4) {
            coords[nc++] = (this.x + ctrls[i + 0] * this.w + ctrls[i + 1] * this.aw);
            coords[nc++] = (this.y + ctrls[i + 2] * this.h + ctrls[i + 3] * this.ah);
        }
        if (this.affine != null) {
            this.affine.transform$double_A$int$double_A$int$int(coords, 0, coords, 0, (nc / 2 | 0));
        }
        return RoundRectIterator.types_$LI$()[this.index];
    };
    return RoundRectIterator;
}());
RoundRectIterator["__class"] = "RoundRectIterator";
RoundRectIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
var javaemul;
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Wraps a native <code>char</code> as an object.
         *
         * TODO(jat): many of the classification methods implemented here are not
         * correct in that they only handle ASCII characters, and many other methods are
         * not currently implemented. I think the proper approach is to introduce * a
         * deferred binding parameter which substitutes an implementation using a
         * fully-correct Unicode character database, at the expense of additional data
         * being downloaded. That way developers that need the functionality can get it
         * without those who don't need it paying for it.
         *
         * <pre>
         * The following methods are still not implemented -- most would require Unicode
         * character db to be useful:
         * - digit / is* / to*(int codePoint)
         * - isDefined(char)
         * - isIdentifierIgnorable(char)
         * - isJavaIdentifierPart(char)
         * - isJavaIdentifierStart(char)
         * - isJavaLetter(char) -- deprecated, so probably not
         * - isJavaLetterOrDigit(char) -- deprecated, so probably not
         * - isISOControl(char)
         * - isMirrored(char)
         * - isSpaceChar(char)
         * - isTitleCase(char)
         * - isUnicodeIdentifierPart(char)
         * - isUnicodeIdentifierStart(char)
         * - getDirectionality(*)
         * - getNumericValue(*)
         * - getType(*)
         * - reverseBytes(char) -- any use for this at all in the browser?
         * - toTitleCase(*)
         * - all the category constants for classification
         *
         * The following do not properly handle characters outside of ASCII:
         * - digit(char c, int radix)
         * - isDigit(char c)
         * - isLetter(char c)
         * - isLetterOrDigit(char c)
         * - isLowerCase(char c)
         * - isUpperCase(char c)
         * </pre>
         */
        var CharacterHelper = (function () {
            function CharacterHelper(value) {
                this.value = null;
                this.value = value;
            }
            CharacterHelper.TYPE_$LI$ = function () { if (CharacterHelper.TYPE == null)
                CharacterHelper.TYPE = String; return CharacterHelper.TYPE; };
            ;
            CharacterHelper.charCount = function (codePoint) {
                return codePoint >= CharacterHelper.MIN_SUPPLEMENTARY_CODE_POINT ? 2 : 1;
            };
            CharacterHelper.codePointAt$char_A$int = function (a, index) {
                return CharacterHelper.codePointAt$java_lang_CharSequence$int$int(new String(a), index, a.length);
            };
            CharacterHelper.codePointAt$char_A$int$int = function (a, index, limit) {
                return CharacterHelper.codePointAt$java_lang_CharSequence$int$int(new String(a), index, limit);
            };
            CharacterHelper.codePointAt = function (a, index, limit) {
                if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'string'))) || a === null) && ((typeof index === 'number') || index === null) && ((typeof limit === 'number') || limit === null)) {
                    return javaemul.internal.CharacterHelper.codePointAt$char_A$int$int(a, index, limit);
                }
                else if (((a != null && (a["__interfaces"] != null && a["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || a.constructor != null && a.constructor["__interfaces"] != null && a.constructor["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof a === "string")) || a === null) && ((typeof index === 'number') || index === null) && ((typeof limit === 'number') || limit === null)) {
                    return javaemul.internal.CharacterHelper.codePointAt$java_lang_CharSequence$int$int(a, index, limit);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'string'))) || a === null) && ((typeof index === 'number') || index === null) && limit === undefined) {
                    return javaemul.internal.CharacterHelper.codePointAt$char_A$int(a, index);
                }
                else if (((a != null && (a["__interfaces"] != null && a["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || a.constructor != null && a.constructor["__interfaces"] != null && a.constructor["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof a === "string")) || a === null) && ((typeof index === 'number') || index === null) && limit === undefined) {
                    return javaemul.internal.CharacterHelper.codePointAt$java_lang_CharSequence$int(a, index);
                }
                else
                    throw new Error('invalid overload');
            };
            CharacterHelper.codePointAt$java_lang_CharSequence$int = function (seq, index) {
                return CharacterHelper.codePointAt$java_lang_CharSequence$int$int(seq, index, seq.length);
            };
            CharacterHelper.codePointBefore$char_A$int = function (a, index) {
                return CharacterHelper.codePointBefore$java_lang_CharSequence$int$int(new String(a), index, 0);
            };
            CharacterHelper.codePointBefore$char_A$int$int = function (a, index, start) {
                return CharacterHelper.codePointBefore$java_lang_CharSequence$int$int(new String(a), index, start);
            };
            CharacterHelper.codePointBefore = function (a, index, start) {
                if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'string'))) || a === null) && ((typeof index === 'number') || index === null) && ((typeof start === 'number') || start === null)) {
                    return javaemul.internal.CharacterHelper.codePointBefore$char_A$int$int(a, index, start);
                }
                else if (((a != null && (a["__interfaces"] != null && a["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || a.constructor != null && a.constructor["__interfaces"] != null && a.constructor["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof a === "string")) || a === null) && ((typeof index === 'number') || index === null) && ((typeof start === 'number') || start === null)) {
                    return javaemul.internal.CharacterHelper.codePointBefore$java_lang_CharSequence$int$int(a, index, start);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'string'))) || a === null) && ((typeof index === 'number') || index === null) && start === undefined) {
                    return javaemul.internal.CharacterHelper.codePointBefore$char_A$int(a, index);
                }
                else if (((a != null && (a["__interfaces"] != null && a["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || a.constructor != null && a.constructor["__interfaces"] != null && a.constructor["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof a === "string")) || a === null) && ((typeof index === 'number') || index === null) && start === undefined) {
                    return javaemul.internal.CharacterHelper.codePointBefore$java_lang_CharSequence$int(a, index);
                }
                else
                    throw new Error('invalid overload');
            };
            CharacterHelper.codePointBefore$java_lang_CharSequence$int = function (cs, index) {
                return CharacterHelper.codePointBefore$java_lang_CharSequence$int$int(cs, index, 0);
            };
            CharacterHelper.codePointCount$char_A$int$int = function (a, offset, count) {
                return CharacterHelper.codePointCount$java_lang_CharSequence$int$int(new String(a), offset, offset + count);
            };
            CharacterHelper.codePointCount = function (a, offset, count) {
                if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'string'))) || a === null) && ((typeof offset === 'number') || offset === null) && ((typeof count === 'number') || count === null)) {
                    return javaemul.internal.CharacterHelper.codePointCount$char_A$int$int(a, offset, count);
                }
                else if (((a != null && (a["__interfaces"] != null && a["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || a.constructor != null && a.constructor["__interfaces"] != null && a.constructor["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof a === "string")) || a === null) && ((typeof offset === 'number') || offset === null) && ((typeof count === 'number') || count === null)) {
                    return javaemul.internal.CharacterHelper.codePointCount$java_lang_CharSequence$int$int(a, offset, count);
                }
                else
                    throw new Error('invalid overload');
            };
            CharacterHelper.codePointCount$java_lang_CharSequence$int$int = function (seq, beginIndex, endIndex) {
                var count = 0;
                for (var idx = beginIndex; idx < endIndex;) {
                    var ch = seq.charAt(idx++);
                    if (CharacterHelper.isHighSurrogate(ch) && idx < endIndex && (CharacterHelper.isLowSurrogate(seq.charAt(idx)))) {
                        ++idx;
                    }
                    ++count;
                }
                return count;
            };
            CharacterHelper.compare = function (x, y) {
                return (function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(x) - (function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(y);
            };
            CharacterHelper.digit = function (c, radix) {
                if (radix < CharacterHelper.MIN_RADIX || radix > CharacterHelper.MAX_RADIX) {
                    return -1;
                }
                if ((function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(c) >= '0'.charCodeAt(0) && (function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(c) < '0'.charCodeAt(0) + Math.min(radix, 10)) {
                    return (function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(c) - '0'.charCodeAt(0);
                }
                if ((function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(c) >= 'a'.charCodeAt(0) && (function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(c) < (radix + 'a'.charCodeAt(0) - 10)) {
                    return (function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(c) - 'a'.charCodeAt(0) + 10;
                }
                if ((function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(c) >= 'A'.charCodeAt(0) && (function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(c) < (radix + 'A'.charCodeAt(0) - 10)) {
                    return (function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(c) - 'A'.charCodeAt(0) + 10;
                }
                return -1;
            };
            CharacterHelper.getNumericValue = function (ch) {
                return (ch.charCodeAt(0) | 0);
            };
            CharacterHelper.forDigit$int$int = function (digit, radix) {
                if (radix < CharacterHelper.MIN_RADIX || radix > CharacterHelper.MAX_RADIX) {
                    return String.fromCharCode(0);
                }
                if (digit < 0 || digit >= radix) {
                    return String.fromCharCode(0);
                }
                return CharacterHelper.forDigit$int(digit);
            };
            CharacterHelper.forDigit = function (digit, radix) {
                if (((typeof digit === 'number') || digit === null) && ((typeof radix === 'number') || radix === null)) {
                    return javaemul.internal.CharacterHelper.forDigit$int$int(digit, radix);
                }
                else if (((typeof digit === 'number') || digit === null) && radix === undefined) {
                    return javaemul.internal.CharacterHelper.forDigit$int(digit);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * @skip
             *
             * public for shared implementation with Arrays.hashCode
             * @param {string} c
             * @return {number}
             */
            CharacterHelper.hashCode = function (c) {
                return (c).charCodeAt(0);
            };
            CharacterHelper.isDigit = function (c) {
                var result = (new String(c).toString()).match(CharacterHelper.digitRegex());
                return result != null && result.length > 0;
            };
            CharacterHelper.digitRegex = function () {
                return new RegExp("\\d");
            };
            CharacterHelper.isHighSurrogate = function (ch) {
                return (function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(ch) >= (function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(CharacterHelper.MIN_HIGH_SURROGATE) && (function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(ch) <= (function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(CharacterHelper.MAX_HIGH_SURROGATE);
            };
            CharacterHelper.isLetter = function (c) {
                return (new String(c).toString()).match(CharacterHelper.leterRegex()).length > 0;
            };
            CharacterHelper.leterRegex = function () {
                return new RegExp("[A-Z]", "i");
            };
            CharacterHelper.isLetterOrDigit = function (c) {
                return (new String(c).toString()).match(CharacterHelper.leterOrDigitRegex()).length > 0;
            };
            CharacterHelper.leterOrDigitRegex = function () {
                return new RegExp("[A-Z\\d]", "i");
            };
            CharacterHelper.isLowerCase = function (c) {
                return (function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(CharacterHelper.toLowerCase$char(c)) == (function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(c) && CharacterHelper.isLetter(c);
            };
            CharacterHelper.isLowSurrogate = function (ch) {
                return (function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(ch) >= (function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(CharacterHelper.MIN_LOW_SURROGATE) && (function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(ch) <= (function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(CharacterHelper.MAX_LOW_SURROGATE);
            };
            /**
             * Deprecated - see isWhitespace(char).
             * @param {string} c
             * @return {boolean}
             */
            CharacterHelper.isSpace = function (c) {
                switch ((c)) {
                    case ' ':
                        return true;
                    case '\n':
                        return true;
                    case '\t':
                        return true;
                    case '\f':
                        return true;
                    case '\r':
                        return true;
                    default:
                        return false;
                }
            };
            CharacterHelper.isWhitespace$char = function (ch) {
                return (new String(ch).toString()).match(CharacterHelper.whitespaceRegex()).length > 0;
            };
            CharacterHelper.isWhitespace = function (ch) {
                if (((typeof ch === 'string') || ch === null)) {
                    return javaemul.internal.CharacterHelper.isWhitespace$char(ch);
                }
                else if (((typeof ch === 'number') || ch === null)) {
                    return javaemul.internal.CharacterHelper.isWhitespace$int(ch);
                }
                else
                    throw new Error('invalid overload');
            };
            CharacterHelper.isWhitespace$int = function (codePoint) {
                return (String.fromCharCode(codePoint)).match(CharacterHelper.whitespaceRegex()).length > 0;
            };
            CharacterHelper.whitespaceRegex = function () {
                return new RegExp("[\\t-\\r \\u1680\\u180E\\u2000-\\u2006\\u2008-\\u200A\\u2028\\u2029\\u205F\\u3000\\uFEFF]|[\\x1C-\\x1F]");
            };
            CharacterHelper.isSupplementaryCodePoint = function (codePoint) {
                return codePoint >= CharacterHelper.MIN_SUPPLEMENTARY_CODE_POINT && codePoint <= CharacterHelper.MAX_CODE_POINT;
            };
            CharacterHelper.isSurrogatePair = function (highSurrogate, lowSurrogate) {
                return CharacterHelper.isHighSurrogate(highSurrogate) && CharacterHelper.isLowSurrogate(lowSurrogate);
            };
            CharacterHelper.isUpperCase = function (c) {
                return (function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(CharacterHelper.toUpperCase$char(c)) == (function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(c) && CharacterHelper.isLetter(c);
            };
            CharacterHelper.isValidCodePoint = function (codePoint) {
                return codePoint >= CharacterHelper.MIN_CODE_POINT && codePoint <= CharacterHelper.MAX_CODE_POINT;
            };
            CharacterHelper.offsetByCodePoints$char_A$int$int$int$int = function (a, start, count, index, codePointOffset) {
                return CharacterHelper.offsetByCodePoints$java_lang_CharSequence$int$int((function (str, index, len) { return str.substring(index, index + len); })((a).join(''), start, count), index, codePointOffset);
            };
            CharacterHelper.offsetByCodePoints = function (a, start, count, index, codePointOffset) {
                if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'string'))) || a === null) && ((typeof start === 'number') || start === null) && ((typeof count === 'number') || count === null) && ((typeof index === 'number') || index === null) && ((typeof codePointOffset === 'number') || codePointOffset === null)) {
                    return javaemul.internal.CharacterHelper.offsetByCodePoints$char_A$int$int$int$int(a, start, count, index, codePointOffset);
                }
                else if (((a != null && (a["__interfaces"] != null && a["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || a.constructor != null && a.constructor["__interfaces"] != null && a.constructor["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof a === "string")) || a === null) && ((typeof start === 'number') || start === null) && ((typeof count === 'number') || count === null) && index === undefined && codePointOffset === undefined) {
                    return javaemul.internal.CharacterHelper.offsetByCodePoints$java_lang_CharSequence$int$int(a, start, count);
                }
                else
                    throw new Error('invalid overload');
            };
            CharacterHelper.offsetByCodePoints$java_lang_CharSequence$int$int = function (seq, index, codePointOffset) {
                if (codePointOffset < 0) {
                    while ((codePointOffset < 0)) {
                        --index;
                        if (CharacterHelper.isLowSurrogate(seq.charAt(index)) && CharacterHelper.isHighSurrogate(seq.charAt(index - 1))) {
                            --index;
                        }
                        ++codePointOffset;
                    }
                    ;
                }
                else {
                    while ((codePointOffset > 0)) {
                        if (CharacterHelper.isHighSurrogate(seq.charAt(index)) && CharacterHelper.isLowSurrogate(seq.charAt(index + 1))) {
                            ++index;
                        }
                        ++index;
                        --codePointOffset;
                    }
                    ;
                }
                return index;
            };
            CharacterHelper.toChars$int = function (codePoint) {
                javaemul.internal.InternalPreconditions.checkCriticalArgument(codePoint >= 0 && codePoint <= CharacterHelper.MAX_CODE_POINT);
                if (codePoint >= CharacterHelper.MIN_SUPPLEMENTARY_CODE_POINT) {
                    return [CharacterHelper.getHighSurrogate(codePoint), CharacterHelper.getLowSurrogate(codePoint)];
                }
                else {
                    return [String.fromCharCode(codePoint)];
                }
            };
            CharacterHelper.toChars$int$char_A$int = function (codePoint, dst, dstIndex) {
                javaemul.internal.InternalPreconditions.checkCriticalArgument(codePoint >= 0 && codePoint <= CharacterHelper.MAX_CODE_POINT);
                if (codePoint >= CharacterHelper.MIN_SUPPLEMENTARY_CODE_POINT) {
                    dst[dstIndex++] = CharacterHelper.getHighSurrogate(codePoint);
                    dst[dstIndex] = CharacterHelper.getLowSurrogate(codePoint);
                    return 2;
                }
                else {
                    dst[dstIndex] = String.fromCharCode(codePoint);
                    return 1;
                }
            };
            CharacterHelper.toChars = function (codePoint, dst, dstIndex) {
                if (((typeof codePoint === 'number') || codePoint === null) && ((dst != null && dst instanceof Array && (dst.length == 0 || dst[0] == null || (typeof dst[0] === 'string'))) || dst === null) && ((typeof dstIndex === 'number') || dstIndex === null)) {
                    return javaemul.internal.CharacterHelper.toChars$int$char_A$int(codePoint, dst, dstIndex);
                }
                else if (((typeof codePoint === 'number') || codePoint === null) && dst === undefined && dstIndex === undefined) {
                    return javaemul.internal.CharacterHelper.toChars$int(codePoint);
                }
                else
                    throw new Error('invalid overload');
            };
            CharacterHelper.toCodePoint = function (highSurrogate, lowSurrogate) {
                return CharacterHelper.MIN_SUPPLEMENTARY_CODE_POINT + (((function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(highSurrogate) & 1023) << 10) + ((function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(lowSurrogate) & 1023);
            };
            CharacterHelper.toLowerCase$char = function (c) {
                return new String(c).toString().toLowerCase().charAt(0);
            };
            CharacterHelper.toLowerCase = function (c) {
                if (((typeof c === 'string') || c === null)) {
                    return javaemul.internal.CharacterHelper.toLowerCase$char(c);
                }
                else if (((typeof c === 'number') || c === null)) {
                    return javaemul.internal.CharacterHelper.toLowerCase$int(c);
                }
                else
                    throw new Error('invalid overload');
            };
            CharacterHelper.toLowerCase$int = function (c) {
                return (new String(String.fromCharCode(c)).toString().toLowerCase().charAt(0)).charCodeAt(0);
            };
            CharacterHelper.toString = function (x) {
                return new String(x).toString();
            };
            CharacterHelper.toUpperCase$char = function (c) {
                return new String(c).toString().toUpperCase().charAt(0);
            };
            CharacterHelper.toUpperCase = function (c) {
                if (((typeof c === 'string') || c === null)) {
                    return javaemul.internal.CharacterHelper.toUpperCase$char(c);
                }
                else if (((typeof c === 'number') || c === null)) {
                    return javaemul.internal.CharacterHelper.toUpperCase$int(c);
                }
                else
                    throw new Error('invalid overload');
            };
            CharacterHelper.toUpperCase$int = function (c) {
                return new String(String.fromCharCode(c)).toString().toUpperCase().charAt(0);
            };
            CharacterHelper.valueOf = function (c) {
                if ((function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(c) < 128) {
                    var result = CharacterHelper.BoxedValues.boxedValues_$LI$()[c];
                    if (result == null) {
                        result = CharacterHelper.BoxedValues.boxedValues_$LI$()[c] = new CharacterHelper(c);
                    }
                    return result;
                }
                return new CharacterHelper(c);
            };
            CharacterHelper.codePointAt$java_lang_CharSequence$int$int = function (cs, index, limit) {
                var hiSurrogate = cs.charAt(index++);
                var loSurrogate;
                if (CharacterHelper.isHighSurrogate(hiSurrogate) && index < limit && CharacterHelper.isLowSurrogate(loSurrogate = cs.charAt(index))) {
                    return CharacterHelper.toCodePoint(hiSurrogate, loSurrogate);
                }
                return (hiSurrogate).charCodeAt(0);
            };
            CharacterHelper.codePointBefore$java_lang_CharSequence$int$int = function (cs, index, start) {
                var loSurrogate = cs.charAt(--index);
                var highSurrogate;
                if (CharacterHelper.isLowSurrogate(loSurrogate) && index > start && CharacterHelper.isHighSurrogate(highSurrogate = cs.charAt(index - 1))) {
                    return CharacterHelper.toCodePoint(highSurrogate, loSurrogate);
                }
                return (loSurrogate).charCodeAt(0);
            };
            /**
             * Shared implementation with {@link LongHelper#toString}.
             *
             * @skip
             * @param {number} digit
             * @return {string}
             */
            CharacterHelper.forDigit$int = function (digit) {
                var overBaseTen = digit - 10;
                return String.fromCharCode((overBaseTen < 0 ? '0'.charCodeAt(0) + digit : 'a'.charCodeAt(0) + overBaseTen));
            };
            /**
             * Computes the high surrogate character of the UTF16 representation of a
             * non-BMP code point. See {@link getLowSurrogate}.
             *
             * @param {number} codePoint
             * requested codePoint, required to be >=
             * MIN_SUPPLEMENTARY_CODE_POINT
             * @return {string} high surrogate character
             */
            CharacterHelper.getHighSurrogate = function (codePoint) {
                return String.fromCharCode(((function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(CharacterHelper.MIN_HIGH_SURROGATE) + (((codePoint - CharacterHelper.MIN_SUPPLEMENTARY_CODE_POINT) >> 10) & 1023)));
            };
            /**
             * Computes the low surrogate character of the UTF16 representation of a
             * non-BMP code point. See {@link getHighSurrogate}.
             *
             * @param {number} codePoint
             * requested codePoint, required to be >=
             * MIN_SUPPLEMENTARY_CODE_POINT
             * @return {string} low surrogate character
             */
            CharacterHelper.getLowSurrogate = function (codePoint) {
                return String.fromCharCode(((function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(CharacterHelper.MIN_LOW_SURROGATE) + ((codePoint - CharacterHelper.MIN_SUPPLEMENTARY_CODE_POINT) & 1023)));
            };
            CharacterHelper.prototype.charValue = function () {
                return this.value;
            };
            CharacterHelper.prototype.compareTo = function (c) {
                return CharacterHelper.compare(this.value, c.value);
            };
            CharacterHelper.prototype.equals = function (o) {
                return (o != null && o instanceof javaemul.internal.CharacterHelper) && ((function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(o.value) == (function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(this.value));
            };
            CharacterHelper.prototype.toString = function () {
                return new String(this.value).toString();
            };
            return CharacterHelper;
        }());
        CharacterHelper.MIN_RADIX = 2;
        CharacterHelper.MAX_RADIX = 36;
        CharacterHelper.MIN_VALUE = '\u0000';
        CharacterHelper.MAX_VALUE = '\uffff';
        CharacterHelper.MIN_SURROGATE = '\ud800';
        CharacterHelper.MAX_SURROGATE = '\udfff';
        CharacterHelper.MIN_LOW_SURROGATE = '\udc00';
        CharacterHelper.MAX_LOW_SURROGATE = '\udfff';
        CharacterHelper.MIN_HIGH_SURROGATE = '\ud800';
        CharacterHelper.MAX_HIGH_SURROGATE = '\udbff';
        CharacterHelper.MIN_SUPPLEMENTARY_CODE_POINT = 65536;
        CharacterHelper.MIN_CODE_POINT = 0;
        CharacterHelper.MAX_CODE_POINT = 1114111;
        CharacterHelper.SIZE = 16;
        internal.CharacterHelper = CharacterHelper;
        CharacterHelper["__class"] = "javaemul.internal.CharacterHelper";
        CharacterHelper["__interfaces"] = ["java.lang.Comparable", "java.io.Serializable"];
        (function (CharacterHelper) {
            /**
             * Use nested class to avoid clinit on outer.
             */
            var BoxedValues = (function () {
                function BoxedValues() {
                }
                BoxedValues.boxedValues_$LI$ = function () { if (BoxedValues.boxedValues == null)
                    BoxedValues.boxedValues = new Array(128); return BoxedValues.boxedValues; };
                ;
                return BoxedValues;
            }());
            CharacterHelper.BoxedValues = BoxedValues;
            BoxedValues["__class"] = "javaemul.internal.CharacterHelper.BoxedValues";
        })(CharacterHelper = internal.CharacterHelper || (internal.CharacterHelper = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        var ExceptionHelper = (function () {
            function ExceptionHelper() {
            }
            ExceptionHelper.forInputString = function (s) {
                return Object.defineProperty(new Error("For input string: \"" + s + "\""), '__class', { configurable: true, value: 'java.lang.NumberFormatException' });
            };
            ExceptionHelper.forNullInputString = function () {
                return Object.defineProperty(new Error("null"), '__class', { configurable: true, value: 'java.lang.NumberFormatException' });
            };
            ExceptionHelper.forRadix = function (radix) {
                return Object.defineProperty(new Error("radix " + radix + " out of range"), '__class', { configurable: true, value: 'java.lang.NumberFormatException' });
            };
            return ExceptionHelper;
        }());
        internal.ExceptionHelper = ExceptionHelper;
        ExceptionHelper["__class"] = "javaemul.internal.ExceptionHelper";
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * A utility class that provides utility functions to do precondition checks
         * inside GWT-SDK.
         */
        var InternalPreconditions = (function () {
            function InternalPreconditions() {
            }
            InternalPreconditions.checkType = function (expression) {
                if (InternalPreconditions.TYPE_CHECK) {
                    InternalPreconditions.checkCriticalType(expression);
                }
                else if (InternalPreconditions.CHECKED_MODE) {
                    try {
                        InternalPreconditions.checkCriticalType(expression);
                    }
                    catch (e) {
                        throw Object.defineProperty(new Error(e.message), '__class', { configurable: true, value: 'java.lang.AssertionError' });
                    }
                    ;
                }
            };
            InternalPreconditions.checkCriticalType = function (expression) {
                if (!expression) {
                    throw Object.defineProperty(new Error(), '__class', { configurable: true, value: 'java.lang.ClassCastException' });
                }
            };
            /**
             * Ensures the truth of an expression that verifies array type.
             * @param {boolean} expression
             */
            InternalPreconditions.checkArrayType$boolean = function (expression) {
                if (InternalPreconditions.TYPE_CHECK) {
                    InternalPreconditions.checkCriticalArrayType$boolean(expression);
                }
                else if (InternalPreconditions.CHECKED_MODE) {
                    try {
                        InternalPreconditions.checkCriticalArrayType$boolean(expression);
                    }
                    catch (e) {
                        throw Object.defineProperty(new Error(e.message), '__class', { configurable: true, value: 'java.lang.AssertionError' });
                    }
                    ;
                }
            };
            InternalPreconditions.checkCriticalArrayType$boolean = function (expression) {
                if (!expression) {
                    throw Object.defineProperty(new Error(), '__class', { configurable: true, value: 'java.lang.ArrayStoreException' });
                }
            };
            /**
             * Ensures the truth of an expression that verifies array type.
             * @param {boolean} expression
             * @param {*} errorMessage
             */
            InternalPreconditions.checkArrayType$boolean$java_lang_Object = function (expression, errorMessage) {
                if (InternalPreconditions.TYPE_CHECK) {
                    InternalPreconditions.checkCriticalArrayType$boolean$java_lang_Object(expression, errorMessage);
                }
                else if (InternalPreconditions.CHECKED_MODE) {
                    try {
                        InternalPreconditions.checkCriticalArrayType$boolean$java_lang_Object(expression, errorMessage);
                    }
                    catch (e) {
                        throw Object.defineProperty(new Error(e.message), '__class', { configurable: true, value: 'java.lang.AssertionError' });
                    }
                    ;
                }
            };
            /**
             * Ensures the truth of an expression that verifies array type.
             * @param {boolean} expression
             * @param {*} errorMessage
             */
            InternalPreconditions.checkArrayType = function (expression, errorMessage) {
                if (((typeof expression === 'boolean') || expression === null) && ((errorMessage != null) || errorMessage === null)) {
                    return javaemul.internal.InternalPreconditions.checkArrayType$boolean$java_lang_Object(expression, errorMessage);
                }
                else if (((typeof expression === 'boolean') || expression === null) && errorMessage === undefined) {
                    return javaemul.internal.InternalPreconditions.checkArrayType$boolean(expression);
                }
                else
                    throw new Error('invalid overload');
            };
            InternalPreconditions.checkCriticalArrayType$boolean$java_lang_Object = function (expression, errorMessage) {
                if (!expression) {
                    throw Object.defineProperty(new Error(/* valueOf */ new String(errorMessage).toString()), '__class', { configurable: true, value: 'java.lang.ArrayStoreException' });
                }
            };
            InternalPreconditions.checkCriticalArrayType = function (expression, errorMessage) {
                if (((typeof expression === 'boolean') || expression === null) && ((errorMessage != null) || errorMessage === null)) {
                    return javaemul.internal.InternalPreconditions.checkCriticalArrayType$boolean$java_lang_Object(expression, errorMessage);
                }
                else if (((typeof expression === 'boolean') || expression === null) && errorMessage === undefined) {
                    return javaemul.internal.InternalPreconditions.checkCriticalArrayType$boolean(expression);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Ensures the truth of an expression involving existence of an element.
             * @param {boolean} expression
             */
            InternalPreconditions.checkElement$boolean = function (expression) {
                if (InternalPreconditions.API_CHECK) {
                    InternalPreconditions.checkCriticalElement$boolean(expression);
                }
                else if (InternalPreconditions.CHECKED_MODE) {
                    try {
                        InternalPreconditions.checkCriticalElement$boolean(expression);
                    }
                    catch (e) {
                        throw Object.defineProperty(new Error(e.message), '__class', { configurable: true, value: 'java.lang.AssertionError' });
                    }
                    ;
                }
            };
            /**
             * Ensures the truth of an expression involving existence of an element.
             * <p>
             * For cases where failing fast is pretty important and not failing early
             * could cause bugs that are much harder to debug.
             * @param {boolean} expression
             */
            InternalPreconditions.checkCriticalElement$boolean = function (expression) {
                if (!expression) {
                    throw new Error();
                }
            };
            /**
             * Ensures the truth of an expression involving existence of an element.
             * @param {boolean} expression
             * @param {*} errorMessage
             */
            InternalPreconditions.checkElement$boolean$java_lang_Object = function (expression, errorMessage) {
                if (InternalPreconditions.API_CHECK) {
                    InternalPreconditions.checkCriticalElement$boolean$java_lang_Object(expression, errorMessage);
                }
                else if (InternalPreconditions.CHECKED_MODE) {
                    try {
                        InternalPreconditions.checkCriticalElement$boolean$java_lang_Object(expression, errorMessage);
                    }
                    catch (e) {
                        throw Object.defineProperty(new Error(e.message), '__class', { configurable: true, value: 'java.lang.AssertionError' });
                    }
                    ;
                }
            };
            /**
             * Ensures the truth of an expression involving existence of an element.
             * @param {boolean} expression
             * @param {*} errorMessage
             */
            InternalPreconditions.checkElement = function (expression, errorMessage) {
                if (((typeof expression === 'boolean') || expression === null) && ((errorMessage != null) || errorMessage === null)) {
                    return javaemul.internal.InternalPreconditions.checkElement$boolean$java_lang_Object(expression, errorMessage);
                }
                else if (((typeof expression === 'boolean') || expression === null) && errorMessage === undefined) {
                    return javaemul.internal.InternalPreconditions.checkElement$boolean(expression);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Ensures the truth of an expression involving existence of an element.
             * <p>
             * For cases where failing fast is pretty important and not failing early
             * could cause bugs that are much harder to debug.
             * @param {boolean} expression
             * @param {*} errorMessage
             */
            InternalPreconditions.checkCriticalElement$boolean$java_lang_Object = function (expression, errorMessage) {
                if (!expression) {
                    throw Object.defineProperty(new Error(/* valueOf */ new String(errorMessage).toString()), '__class', { configurable: true, value: 'java.util.NoSuchElementException' });
                }
            };
            /**
             * Ensures the truth of an expression involving existence of an element.
             * <p>
             * For cases where failing fast is pretty important and not failing early
             * could cause bugs that are much harder to debug.
             * @param {boolean} expression
             * @param {*} errorMessage
             */
            InternalPreconditions.checkCriticalElement = function (expression, errorMessage) {
                if (((typeof expression === 'boolean') || expression === null) && ((errorMessage != null) || errorMessage === null)) {
                    return javaemul.internal.InternalPreconditions.checkCriticalElement$boolean$java_lang_Object(expression, errorMessage);
                }
                else if (((typeof expression === 'boolean') || expression === null) && errorMessage === undefined) {
                    return javaemul.internal.InternalPreconditions.checkCriticalElement$boolean(expression);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Ensures the truth of an expression involving one or more parameters to the
             * calling method.
             * @param {boolean} expression
             */
            InternalPreconditions.checkArgument$boolean = function (expression) {
                if (InternalPreconditions.API_CHECK) {
                    InternalPreconditions.checkCriticalArgument$boolean(expression);
                }
                else if (InternalPreconditions.CHECKED_MODE) {
                    try {
                        InternalPreconditions.checkCriticalArgument$boolean(expression);
                    }
                    catch (e) {
                        throw Object.defineProperty(new Error(e.message), '__class', { configurable: true, value: 'java.lang.AssertionError' });
                    }
                    ;
                }
            };
            /**
             * Ensures the truth of an expression involving one or more parameters to the
             * calling method.
             * <p>
             * For cases where failing fast is pretty important and not failing early
             * could cause bugs that are much harder to debug.
             * @param {boolean} expression
             */
            InternalPreconditions.checkCriticalArgument$boolean = function (expression) {
                if (!expression) {
                    throw Object.defineProperty(new Error(), '__class', { configurable: true, value: 'java.lang.IllegalArgumentException' });
                }
            };
            /**
             * Ensures the truth of an expression involving one or more parameters to the
             * calling method.
             * @param {boolean} expression
             * @param {*} errorMessage
             */
            InternalPreconditions.checkArgument$boolean$java_lang_Object = function (expression, errorMessage) {
                if (InternalPreconditions.API_CHECK) {
                    InternalPreconditions.checkCriticalArgument$boolean$java_lang_Object(expression, errorMessage);
                }
                else if (InternalPreconditions.CHECKED_MODE) {
                    try {
                        InternalPreconditions.checkCriticalArgument$boolean$java_lang_Object(expression, errorMessage);
                    }
                    catch (e) {
                        throw Object.defineProperty(new Error(e.message), '__class', { configurable: true, value: 'java.lang.AssertionError' });
                    }
                    ;
                }
            };
            /**
             * Ensures the truth of an expression involving one or more parameters to the
             * calling method.
             * <p>
             * For cases where failing fast is pretty important and not failing early
             * could cause bugs that are much harder to debug.
             * @param {boolean} expression
             * @param {*} errorMessage
             */
            InternalPreconditions.checkCriticalArgument$boolean$java_lang_Object = function (expression, errorMessage) {
                if (!expression) {
                    throw Object.defineProperty(new Error(/* valueOf */ new String(errorMessage).toString()), '__class', { configurable: true, value: 'java.lang.IllegalArgumentException' });
                }
            };
            /**
             * Ensures the truth of an expression involving one or more parameters to the
             * calling method.
             * @param {boolean} expression
             * @param {string} errorMessageTemplate
             * @param {Array} errorMessageArgs
             */
            InternalPreconditions.checkArgument$boolean$java_lang_String$java_lang_Object_A = function (expression, errorMessageTemplate) {
                var errorMessageArgs = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    errorMessageArgs[_i - 2] = arguments[_i];
                }
                if (InternalPreconditions.API_CHECK) {
                    InternalPreconditions.checkCriticalArgument.apply(this, [expression, errorMessageTemplate].concat(errorMessageArgs));
                }
                else if (InternalPreconditions.CHECKED_MODE) {
                    try {
                        InternalPreconditions.checkCriticalArgument.apply(this, [expression, errorMessageTemplate].concat(errorMessageArgs));
                    }
                    catch (e) {
                        throw Object.defineProperty(new Error(e.message), '__class', { configurable: true, value: 'java.lang.AssertionError' });
                    }
                    ;
                }
            };
            /**
             * Ensures the truth of an expression involving one or more parameters to the
             * calling method.
             * @param {boolean} expression
             * @param {string} errorMessageTemplate
             * @param {Array} errorMessageArgs
             */
            InternalPreconditions.checkArgument = function (expression, errorMessageTemplate) {
                var errorMessageArgs = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    errorMessageArgs[_i - 2] = arguments[_i];
                }
                if (((typeof expression === 'boolean') || expression === null) && ((typeof errorMessageTemplate === 'string') || errorMessageTemplate === null) && ((errorMessageArgs != null && errorMessageArgs instanceof Array && (errorMessageArgs.length == 0 || errorMessageArgs[0] == null || (errorMessageArgs[0] != null))) || errorMessageArgs === null)) {
                    return javaemul.internal.InternalPreconditions.checkArgument$boolean$java_lang_String$java_lang_Object_A(expression, errorMessageTemplate, errorMessageArgs);
                }
                else if (((typeof expression === 'boolean') || expression === null) && ((errorMessageTemplate != null) || errorMessageTemplate === null) && errorMessageArgs === undefined) {
                    return javaemul.internal.InternalPreconditions.checkArgument$boolean$java_lang_Object(expression, errorMessageTemplate);
                }
                else if (((typeof expression === 'boolean') || expression === null) && errorMessageTemplate === undefined && errorMessageArgs === undefined) {
                    return javaemul.internal.InternalPreconditions.checkArgument$boolean(expression);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Ensures the truth of an expression involving one or more parameters to the
             * calling method.
             * <p>
             * For cases where failing fast is pretty important and not failing early
             * could cause bugs that are much harder to debug.
             * @param {boolean} expression
             * @param {string} errorMessageTemplate
             * @param {Array} errorMessageArgs
             */
            InternalPreconditions.checkCriticalArgument$boolean$java_lang_String$java_lang_Object_A = function (expression, errorMessageTemplate) {
                var errorMessageArgs = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    errorMessageArgs[_i - 2] = arguments[_i];
                }
                if (!expression) {
                    throw Object.defineProperty(new Error(InternalPreconditions.format.apply(this, [errorMessageTemplate].concat(errorMessageArgs))), '__class', { configurable: true, value: 'java.lang.IllegalArgumentException' });
                }
            };
            /**
             * Ensures the truth of an expression involving one or more parameters to the
             * calling method.
             * <p>
             * For cases where failing fast is pretty important and not failing early
             * could cause bugs that are much harder to debug.
             * @param {boolean} expression
             * @param {string} errorMessageTemplate
             * @param {Array} errorMessageArgs
             */
            InternalPreconditions.checkCriticalArgument = function (expression, errorMessageTemplate) {
                var errorMessageArgs = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    errorMessageArgs[_i - 2] = arguments[_i];
                }
                if (((typeof expression === 'boolean') || expression === null) && ((typeof errorMessageTemplate === 'string') || errorMessageTemplate === null) && ((errorMessageArgs != null && errorMessageArgs instanceof Array && (errorMessageArgs.length == 0 || errorMessageArgs[0] == null || (errorMessageArgs[0] != null))) || errorMessageArgs === null)) {
                    return javaemul.internal.InternalPreconditions.checkCriticalArgument$boolean$java_lang_String$java_lang_Object_A(expression, errorMessageTemplate, errorMessageArgs);
                }
                else if (((typeof expression === 'boolean') || expression === null) && ((errorMessageTemplate != null) || errorMessageTemplate === null) && errorMessageArgs === undefined) {
                    return javaemul.internal.InternalPreconditions.checkCriticalArgument$boolean$java_lang_Object(expression, errorMessageTemplate);
                }
                else if (((typeof expression === 'boolean') || expression === null) && errorMessageTemplate === undefined && errorMessageArgs === undefined) {
                    return javaemul.internal.InternalPreconditions.checkCriticalArgument$boolean(expression);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Ensures the truth of an expression involving the state of the calling
             * instance, but not involving any parameters to the calling method.
             *
             * @param {boolean} expression
             * a boolean expression
             * @throws IllegalStateException
             * if {@code expression} is false
             */
            InternalPreconditions.checkState$boolean = function (expression) {
                if (InternalPreconditions.API_CHECK) {
                    InternalPreconditions.checkCritcalState(expression);
                }
                else if (InternalPreconditions.CHECKED_MODE) {
                    try {
                        InternalPreconditions.checkCritcalState(expression);
                    }
                    catch (e) {
                        throw Object.defineProperty(new Error(e.message), '__class', { configurable: true, value: 'java.lang.AssertionError' });
                    }
                    ;
                }
            };
            /**
             * Ensures the truth of an expression involving the state of the calling
             * instance, but not involving any parameters to the calling method.
             * <p>
             * For cases where failing fast is pretty important and not failing early
             * could cause bugs that are much harder to debug.
             * @param {boolean} expression
             */
            InternalPreconditions.checkCritcalState = function (expression) {
                if (!expression) {
                    throw Object.defineProperty(new Error(), '__class', { configurable: true, value: 'java.lang.IllegalStateException' });
                }
            };
            /**
             * Ensures the truth of an expression involving the state of the calling
             * instance, but not involving any parameters to the calling method.
             * @param {boolean} expression
             * @param {*} errorMessage
             */
            InternalPreconditions.checkState$boolean$java_lang_Object = function (expression, errorMessage) {
                if (InternalPreconditions.API_CHECK) {
                    InternalPreconditions.checkCriticalState(expression, errorMessage);
                }
                else if (InternalPreconditions.CHECKED_MODE) {
                    try {
                        InternalPreconditions.checkCriticalState(expression, errorMessage);
                    }
                    catch (e) {
                        throw Object.defineProperty(new Error(e.message), '__class', { configurable: true, value: 'java.lang.AssertionError' });
                    }
                    ;
                }
            };
            /**
             * Ensures the truth of an expression involving the state of the calling
             * instance, but not involving any parameters to the calling method.
             * @param {boolean} expression
             * @param {*} errorMessage
             */
            InternalPreconditions.checkState = function (expression, errorMessage) {
                if (((typeof expression === 'boolean') || expression === null) && ((errorMessage != null) || errorMessage === null)) {
                    return javaemul.internal.InternalPreconditions.checkState$boolean$java_lang_Object(expression, errorMessage);
                }
                else if (((typeof expression === 'boolean') || expression === null) && errorMessage === undefined) {
                    return javaemul.internal.InternalPreconditions.checkState$boolean(expression);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Ensures the truth of an expression involving the state of the calling
             * instance, but not involving any parameters to the calling method.
             * @param {boolean} expression
             * @param {*} errorMessage
             */
            InternalPreconditions.checkCriticalState = function (expression, errorMessage) {
                if (!expression) {
                    throw Object.defineProperty(new Error(/* valueOf */ new String(errorMessage).toString()), '__class', { configurable: true, value: 'java.lang.IllegalStateException' });
                }
            };
            /**
             * Ensures that an object reference passed as a parameter to the calling
             * method is not null.
             * @param {*} reference
             * @return {*}
             */
            InternalPreconditions.checkNotNull$java_lang_Object = function (reference) {
                if (InternalPreconditions.API_CHECK) {
                    InternalPreconditions.checkCriticalNotNull(reference);
                }
                else if (InternalPreconditions.CHECKED_MODE) {
                    try {
                        InternalPreconditions.checkCriticalNotNull(reference);
                    }
                    catch (e) {
                        throw Object.defineProperty(new Error(e.message), '__class', { configurable: true, value: 'java.lang.AssertionError' });
                    }
                    ;
                }
                return reference;
            };
            InternalPreconditions.checkCriticalNotNull$java_lang_Object = function (reference) {
                if (reference == null) {
                    throw Object.defineProperty(new Error(), '__class', { configurable: true, value: 'java.lang.NullPointerException' });
                }
                return reference;
            };
            /**
             * Ensures that an object reference passed as a parameter to the calling
             * method is not null.
             * @param {*} reference
             * @param {*} errorMessage
             */
            InternalPreconditions.checkNotNull$java_lang_Object$java_lang_Object = function (reference, errorMessage) {
                if (InternalPreconditions.API_CHECK) {
                    InternalPreconditions.checkCriticalNotNull$java_lang_Object$java_lang_Object(reference, errorMessage);
                }
                else if (InternalPreconditions.CHECKED_MODE) {
                    try {
                        InternalPreconditions.checkCriticalNotNull$java_lang_Object$java_lang_Object(reference, errorMessage);
                    }
                    catch (e) {
                        throw Object.defineProperty(new Error(e.message), '__class', { configurable: true, value: 'java.lang.AssertionError' });
                    }
                    ;
                }
            };
            /**
             * Ensures that an object reference passed as a parameter to the calling
             * method is not null.
             * @param {*} reference
             * @param {*} errorMessage
             */
            InternalPreconditions.checkNotNull = function (reference, errorMessage) {
                if (((reference != null) || reference === null) && ((errorMessage != null) || errorMessage === null)) {
                    return javaemul.internal.InternalPreconditions.checkNotNull$java_lang_Object$java_lang_Object(reference, errorMessage);
                }
                else if (((reference != null) || reference === null) && errorMessage === undefined) {
                    return javaemul.internal.InternalPreconditions.checkNotNull$java_lang_Object(reference);
                }
                else
                    throw new Error('invalid overload');
            };
            InternalPreconditions.checkCriticalNotNull$java_lang_Object$java_lang_Object = function (reference, errorMessage) {
                if (reference == null) {
                    throw Object.defineProperty(new Error(/* valueOf */ new String(errorMessage).toString()), '__class', { configurable: true, value: 'java.lang.NullPointerException' });
                }
            };
            InternalPreconditions.checkCriticalNotNull = function (reference, errorMessage) {
                if (((reference != null) || reference === null) && ((errorMessage != null) || errorMessage === null)) {
                    return javaemul.internal.InternalPreconditions.checkCriticalNotNull$java_lang_Object$java_lang_Object(reference, errorMessage);
                }
                else if (((reference != null) || reference === null) && errorMessage === undefined) {
                    return javaemul.internal.InternalPreconditions.checkCriticalNotNull$java_lang_Object(reference);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Ensures that {@code size} specifies a valid array size (i.e. non-negative).
             * @param {number} size
             */
            InternalPreconditions.checkArraySize = function (size) {
                if (InternalPreconditions.API_CHECK) {
                    InternalPreconditions.checkCriticalArraySize(size);
                }
                else if (InternalPreconditions.CHECKED_MODE) {
                    try {
                        InternalPreconditions.checkCriticalArraySize(size);
                    }
                    catch (e) {
                        throw Object.defineProperty(new Error(e.message), '__class', { configurable: true, value: 'java.lang.AssertionError' });
                    }
                    ;
                }
            };
            InternalPreconditions.checkCriticalArraySize = function (size) {
                if (size < 0) {
                    throw Object.defineProperty(new Error("Negative array size: " + size), '__class', { configurable: true, value: 'java.lang.NegativeArraySizeException' });
                }
            };
            /**
             * Ensures that {@code index} specifies a valid <i>element</i> in an array,
             * list or string of size {@code size}. An element index may range from zero,
             * inclusive, to {@code size}, exclusive.
             * @param {number} index
             * @param {number} size
             */
            InternalPreconditions.checkElementIndex = function (index, size) {
                if (InternalPreconditions.BOUND_CHECK) {
                    InternalPreconditions.checkCriticalElementIndex(index, size);
                }
                else if (InternalPreconditions.CHECKED_MODE) {
                    try {
                        InternalPreconditions.checkCriticalElementIndex(index, size);
                    }
                    catch (e) {
                        throw Object.defineProperty(new Error(e.message), '__class', { configurable: true, value: 'java.lang.AssertionError' });
                    }
                    ;
                }
            };
            InternalPreconditions.checkCriticalElementIndex = function (index, size) {
                if (index < 0 || index >= size) {
                    throw Object.defineProperty(new Error("Index: " + index + ", Size: " + size), '__class', { configurable: true, value: 'java.lang.IndexOutOfBoundsException' });
                }
            };
            /**
             * Ensures that {@code index} specifies a valid <i>position</i> in an array,
             * list or string of size {@code size}. A position index may range from zero
             * to {@code size}, inclusive.
             * @param {number} index
             * @param {number} size
             */
            InternalPreconditions.checkPositionIndex = function (index, size) {
                if (InternalPreconditions.BOUND_CHECK) {
                    InternalPreconditions.checkCriticalPositionIndex(index, size);
                }
                else if (InternalPreconditions.CHECKED_MODE) {
                    try {
                        InternalPreconditions.checkCriticalPositionIndex(index, size);
                    }
                    catch (e) {
                        throw Object.defineProperty(new Error(e.message), '__class', { configurable: true, value: 'java.lang.AssertionError' });
                    }
                    ;
                }
            };
            InternalPreconditions.checkCriticalPositionIndex = function (index, size) {
                if (index < 0 || index > size) {
                    throw Object.defineProperty(new Error("Index: " + index + ", Size: " + size), '__class', { configurable: true, value: 'java.lang.IndexOutOfBoundsException' });
                }
            };
            /**
             * Ensures that {@code start} and {@code end} specify a valid <i>positions</i>
             * in an array, list or string of size {@code size}, and are in order. A
             * position index may range from zero to {@code size}, inclusive.
             * @param {number} start
             * @param {number} end
             * @param {number} size
             */
            InternalPreconditions.checkPositionIndexes = function (start, end, size) {
                if (InternalPreconditions.BOUND_CHECK) {
                    InternalPreconditions.checkCriticalPositionIndexes(start, end, size);
                }
                else if (InternalPreconditions.CHECKED_MODE) {
                    try {
                        InternalPreconditions.checkCriticalPositionIndexes(start, end, size);
                    }
                    catch (e) {
                        throw Object.defineProperty(new Error(e.message), '__class', { configurable: true, value: 'java.lang.AssertionError' });
                    }
                    ;
                }
            };
            /**
             * Ensures that {@code start} and {@code end} specify a valid <i>positions</i>
             * in an array, list or string of size {@code size}, and are in order. A
             * position index may range from zero to {@code size}, inclusive.
             * @param {number} start
             * @param {number} end
             * @param {number} size
             */
            InternalPreconditions.checkCriticalPositionIndexes = function (start, end, size) {
                if (start < 0) {
                    throw Object.defineProperty(new Error("fromIndex: " + start + " < 0"), '__class', { configurable: true, value: 'java.lang.IndexOutOfBoundsException' });
                }
                if (end > size) {
                    throw Object.defineProperty(new Error("toIndex: " + end + " > size " + size), '__class', { configurable: true, value: 'java.lang.IndexOutOfBoundsException' });
                }
                if (start > end) {
                    throw Object.defineProperty(new Error("fromIndex: " + start + " > toIndex: " + end), '__class', { configurable: true, value: 'java.lang.IllegalArgumentException' });
                }
            };
            /**
             * Checks that bounds are correct.
             *
             * @throw StringIndexOutOfBoundsException if the range is not legal
             * @param {number} start
             * @param {number} end
             * @param {number} size
             */
            InternalPreconditions.checkStringBounds = function (start, end, size) {
                if (start < 0) {
                    throw Object.defineProperty(new Error("fromIndex: " + start + " < 0"), '__class', { configurable: true, value: 'java.lang.StringIndexOutOfBoundsException' });
                }
                if (end > size) {
                    throw Object.defineProperty(new Error("toIndex: " + end + " > size " + size), '__class', { configurable: true, value: 'java.lang.StringIndexOutOfBoundsException' });
                }
                if (end < start) {
                    throw Object.defineProperty(new Error("fromIndex: " + start + " > toIndex: " + end), '__class', { configurable: true, value: 'java.lang.StringIndexOutOfBoundsException' });
                }
            };
            /**
             * Substitutes each {@code %s} in {@code template} with an argument. These are
             * matched by position: the first {@code %s} gets {@code args[0]}, etc. If
             * there are more arguments than placeholders, the unmatched arguments will be
             * appended to the end of the formatted message in square braces.
             * @param {string} template
             * @param {Array} args
             * @return {string}
             * @private
             */
            InternalPreconditions.format = function (template) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                if (template == null) {
                    return null;
                }
                for (var i = 0; i < args.length; i++) {
                    template = (template).replace(template, args[i]);
                }
                return template;
            };
            return InternalPreconditions;
        }());
        InternalPreconditions.CHECKED_MODE = false;
        InternalPreconditions.TYPE_CHECK = false;
        InternalPreconditions.API_CHECK = false;
        InternalPreconditions.BOUND_CHECK = false;
        internal.InternalPreconditions = InternalPreconditions;
        InternalPreconditions["__class"] = "javaemul.internal.InternalPreconditions";
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Math utility methods and constants.
         */
        var MathHelper = (function () {
            function MathHelper() {
            }
            MathHelper.EPSILON_$LI$ = function () { if (MathHelper.EPSILON == null)
                MathHelper.EPSILON = MathHelper.pow(2, -52); return MathHelper.EPSILON; };
            ;
            MathHelper.MAX_VALUE_$LI$ = function () { if (MathHelper.MAX_VALUE == null)
                MathHelper.MAX_VALUE = (2 - MathHelper.EPSILON_$LI$()) * MathHelper.pow(2, 1023); return MathHelper.MAX_VALUE; };
            ;
            MathHelper.MIN_VALUE_$LI$ = function () { if (MathHelper.MIN_VALUE == null)
                MathHelper.MIN_VALUE = MathHelper.pow(2, -1022); return MathHelper.MIN_VALUE; };
            ;
            MathHelper.nextDown = function (x) {
                return -MathHelper.nextUp(-x);
            };
            MathHelper.ulp = function (x) {
                return x < 0 ? MathHelper.nextUp(x) - x : x - (-MathHelper.nextUp(-x));
            };
            MathHelper.nextUp = function (x) {
                if (x !== x) {
                    return x;
                }
                if (x === (-1 / 0 | 0)) {
                    return -MathHelper.MAX_VALUE_$LI$();
                }
                if (x === (+1 / 0 | 0)) {
                    return (+1 / 0 | 0);
                }
                if (x === +MathHelper.MAX_VALUE_$LI$()) {
                    return (+1 / 0 | 0);
                }
                var y = x * (x < 0 ? 1 - MathHelper.EPSILON_$LI$() / 2 : 1 + MathHelper.EPSILON_$LI$());
                if (y === x) {
                    y = MathHelper.MIN_VALUE_$LI$() * MathHelper.EPSILON_$LI$() > 0 ? x + MathHelper.MIN_VALUE_$LI$() * MathHelper.EPSILON_$LI$() : x + MathHelper.MIN_VALUE_$LI$();
                }
                if (y === (+1 / 0 | 0)) {
                    y = +MathHelper.MAX_VALUE_$LI$();
                }
                var b = x + (y - x) / 2;
                if (x < b && b < y) {
                    y = b;
                }
                var c = (y + x) / 2;
                if (x < c && c < y) {
                    y = c;
                }
                return y === 0 ? -0 : y;
            };
            MathHelper.PI_OVER_180_$LI$ = function () { if (MathHelper.PI_OVER_180 == null)
                MathHelper.PI_OVER_180 = MathHelper.PI / 180.0; return MathHelper.PI_OVER_180; };
            ;
            MathHelper.PI_UNDER_180_$LI$ = function () { if (MathHelper.PI_UNDER_180 == null)
                MathHelper.PI_UNDER_180 = 180.0 / MathHelper.PI; return MathHelper.PI_UNDER_180; };
            ;
            MathHelper.abs$double = function (x) {
                return x <= 0 ? 0.0 - x : x;
            };
            MathHelper.abs$float = function (x) {
                return MathHelper.abs$double(x);
            };
            MathHelper.abs$int = function (x) {
                return x < 0 ? -x : x;
            };
            MathHelper.abs = function (x) {
                if (((typeof x === 'number') || x === null)) {
                    return javaemul.internal.MathHelper.abs$int(x);
                }
                else if (((typeof x === 'number') || x === null)) {
                    return javaemul.internal.MathHelper.abs$long(x);
                }
                else if (((typeof x === 'number') || x === null)) {
                    return javaemul.internal.MathHelper.abs$float(x);
                }
                else if (((typeof x === 'number') || x === null)) {
                    return javaemul.internal.MathHelper.abs$double(x);
                }
                else
                    throw new Error('invalid overload');
            };
            MathHelper.abs$long = function (x) {
                return x < 0 ? -x : x;
            };
            MathHelper.acos = function (x) {
                return Math.acos(x);
            };
            MathHelper.asin = function (x) {
                return Math.asin(x);
            };
            MathHelper.atan = function (x) {
                return Math.atan(x);
            };
            MathHelper.atan2 = function (y, x) {
                return Math.atan2(y, x);
            };
            MathHelper.cbrt = function (x) {
                return MathHelper.pow(x, 1.0 / 3.0);
            };
            MathHelper.ceil = function (x) {
                return Math.ceil(x);
            };
            MathHelper.copySign$double$double = function (magnitude, sign) {
                if (sign < 0) {
                    return (magnitude < 0) ? magnitude : -magnitude;
                }
                else {
                    return (magnitude > 0) ? magnitude : -magnitude;
                }
            };
            MathHelper.copySign$float$float = function (magnitude, sign) {
                return (MathHelper.copySign$double$double(magnitude, sign));
            };
            MathHelper.copySign = function (magnitude, sign) {
                if (((typeof magnitude === 'number') || magnitude === null) && ((typeof sign === 'number') || sign === null)) {
                    return javaemul.internal.MathHelper.copySign$float$float(magnitude, sign);
                }
                else if (((typeof magnitude === 'number') || magnitude === null) && ((typeof sign === 'number') || sign === null)) {
                    return javaemul.internal.MathHelper.copySign$double$double(magnitude, sign);
                }
                else
                    throw new Error('invalid overload');
            };
            MathHelper.cos = function (x) {
                return Math.cos(x);
            };
            MathHelper.cosh = function (x) {
                return (MathHelper.exp(x) + MathHelper.exp(-x)) / 2.0;
            };
            MathHelper.exp = function (x) {
                return Math.exp(x);
            };
            MathHelper.expm1 = function (d) {
                if (d === 0.0 || isNaN(d)) {
                    return d;
                }
                else if (!(function (value) { return Number.NEGATIVE_INFINITY === value || Number.POSITIVE_INFINITY === value; })(d)) {
                    if (d < 0.0) {
                        return -1.0;
                    }
                    else {
                        return javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
                    }
                }
                return MathHelper.exp(d) + 1.0;
            };
            MathHelper.floor = function (x) {
                return Math.floor(x);
            };
            MathHelper.hypot = function (x, y) {
                return MathHelper.sqrt(x * x + y * y);
            };
            MathHelper.log = function (x) {
                return Math.log(x);
            };
            MathHelper.log10 = function (x) {
                return Math.log(x) * Math.LOG10E;
            };
            MathHelper.log1p = function (x) {
                return MathHelper.log(x + 1.0);
            };
            MathHelper.max$double$double = function (x, y) {
                return Math.max(x, y);
            };
            MathHelper.max$float$float = function (x, y) {
                return Math.max(x, y);
            };
            MathHelper.max$int$int = function (x, y) {
                return x > y ? x : y;
            };
            MathHelper.max = function (x, y) {
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return javaemul.internal.MathHelper.max$int$int(x, y);
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return javaemul.internal.MathHelper.max$long$long(x, y);
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return javaemul.internal.MathHelper.max$float$float(x, y);
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return javaemul.internal.MathHelper.max$double$double(x, y);
                }
                else
                    throw new Error('invalid overload');
            };
            MathHelper.max$long$long = function (x, y) {
                return x > y ? x : y;
            };
            MathHelper.min$double$double = function (x, y) {
                return Math.min(x, y);
            };
            MathHelper.min$float$float = function (x, y) {
                return Math.min(x, y);
            };
            MathHelper.min$int$int = function (x, y) {
                return x < y ? x : y;
            };
            MathHelper.min = function (x, y) {
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return javaemul.internal.MathHelper.min$int$int(x, y);
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return javaemul.internal.MathHelper.min$long$long(x, y);
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return javaemul.internal.MathHelper.min$float$float(x, y);
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return javaemul.internal.MathHelper.min$double$double(x, y);
                }
                else
                    throw new Error('invalid overload');
            };
            MathHelper.min$long$long = function (x, y) {
                return x < y ? x : y;
            };
            MathHelper.pow = function (x, exp) {
                return Math.pow(x, exp);
            };
            MathHelper.random = function () {
                return Math.random();
            };
            MathHelper.rint = function (d) {
                if (isNaN(d)) {
                    return d;
                }
                else if ((function (value) { return Number.NEGATIVE_INFINITY === value || Number.POSITIVE_INFINITY === value; })(d)) {
                    return d;
                }
                else if (d === 0.0) {
                    return d;
                }
                else {
                    return MathHelper.round$double(d);
                }
            };
            MathHelper.round$double = function (x) {
                return Math.floor(Math.round(x));
            };
            MathHelper.round$float = function (x) {
                var roundedValue = Math.round(x);
                return MathHelper.unsafeCastToInt(roundedValue);
            };
            MathHelper.round = function (x) {
                if (((typeof x === 'number') || x === null)) {
                    return javaemul.internal.MathHelper.round$float(x);
                }
                else if (((typeof x === 'number') || x === null)) {
                    return javaemul.internal.MathHelper.round$double(x);
                }
                else
                    throw new Error('invalid overload');
            };
            MathHelper.unsafeCastToInt = function (d) {
                return d;
            };
            MathHelper.scalb$double$int = function (d, scaleFactor) {
                if (scaleFactor >= 31 || scaleFactor <= -31) {
                    return d * MathHelper.pow(2, scaleFactor);
                }
                else if (scaleFactor > 0) {
                    return d * (1 << scaleFactor);
                }
                else if (scaleFactor === 0) {
                    return d;
                }
                else {
                    return d * 1.0 / (1 << -scaleFactor);
                }
            };
            MathHelper.scalb$float$int = function (f, scaleFactor) {
                if (scaleFactor >= 31 || scaleFactor <= -31) {
                    return f * MathHelper.pow(2, scaleFactor);
                }
                else if (scaleFactor > 0) {
                    return f * (1 << scaleFactor);
                }
                else if (scaleFactor === 0) {
                    return f;
                }
                else {
                    return f * 1.0 / (1 << -scaleFactor);
                }
            };
            MathHelper.scalb = function (f, scaleFactor) {
                if (((typeof f === 'number') || f === null) && ((typeof scaleFactor === 'number') || scaleFactor === null)) {
                    return javaemul.internal.MathHelper.scalb$float$int(f, scaleFactor);
                }
                else if (((typeof f === 'number') || f === null) && ((typeof scaleFactor === 'number') || scaleFactor === null)) {
                    return javaemul.internal.MathHelper.scalb$double$int(f, scaleFactor);
                }
                else
                    throw new Error('invalid overload');
            };
            MathHelper.signum$double = function (d) {
                if (d > 0.0) {
                    return 1.0;
                }
                else if (d < 0.0) {
                    return -1.0;
                }
                else {
                    return 0.0;
                }
            };
            MathHelper.signum$float = function (f) {
                if (f > 0.0) {
                    return 1.0;
                }
                else if (f < 0.0) {
                    return -1.0;
                }
                else {
                    return 0.0;
                }
            };
            MathHelper.signum = function (f) {
                if (((typeof f === 'number') || f === null)) {
                    return javaemul.internal.MathHelper.signum$float(f);
                }
                else if (((typeof f === 'number') || f === null)) {
                    return javaemul.internal.MathHelper.signum$double(f);
                }
                else
                    throw new Error('invalid overload');
            };
            MathHelper.sin = function (x) {
                return Math.sin(x);
            };
            MathHelper.sinh = function (x) {
                return (MathHelper.exp(x) - MathHelper.exp(-x)) / 2.0;
            };
            MathHelper.sqrt = function (x) {
                return Math.sqrt(x);
            };
            MathHelper.tan = function (x) {
                return Math.tan(x);
            };
            MathHelper.tanh = function (x) {
                if (x === Infinity) {
                    return 1.0;
                }
                else if (x === -Infinity) {
                    return -1.0;
                }
                var e2x = MathHelper.exp(2.0 * x);
                return (e2x - 1) / (e2x + 1);
            };
            MathHelper.toDegrees = function (x) {
                return x * MathHelper.PI_UNDER_180_$LI$();
            };
            MathHelper.toRadians = function (x) {
                return x * MathHelper.PI_OVER_180_$LI$();
            };
            MathHelper.IEEEremainder = function (f1, f2) {
                var r = Math.abs(f1 % f2);
                if (isNaN(r) || r === f2 || r <= Math.abs(f2) / 2.0) {
                    return r;
                }
                else {
                    return (function (f) { if (f > 0) {
                        return 1;
                    }
                    else if (f < 0) {
                        return -1;
                    }
                    else {
                        return 0;
                    } })(f1) * (r - f2);
                }
            };
            return MathHelper;
        }());
        MathHelper.E = 2.718281828459045;
        MathHelper.PI = 3.141592653589793;
        internal.MathHelper = MathHelper;
        MathHelper["__class"] = "javaemul.internal.MathHelper";
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Abstract base class for numeric wrapper classes.
         */
        var NumberHelper = (function () {
            function NumberHelper() {
            }
            /**
             * @skip
             *
             * This function will determine the radix that the string is expressed
             * in based on the parsing rules defined in the Javadocs for
             * Integer.decode() and invoke __parseAndValidateInt.
             * @param {string} s
             * @param {number} lowerBound
             * @param {number} upperBound
             * @return {number}
             */
            NumberHelper.__decodeAndValidateInt = function (s, lowerBound, upperBound) {
                var decode = NumberHelper.__decodeNumberString(s);
                return NumberHelper.__parseAndValidateInt(decode.payload, decode.radix, lowerBound, upperBound);
            };
            NumberHelper.__decodeNumberString = function (s) {
                var negative;
                if ((function (str, searchString, position) {
                    if (position === void 0) { position = 0; }
                    return str.substr(position, searchString.length) === searchString;
                })(s, "-")) {
                    negative = true;
                    s = s.substring(1);
                }
                else {
                    negative = false;
                    if ((function (str, searchString, position) {
                        if (position === void 0) { position = 0; }
                        return str.substr(position, searchString.length) === searchString;
                    })(s, "+")) {
                        s = s.substring(1);
                    }
                }
                var radix;
                if ((function (str, searchString, position) {
                    if (position === void 0) { position = 0; }
                    return str.substr(position, searchString.length) === searchString;
                })(s, "0x") || (function (str, searchString, position) {
                    if (position === void 0) { position = 0; }
                    return str.substr(position, searchString.length) === searchString;
                })(s, "0X")) {
                    s = s.substring(2);
                    radix = 16;
                }
                else if ((function (str, searchString, position) {
                    if (position === void 0) { position = 0; }
                    return str.substr(position, searchString.length) === searchString;
                })(s, "#")) {
                    s = s.substring(1);
                    radix = 16;
                }
                else if ((function (str, searchString, position) {
                    if (position === void 0) { position = 0; }
                    return str.substr(position, searchString.length) === searchString;
                })(s, "0")) {
                    radix = 8;
                }
                else {
                    radix = 10;
                }
                if (negative) {
                    s = "-" + s;
                }
                return new NumberHelper.__Decode(radix, s);
            };
            /**
             * @skip
             *
             * This function contains common logic for parsing a String as a
             * floating- point number and validating the range.
             * @param {string} s
             * @return {number}
             */
            NumberHelper.__parseAndValidateDouble = function (s) {
                if (!NumberHelper.__isValidDouble(s)) {
                    throw javaemul.internal.ExceptionHelper.forInputString(s);
                }
                return parseFloat(s);
            };
            /**
             * @skip
             *
             * This function contains common logic for parsing a String in a given
             * radix and validating the result.
             * @param {string} s
             * @param {number} radix
             * @param {number} lowerBound
             * @param {number} upperBound
             * @return {number}
             */
            NumberHelper.__parseAndValidateInt = function (s, radix, lowerBound, upperBound) {
                if (s == null) {
                    throw javaemul.internal.ExceptionHelper.forNullInputString();
                }
                if (radix < javaemul.internal.CharacterHelper.MIN_RADIX || radix > javaemul.internal.CharacterHelper.MAX_RADIX) {
                    throw javaemul.internal.ExceptionHelper.forRadix(radix);
                }
                var length = s.length;
                var startIndex = (length > 0) && ((function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(s.charAt(0)) == '-'.charCodeAt(0) || (function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(s.charAt(0)) == '+'.charCodeAt(0)) ? 1 : 0;
                for (var i = startIndex; i < length; i++) {
                    if (javaemul.internal.CharacterHelper.digit(s.charAt(i), radix) === -1) {
                        throw javaemul.internal.ExceptionHelper.forInputString(s);
                    }
                }
                var toReturn = (parseInt(s, radix) | 0);
                var isTooLow = toReturn < lowerBound;
                if (javaemul.internal.DoubleHelper.isNaN(toReturn)) {
                    throw javaemul.internal.ExceptionHelper.forInputString(s);
                }
                else if (isTooLow || toReturn > upperBound) {
                    throw javaemul.internal.ExceptionHelper.forInputString(s);
                }
                return toReturn;
            };
            /**
             * @skip
             *
             * This function contains common logic for parsing a String in a given
             * radix and validating the result.
             * @param {string} s
             * @param {number} radix
             * @return {number}
             */
            NumberHelper.__parseAndValidateLong = function (s, radix) {
                if (s == null) {
                    throw javaemul.internal.ExceptionHelper.forNullInputString();
                }
                if (radix < javaemul.internal.CharacterHelper.MIN_RADIX || radix > javaemul.internal.CharacterHelper.MAX_RADIX) {
                    throw javaemul.internal.ExceptionHelper.forRadix(radix);
                }
                var orig = s;
                var length = s.length;
                var negative = false;
                if (length > 0) {
                    var c = s.charAt(0);
                    if ((function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(c) == '-'.charCodeAt(0) || (function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(c) == '+'.charCodeAt(0)) {
                        s = s.substring(1);
                        length--;
                        negative = ((function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(c) == '-'.charCodeAt(0));
                    }
                }
                if (length === 0) {
                    throw javaemul.internal.ExceptionHelper.forInputString(orig);
                }
                while ((s.length > 0 && (function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(s.charAt(0)) == '0'.charCodeAt(0))) {
                    s = s.substring(1);
                    length--;
                }
                ;
                if (length > NumberHelper.__ParseLong.maxLengthForRadix_$LI$()[radix]) {
                    throw javaemul.internal.ExceptionHelper.forInputString(orig);
                }
                for (var i = 0; i < length; i++) {
                    if (javaemul.internal.CharacterHelper.digit(s.charAt(i), radix) === -1) {
                        throw javaemul.internal.ExceptionHelper.forInputString(orig);
                    }
                }
                var toReturn = 0;
                var maxDigits = NumberHelper.__ParseLong.maxDigitsForRadix_$LI$()[radix];
                var radixPower = NumberHelper.__ParseLong.maxDigitsRadixPower_$LI$()[radix];
                var minValue = -NumberHelper.__ParseLong.maxValueForRadix_$LI$()[radix];
                var firstTime = true;
                var head = length % maxDigits;
                if (head > 0) {
                    toReturn = -(parseInt(s.substring(0, head), radix) | 0);
                    s = s.substring(head);
                    length -= head;
                    firstTime = false;
                }
                while ((length >= maxDigits)) {
                    head = (parseInt(s.substring(0, maxDigits), radix) | 0);
                    s = s.substring(maxDigits);
                    length -= maxDigits;
                    if (!firstTime) {
                        if (toReturn < minValue) {
                            throw javaemul.internal.ExceptionHelper.forInputString(orig);
                        }
                        toReturn *= radixPower;
                    }
                    else {
                        firstTime = false;
                    }
                    toReturn -= head;
                }
                ;
                if (toReturn > 0) {
                    throw javaemul.internal.ExceptionHelper.forInputString(orig);
                }
                if (!negative) {
                    toReturn = -toReturn;
                    if (toReturn < 0) {
                        throw javaemul.internal.ExceptionHelper.forInputString(orig);
                    }
                }
                return toReturn;
            };
            /**
             * @skip
             *
             * @param {string} str
             * @return {boolean} {@code true} if the string matches the float format, {@code false}
             * otherwise
             * @private
             */
            NumberHelper.__isValidDouble = function (str) {
                if (NumberHelper.floatRegex == null) {
                    NumberHelper.floatRegex = NumberHelper.createFloatRegex();
                }
                return NumberHelper.floatRegex.test(str);
            };
            NumberHelper.createFloatRegex = function () {
                return /^\s*[+-]?(NaN|Infinity|((\d+\.?\d*)|(\.\d+))([eE][+-]?\d+)?[dDfF]?)\s*$/;
            };
            return NumberHelper;
        }());
        internal.NumberHelper = NumberHelper;
        NumberHelper["__class"] = "javaemul.internal.NumberHelper";
        NumberHelper["__interfaces"] = ["java.io.Serializable"];
        (function (NumberHelper) {
            var __Decode = (function () {
                function __Decode(radix, payload) {
                    this.payload = null;
                    this.radix = 0;
                    this.radix = radix;
                    this.payload = payload;
                }
                return __Decode;
            }());
            NumberHelper.__Decode = __Decode;
            __Decode["__class"] = "javaemul.internal.NumberHelper.__Decode";
            /**
             * Use nested class to avoid clinit on outer.
             */
            var __ParseLong = (function () {
                function __ParseLong() {
                }
                __ParseLong.__static_initialize = function () { if (!__ParseLong.__static_initialized) {
                    __ParseLong.__static_initialized = true;
                    __ParseLong.__static_initializer_0();
                } };
                __ParseLong.maxDigitsForRadix_$LI$ = function () { __ParseLong.__static_initialize(); if (__ParseLong.maxDigitsForRadix == null)
                    __ParseLong.maxDigitsForRadix = [-1, -1, 30, 19, 15, 13, 11, 11, 10, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5]; return __ParseLong.maxDigitsForRadix; };
                ;
                __ParseLong.maxDigitsRadixPower_$LI$ = function () { __ParseLong.__static_initialize(); if (__ParseLong.maxDigitsRadixPower == null)
                    __ParseLong.maxDigitsRadixPower = (function (s) { var a = []; while (s-- > 0)
                        a.push(0); return a; })(37); return __ParseLong.maxDigitsRadixPower; };
                ;
                __ParseLong.maxLengthForRadix_$LI$ = function () { __ParseLong.__static_initialize(); if (__ParseLong.maxLengthForRadix == null)
                    __ParseLong.maxLengthForRadix = [-1, -1, 63, 40, 32, 28, 25, 23, 21, 20, 19, 19, 18, 18, 17, 17, 16, 16, 16, 15, 15, 15, 15, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13]; return __ParseLong.maxLengthForRadix; };
                ;
                __ParseLong.maxValueForRadix_$LI$ = function () { __ParseLong.__static_initialize(); if (__ParseLong.maxValueForRadix == null)
                    __ParseLong.maxValueForRadix = (function (s) { var a = []; while (s-- > 0)
                        a.push(0); return a; })(37); return __ParseLong.maxValueForRadix; };
                ;
                __ParseLong.__static_initializer_0 = function () {
                    for (var i = 2; i <= 36; i++) {
                        __ParseLong.maxDigitsRadixPower_$LI$()[i] = (Math.pow(i, __ParseLong.maxDigitsForRadix_$LI$()[i]) | 0);
                        __ParseLong.maxValueForRadix_$LI$()[i] = Math.floor(9223372036854775807 / __ParseLong.maxDigitsRadixPower_$LI$()[i]);
                    }
                };
                return __ParseLong;
            }());
            __ParseLong.__static_initialized = false;
            NumberHelper.__ParseLong = __ParseLong;
            __ParseLong["__class"] = "javaemul.internal.NumberHelper.__ParseLong";
        })(NumberHelper = internal.NumberHelper || (internal.NumberHelper = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
var sun;
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var ChainEnd = (function () {
                function ChainEnd(first, partner) {
                    this.head = null;
                    this.tail = null;
                    this.partner = null;
                    this.etag = 0;
                    this.head = first;
                    this.tail = first;
                    this.partner = partner;
                    this.etag = first.getEdgeTag();
                }
                ChainEnd.prototype.getChain = function () {
                    return this.head;
                };
                ChainEnd.prototype.setOtherEnd = function (partner) {
                    this.partner = partner;
                };
                ChainEnd.prototype.getPartner = function () {
                    return this.partner;
                };
                ChainEnd.prototype.linkTo = function (that) {
                    if (this.etag === sun.awt.geom.AreaOp.ETAG_IGNORE || that.etag === sun.awt.geom.AreaOp.ETAG_IGNORE) {
                        throw Object.defineProperty(new Error("ChainEnd linked more than once!"), '__class', { configurable: true, value: 'java.lang.InternalError' });
                    }
                    if (this.etag === that.etag) {
                        throw Object.defineProperty(new Error("Linking chains of the same type!"), '__class', { configurable: true, value: 'java.lang.InternalError' });
                    }
                    var enter;
                    var exit;
                    if (this.etag === sun.awt.geom.AreaOp.ETAG_ENTER) {
                        enter = this;
                        exit = that;
                    }
                    else {
                        enter = that;
                        exit = this;
                    }
                    this.etag = sun.awt.geom.AreaOp.ETAG_IGNORE;
                    that.etag = sun.awt.geom.AreaOp.ETAG_IGNORE;
                    enter.tail.setNext(exit.head);
                    enter.tail = exit.tail;
                    if (this.partner === that) {
                        return enter.head;
                    }
                    var otherenter = exit.partner;
                    var otherexit = enter.partner;
                    otherenter.partner = otherexit;
                    otherexit.partner = otherenter;
                    if (enter.head.getYTop() < otherenter.head.getYTop()) {
                        enter.tail.setNext(otherenter.head);
                        otherenter.head = enter.head;
                    }
                    else {
                        otherexit.tail.setNext(enter.head);
                        otherexit.tail = enter.tail;
                    }
                    return null;
                };
                ChainEnd.prototype.addLink = function (newlink) {
                    if (this.etag === sun.awt.geom.AreaOp.ETAG_ENTER) {
                        this.tail.setNext(newlink);
                        this.tail = newlink;
                    }
                    else {
                        newlink.setNext(this.head);
                        this.head = newlink;
                    }
                };
                ChainEnd.prototype.getX = function () {
                    if (this.etag === sun.awt.geom.AreaOp.ETAG_ENTER) {
                        return this.tail.getXBot();
                    }
                    else {
                        return this.head.getXBot();
                    }
                };
                return ChainEnd;
            }());
            geom.ChainEnd = ChainEnd;
            ChainEnd["__class"] = "sun.awt.geom.ChainEnd";
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var Crossings = (function () {
                function Crossings(xlo, ylo, xhi, yhi) {
                    this.limit = 0;
                    this.yranges = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                    /*private*/ this.tmp = ([]);
                    this.xlo = 0;
                    this.ylo = 0;
                    this.xhi = 0;
                    this.yhi = 0;
                    this.xlo = xlo;
                    this.ylo = ylo;
                    this.xhi = xhi;
                    this.yhi = yhi;
                }
                Crossings.prototype.getXLo = function () {
                    return this.xlo;
                };
                Crossings.prototype.getYLo = function () {
                    return this.ylo;
                };
                Crossings.prototype.getXHi = function () {
                    return this.xhi;
                };
                Crossings.prototype.getYHi = function () {
                    return this.yhi;
                };
                Crossings.prototype.print = function () {
                    console.info("Crossings [");
                    console.info("  bounds = [" + this.ylo + ", " + this.yhi + "]");
                    for (var i = 0; i < this.limit; i += 2) {
                        console.info("  [" + this.yranges[i] + ", " + this.yranges[i + 1] + "]");
                    }
                    console.info("]");
                };
                Crossings.prototype.isEmpty = function () {
                    return (this.limit === 0);
                };
                Crossings.findCrossings$java_util_Vector$double$double$double$double = function (curves, xlo, ylo, xhi, yhi) {
                    var cross = new Crossings.EvenOdd(xlo, ylo, xhi, yhi);
                    var enum_ = (function (a) { var i = 0; return { nextElement: function () { return i < a.length ? a[i++] : null; }, hasMoreElements: function () { return i < a.length; } }; })(curves);
                    while ((enum_.hasMoreElements())) {
                        var c = enum_.nextElement();
                        if (c.accumulateCrossings(cross)) {
                            return null;
                        }
                    }
                    ;
                    if (Crossings.debug) {
                        cross.print();
                    }
                    return cross;
                };
                Crossings.findCrossings = function (curves, xlo, ylo, xhi, yhi) {
                    if (((curves != null && (curves instanceof Array)) || curves === null) && ((typeof xlo === 'number') || xlo === null) && ((typeof ylo === 'number') || ylo === null) && ((typeof xhi === 'number') || xhi === null) && ((typeof yhi === 'number') || yhi === null)) {
                        return sun.awt.geom.Crossings.findCrossings$java_util_Vector$double$double$double$double(curves, xlo, ylo, xhi, yhi);
                    }
                    else if (((curves != null && (curves["__interfaces"] != null && curves["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || curves.constructor != null && curves.constructor["__interfaces"] != null && curves.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || curves === null) && ((typeof xlo === 'number') || xlo === null) && ((typeof ylo === 'number') || ylo === null) && ((typeof xhi === 'number') || xhi === null) && ((typeof yhi === 'number') || yhi === null)) {
                        return sun.awt.geom.Crossings.findCrossings$java_awt_geom_PathIterator$double$double$double$double(curves, xlo, ylo, xhi, yhi);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Crossings.findCrossings$java_awt_geom_PathIterator$double$double$double$double = function (pi, xlo, ylo, xhi, yhi) {
                    var cross;
                    if (pi.getWindingRule() === PathIterator.WIND_EVEN_ODD) {
                        cross = new Crossings.EvenOdd(xlo, ylo, xhi, yhi);
                    }
                    else {
                        cross = new Crossings.NonZero(xlo, ylo, xhi, yhi);
                    }
                    var coords = (function (s) { var a = []; while (s-- > 0)
                        a.push(0); return a; })(23);
                    var movx = 0;
                    var movy = 0;
                    var curx = 0;
                    var cury = 0;
                    var newx;
                    var newy;
                    while ((!pi.isDone())) {
                        var type = pi['currentSegment$double_A'](coords);
                        switch ((type)) {
                            case PathIterator.SEG_MOVETO:
                                if (movy !== cury && cross.accumulateLine$double$double$double$double(curx, cury, movx, movy)) {
                                    return null;
                                }
                                movx = curx = coords[0];
                                movy = cury = coords[1];
                                break;
                            case PathIterator.SEG_LINETO:
                                newx = coords[0];
                                newy = coords[1];
                                if (cross.accumulateLine$double$double$double$double(curx, cury, newx, newy)) {
                                    return null;
                                }
                                curx = newx;
                                cury = newy;
                                break;
                            case PathIterator.SEG_QUADTO:
                                newx = coords[2];
                                newy = coords[3];
                                if (cross.accumulateQuad(curx, cury, coords)) {
                                    return null;
                                }
                                curx = newx;
                                cury = newy;
                                break;
                            case PathIterator.SEG_CUBICTO:
                                newx = coords[4];
                                newy = coords[5];
                                if (cross.accumulateCubic(curx, cury, coords)) {
                                    return null;
                                }
                                curx = newx;
                                cury = newy;
                                break;
                            case PathIterator.SEG_CLOSE:
                                if (movy !== cury && cross.accumulateLine$double$double$double$double(curx, cury, movx, movy)) {
                                    return null;
                                }
                                curx = movx;
                                cury = movy;
                                break;
                        }
                        pi.next();
                    }
                    ;
                    if (movy !== cury) {
                        if (cross.accumulateLine$double$double$double$double(curx, cury, movx, movy)) {
                            return null;
                        }
                    }
                    if (Crossings.debug) {
                        cross.print();
                    }
                    return cross;
                };
                Crossings.prototype.accumulateLine$double$double$double$double = function (x0, y0, x1, y1) {
                    if (y0 <= y1) {
                        return this.accumulateLine$double$double$double$double$int(x0, y0, x1, y1, 1);
                    }
                    else {
                        return this.accumulateLine$double$double$double$double$int(x1, y1, x0, y0, -1);
                    }
                };
                Crossings.prototype.accumulateLine$double$double$double$double$int = function (x0, y0, x1, y1, direction) {
                    if (this.yhi <= y0 || this.ylo >= y1) {
                        return false;
                    }
                    if (x0 >= this.xhi && x1 >= this.xhi) {
                        return false;
                    }
                    if (y0 === y1) {
                        return (x0 >= this.xlo || x1 >= this.xlo);
                    }
                    var xstart;
                    var ystart;
                    var xend;
                    var yend;
                    var dx = (x1 - x0);
                    var dy = (y1 - y0);
                    if (y0 < this.ylo) {
                        xstart = x0 + (this.ylo - y0) * dx / dy;
                        ystart = this.ylo;
                    }
                    else {
                        xstart = x0;
                        ystart = y0;
                    }
                    if (this.yhi < y1) {
                        xend = x0 + (this.yhi - y0) * dx / dy;
                        yend = this.yhi;
                    }
                    else {
                        xend = x1;
                        yend = y1;
                    }
                    if (xstart >= this.xhi && xend >= this.xhi) {
                        return false;
                    }
                    if (xstart > this.xlo || xend > this.xlo) {
                        return true;
                    }
                    this.record(ystart, yend, direction);
                    return false;
                };
                Crossings.prototype.accumulateLine = function (x0, y0, x1, y1, direction) {
                    if (((typeof x0 === 'number') || x0 === null) && ((typeof y0 === 'number') || y0 === null) && ((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof direction === 'number') || direction === null)) {
                        return this.accumulateLine$double$double$double$double$int(x0, y0, x1, y1, direction);
                    }
                    else if (((typeof x0 === 'number') || x0 === null) && ((typeof y0 === 'number') || y0 === null) && ((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && direction === undefined) {
                        return this.accumulateLine$double$double$double$double(x0, y0, x1, y1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Crossings.prototype.accumulateQuad = function (x0, y0, coords) {
                    if (y0 < this.ylo && coords[1] < this.ylo && coords[3] < this.ylo) {
                        return false;
                    }
                    if (y0 > this.yhi && coords[1] > this.yhi && coords[3] > this.yhi) {
                        return false;
                    }
                    if (x0 > this.xhi && coords[0] > this.xhi && coords[2] > this.xhi) {
                        return false;
                    }
                    if (x0 < this.xlo && coords[0] < this.xlo && coords[2] < this.xlo) {
                        if (y0 < coords[3]) {
                            this.record(Math.max(y0, this.ylo), Math.min(coords[3], this.yhi), 1);
                        }
                        else if (y0 > coords[3]) {
                            this.record(Math.max(coords[3], this.ylo), Math.min(y0, this.yhi), -1);
                        }
                        return false;
                    }
                    sun.awt.geom.Curve.insertQuad(this.tmp, x0, y0, coords);
                    var enum_ = (function (a) { var i = 0; return { nextElement: function () { return i < a.length ? a[i++] : null; }, hasMoreElements: function () { return i < a.length; } }; })(this.tmp);
                    while ((enum_.hasMoreElements())) {
                        var c = enum_.nextElement();
                        if (c.accumulateCrossings(this)) {
                            return true;
                        }
                    }
                    ;
                    /* clear */ (this.tmp.length = 0);
                    return false;
                };
                Crossings.prototype.accumulateCubic = function (x0, y0, coords) {
                    if (y0 < this.ylo && coords[1] < this.ylo && coords[3] < this.ylo && coords[5] < this.ylo) {
                        return false;
                    }
                    if (y0 > this.yhi && coords[1] > this.yhi && coords[3] > this.yhi && coords[5] > this.yhi) {
                        return false;
                    }
                    if (x0 > this.xhi && coords[0] > this.xhi && coords[2] > this.xhi && coords[4] > this.xhi) {
                        return false;
                    }
                    if (x0 < this.xlo && coords[0] < this.xlo && coords[2] < this.xlo && coords[4] < this.xlo) {
                        if (y0 <= coords[5]) {
                            this.record(Math.max(y0, this.ylo), Math.min(coords[5], this.yhi), 1);
                        }
                        else {
                            this.record(Math.max(coords[5], this.ylo), Math.min(y0, this.yhi), -1);
                        }
                        return false;
                    }
                    sun.awt.geom.Curve.insertCubic(this.tmp, x0, y0, coords);
                    var enum_ = (function (a) { var i = 0; return { nextElement: function () { return i < a.length ? a[i++] : null; }, hasMoreElements: function () { return i < a.length; } }; })(this.tmp);
                    while ((enum_.hasMoreElements())) {
                        var c = enum_.nextElement();
                        if (c.accumulateCrossings(this)) {
                            return true;
                        }
                    }
                    ;
                    /* clear */ (this.tmp.length = 0);
                    return false;
                };
                return Crossings;
            }());
            Crossings.debug = false;
            geom.Crossings = Crossings;
            Crossings["__class"] = "sun.awt.geom.Crossings";
            (function (Crossings) {
                var EvenOdd = (function (_super) {
                    __extends(EvenOdd, _super);
                    function EvenOdd(xlo, ylo, xhi, yhi) {
                        return _super.call(this, xlo, ylo, xhi, yhi) || this;
                    }
                    EvenOdd.prototype.covers = function (ystart, yend) {
                        return (this.limit === 2 && this.yranges[0] <= ystart && this.yranges[1] >= yend);
                    };
                    EvenOdd.prototype.record = function (ystart, yend, direction) {
                        if (ystart >= yend) {
                            return;
                        }
                        var from = 0;
                        while ((from < this.limit && ystart > this.yranges[from + 1])) {
                            from += 2;
                        }
                        ;
                        var to = from;
                        while ((from < this.limit)) {
                            var yrlo = this.yranges[from++];
                            var yrhi = this.yranges[from++];
                            if (yend < yrlo) {
                                this.yranges[to++] = ystart;
                                this.yranges[to++] = yend;
                                ystart = yrlo;
                                yend = yrhi;
                                continue;
                            }
                            var yll = void 0;
                            var ylh = void 0;
                            var yhl = void 0;
                            var yhh = void 0;
                            if (ystart < yrlo) {
                                yll = ystart;
                                ylh = yrlo;
                            }
                            else {
                                yll = yrlo;
                                ylh = ystart;
                            }
                            if (yend < yrhi) {
                                yhl = yend;
                                yhh = yrhi;
                            }
                            else {
                                yhl = yrhi;
                                yhh = yend;
                            }
                            if (ylh === yhl) {
                                ystart = yll;
                                yend = yhh;
                            }
                            else {
                                if (ylh > yhl) {
                                    ystart = yhl;
                                    yhl = ylh;
                                    ylh = ystart;
                                }
                                if (yll !== ylh) {
                                    this.yranges[to++] = yll;
                                    this.yranges[to++] = ylh;
                                }
                                ystart = yhl;
                                yend = yhh;
                            }
                            if (ystart >= yend) {
                                break;
                            }
                        }
                        ;
                        if (to < from && from < this.limit) {
                            Helper.arraycopy(this.yranges, from, this.yranges, to, this.limit - from);
                        }
                        to += (this.limit - from);
                        if (ystart < yend) {
                            if (to >= this.yranges.length) {
                                var newranges = (function (s) { var a = []; while (s-- > 0)
                                    a.push(0); return a; })(to + 10);
                                Helper.arraycopy(this.yranges, 0, newranges, 0, to);
                                this.yranges = newranges;
                            }
                            this.yranges[to++] = ystart;
                            this.yranges[to++] = yend;
                        }
                        this.limit = to;
                    };
                    return EvenOdd;
                }(sun.awt.geom.Crossings));
                Crossings.EvenOdd = EvenOdd;
                EvenOdd["__class"] = "sun.awt.geom.Crossings.EvenOdd";
                var NonZero = (function (_super) {
                    __extends(NonZero, _super);
                    function NonZero(xlo, ylo, xhi, yhi) {
                        var _this = _super.call(this, xlo, ylo, xhi, yhi) || this;
                        _this.crosscounts = null;
                        _this.crosscounts = (function (s) { var a = []; while (s-- > 0)
                            a.push(0); return a; })((_this.yranges.length / 2 | 0));
                        return _this;
                    }
                    NonZero.prototype.covers = function (ystart, yend) {
                        var i = 0;
                        while ((i < this.limit)) {
                            var ylo = this.yranges[i++];
                            var yhi = this.yranges[i++];
                            if (ystart >= yhi) {
                                continue;
                            }
                            if (ystart < ylo) {
                                return false;
                            }
                            if (yend <= yhi) {
                                return true;
                            }
                            ystart = yhi;
                        }
                        ;
                        return (ystart >= yend);
                    };
                    NonZero.prototype.remove = function (cur) {
                        this.limit -= 2;
                        var rem = this.limit - cur;
                        if (rem > 0) {
                            Helper.arraycopy(this.yranges, cur + 2, this.yranges, cur, rem);
                            Helper.arraycopy(this.crosscounts, (cur / 2 | 0) + 1, this.crosscounts, (cur / 2 | 0), (rem / 2 | 0));
                        }
                    };
                    NonZero.prototype.insert = function (cur, lo, hi, dir) {
                        var rem = this.limit - cur;
                        var oldranges = this.yranges;
                        var oldcounts = this.crosscounts;
                        if (this.limit >= this.yranges.length) {
                            this.yranges = (function (s) { var a = []; while (s-- > 0)
                                a.push(0); return a; })(this.limit + 10);
                            Helper.arraycopy(oldranges, 0, this.yranges, 0, cur);
                            this.crosscounts = (function (s) { var a = []; while (s-- > 0)
                                a.push(0); return a; })(((this.limit + 10) / 2 | 0));
                            Helper.arraycopy(oldcounts, 0, this.crosscounts, 0, (cur / 2 | 0));
                        }
                        if (rem > 0) {
                            Helper.arraycopy(oldranges, cur, this.yranges, cur + 2, rem);
                            Helper.arraycopy(oldcounts, (cur / 2 | 0), this.crosscounts, (cur / 2 | 0) + 1, (rem / 2 | 0));
                        }
                        this.yranges[cur + 0] = lo;
                        this.yranges[cur + 1] = hi;
                        this.crosscounts[(cur / 2 | 0)] = dir;
                        this.limit += 2;
                    };
                    NonZero.prototype.record = function (ystart, yend, direction) {
                        if (ystart >= yend) {
                            return;
                        }
                        var cur = 0;
                        while ((cur < this.limit && ystart > this.yranges[cur + 1])) {
                            cur += 2;
                        }
                        ;
                        if (cur < this.limit) {
                            var rdir = this.crosscounts[(cur / 2 | 0)];
                            var yrlo = this.yranges[cur + 0];
                            var yrhi = this.yranges[cur + 1];
                            if (yrhi === ystart && rdir === direction) {
                                if (cur + 2 === this.limit) {
                                    this.yranges[cur + 1] = yend;
                                    return;
                                }
                                this.remove(cur);
                                ystart = yrlo;
                                rdir = this.crosscounts[(cur / 2 | 0)];
                                yrlo = this.yranges[cur + 0];
                                yrhi = this.yranges[cur + 1];
                            }
                            if (yend < yrlo) {
                                this.insert(cur, ystart, yend, direction);
                                return;
                            }
                            if (yend === yrlo && rdir === direction) {
                                this.yranges[cur] = ystart;
                                return;
                            }
                            if (ystart < yrlo) {
                                this.insert(cur, ystart, yrlo, direction);
                                cur += 2;
                                ystart = yrlo;
                            }
                            else if (yrlo < ystart) {
                                this.insert(cur, yrlo, ystart, rdir);
                                cur += 2;
                                yrlo = ystart;
                            }
                            var newdir = rdir + direction;
                            var newend = Math.min(yend, yrhi);
                            if (newdir === 0) {
                                this.remove(cur);
                            }
                            else {
                                this.crosscounts[(cur / 2 | 0)] = newdir;
                                this.yranges[cur++] = ystart;
                                this.yranges[cur++] = newend;
                            }
                            ystart = yrlo = newend;
                            if (yrlo < yrhi) {
                                this.insert(cur, yrlo, yrhi, rdir);
                            }
                        }
                        if (ystart < yend) {
                            this.insert(cur, ystart, yend, direction);
                        }
                    };
                    return NonZero;
                }(sun.awt.geom.Crossings));
                Crossings.NonZero = NonZero;
                NonZero["__class"] = "sun.awt.geom.Crossings.NonZero";
            })(Crossings = geom.Crossings || (geom.Crossings = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var Curve = (function () {
                function Curve(direction) {
                    this.direction = 0;
                    this.direction = direction;
                }
                Curve.insertMove = function (curves, x, y) {
                    /* add */ curves.push(new sun.awt.geom.Order0(x, y));
                };
                Curve.insertLine = function (curves, x0, y0, x1, y1) {
                    if (y0 < y1) {
                        /* add */ curves.push(new sun.awt.geom.Order1(x0, y0, x1, y1, Curve.INCREASING));
                    }
                    else if (y0 > y1) {
                        /* add */ curves.push(new sun.awt.geom.Order1(x1, y1, x0, y0, Curve.DECREASING));
                    }
                    else {
                    }
                };
                Curve.insertQuad = function (curves, x0, y0, coords) {
                    var y1 = coords[3];
                    if (y0 > y1) {
                        sun.awt.geom.Order2.insert(curves, coords, coords[2], y1, coords[0], coords[1], x0, y0, Curve.DECREASING);
                    }
                    else if (y0 === y1 && y0 === coords[1]) {
                        return;
                    }
                    else {
                        sun.awt.geom.Order2.insert(curves, coords, x0, y0, coords[0], coords[1], coords[2], y1, Curve.INCREASING);
                    }
                };
                Curve.insertCubic = function (curves, x0, y0, coords) {
                    var y1 = coords[5];
                    if (y0 > y1) {
                        sun.awt.geom.Order3.insert(curves, coords, coords[4], y1, coords[2], coords[3], coords[0], coords[1], x0, y0, Curve.DECREASING);
                    }
                    else if (y0 === y1 && y0 === coords[1] && y0 === coords[3]) {
                        return;
                    }
                    else {
                        sun.awt.geom.Order3.insert(curves, coords, x0, y0, coords[0], coords[1], coords[2], coords[3], coords[4], y1, Curve.INCREASING);
                    }
                };
                /**
                 * Calculates the number of times the given path crosses the ray extending
                 * to the right from (px,py). If the point lies on a part of the path, then
                 * no crossings are counted for that intersection. +1 is added for each
                 * crossing where the Y coordinate is increasing -1 is added for each
                 * crossing where the Y coordinate is decreasing The return value is the sum
                 * of all crossings for every segment in the path. The path must start with
                 * a SEG_MOVETO, otherwise an exception is thrown. The caller must check
                 * p[xy] for NaN values. The caller may also reject infinite p[xy] values as
                 * well.
                 * @param {PathIterator} pi
                 * @param {number} px
                 * @param {number} py
                 * @return {number}
                 */
                Curve.pointCrossingsForPath = function (pi, px, py) {
                    if (pi.isDone()) {
                        return 0;
                    }
                    var coords = [0, 0, 0, 0, 0, 0];
                    if (pi['currentSegment$double_A'](coords) !== PathIterator.SEG_MOVETO) {
                        throw Object.defineProperty(new Error("missing initial moveto in path definition"), '__class', { configurable: true, value: 'java.awt.geom.IllegalPathStateException' });
                    }
                    pi.next();
                    var movx = coords[0];
                    var movy = coords[1];
                    var curx = movx;
                    var cury = movy;
                    var endx;
                    var endy;
                    var crossings = 0;
                    while ((!pi.isDone())) {
                        switch ((pi['currentSegment$double_A'](coords))) {
                            case PathIterator.SEG_MOVETO:
                                if (cury !== movy) {
                                    crossings += Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                                }
                                movx = curx = coords[0];
                                movy = cury = coords[1];
                                break;
                            case PathIterator.SEG_LINETO:
                                endx = coords[0];
                                endy = coords[1];
                                crossings += Curve.pointCrossingsForLine(px, py, curx, cury, endx, endy);
                                curx = endx;
                                cury = endy;
                                break;
                            case PathIterator.SEG_QUADTO:
                                endx = coords[2];
                                endy = coords[3];
                                crossings += Curve.pointCrossingsForQuad(px, py, curx, cury, coords[0], coords[1], endx, endy, 0);
                                curx = endx;
                                cury = endy;
                                break;
                            case PathIterator.SEG_CUBICTO:
                                endx = coords[4];
                                endy = coords[5];
                                crossings += Curve.pointCrossingsForCubic(px, py, curx, cury, coords[0], coords[1], coords[2], coords[3], endx, endy, 0);
                                curx = endx;
                                cury = endy;
                                break;
                            case PathIterator.SEG_CLOSE:
                                if (cury !== movy) {
                                    crossings += Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                                }
                                curx = movx;
                                cury = movy;
                                break;
                        }
                        pi.next();
                    }
                    ;
                    if (cury !== movy) {
                        crossings += Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                    }
                    return crossings;
                };
                /**
                 * Calculates the number of times the line from (x0,y0) to (x1,y1) crosses
                 * the ray extending to the right from (px,py). If the point lies on the
                 * line, then no crossings are recorded. +1 is returned for a crossing where
                 * the Y coordinate is increasing -1 is returned for a crossing where the Y
                 * coordinate is decreasing
                 * @param {number} px
                 * @param {number} py
                 * @param {number} x0
                 * @param {number} y0
                 * @param {number} x1
                 * @param {number} y1
                 * @return {number}
                 */
                Curve.pointCrossingsForLine = function (px, py, x0, y0, x1, y1) {
                    if (py < y0 && py < y1)
                        return 0;
                    if (py >= y0 && py >= y1)
                        return 0;
                    if (px >= x0 && px >= x1)
                        return 0;
                    if (px < x0 && px < x1)
                        return (y0 < y1) ? 1 : -1;
                    var xintercept = x0 + (py - y0) * (x1 - x0) / (y1 - y0);
                    if (px >= xintercept)
                        return 0;
                    return (y0 < y1) ? 1 : -1;
                };
                /**
                 * Calculates the number of times the quad from (x0,y0) to (x1,y1) crosses
                 * the ray extending to the right from (px,py). If the point lies on a part
                 * of the curve, then no crossings are counted for that intersection. the
                 * level parameter should be 0 at the top-level call and will count up for
                 * each recursion level to prevent infinite recursion +1 is added for each
                 * crossing where the Y coordinate is increasing -1 is added for each
                 * crossing where the Y coordinate is decreasing
                 * @param {number} px
                 * @param {number} py
                 * @param {number} x0
                 * @param {number} y0
                 * @param {number} xc
                 * @param {number} yc
                 * @param {number} x1
                 * @param {number} y1
                 * @param {number} level
                 * @return {number}
                 */
                Curve.pointCrossingsForQuad = function (px, py, x0, y0, xc, yc, x1, y1, level) {
                    if (py < y0 && py < yc && py < y1)
                        return 0;
                    if (py >= y0 && py >= yc && py >= y1)
                        return 0;
                    if (px >= x0 && px >= xc && px >= x1)
                        return 0;
                    if (px < x0 && px < xc && px < x1) {
                        if (py >= y0) {
                            if (py < y1)
                                return 1;
                        }
                        else {
                            if (py >= y1)
                                return -1;
                        }
                        return 0;
                    }
                    if (level > 52)
                        return Curve.pointCrossingsForLine(px, py, x0, y0, x1, y1);
                    var x0c = (x0 + xc) / 2;
                    var y0c = (y0 + yc) / 2;
                    var xc1 = (xc + x1) / 2;
                    var yc1 = (yc + y1) / 2;
                    xc = (x0c + xc1) / 2;
                    yc = (y0c + yc1) / 2;
                    if (isNaN(xc) || isNaN(yc)) {
                        return 0;
                    }
                    return (Curve.pointCrossingsForQuad(px, py, x0, y0, x0c, y0c, xc, yc, level + 1) + Curve.pointCrossingsForQuad(px, py, xc, yc, xc1, yc1, x1, y1, level + 1));
                };
                /**
                 * Calculates the number of times the cubic from (x0,y0) to (x1,y1) crosses
                 * the ray extending to the right from (px,py). If the point lies on a part
                 * of the curve, then no crossings are counted for that intersection. the
                 * level parameter should be 0 at the top-level call and will count up for
                 * each recursion level to prevent infinite recursion +1 is added for each
                 * crossing where the Y coordinate is increasing -1 is added for each
                 * crossing where the Y coordinate is decreasing
                 * @param {number} px
                 * @param {number} py
                 * @param {number} x0
                 * @param {number} y0
                 * @param {number} xc0
                 * @param {number} yc0
                 * @param {number} xc1
                 * @param {number} yc1
                 * @param {number} x1
                 * @param {number} y1
                 * @param {number} level
                 * @return {number}
                 */
                Curve.pointCrossingsForCubic = function (px, py, x0, y0, xc0, yc0, xc1, yc1, x1, y1, level) {
                    if (py < y0 && py < yc0 && py < yc1 && py < y1)
                        return 0;
                    if (py >= y0 && py >= yc0 && py >= yc1 && py >= y1)
                        return 0;
                    if (px >= x0 && px >= xc0 && px >= xc1 && px >= x1)
                        return 0;
                    if (px < x0 && px < xc0 && px < xc1 && px < x1) {
                        if (py >= y0) {
                            if (py < y1)
                                return 1;
                        }
                        else {
                            if (py >= y1)
                                return -1;
                        }
                        return 0;
                    }
                    if (level > 52)
                        return Curve.pointCrossingsForLine(px, py, x0, y0, x1, y1);
                    var xmid = (xc0 + xc1) / 2;
                    var ymid = (yc0 + yc1) / 2;
                    xc0 = (x0 + xc0) / 2;
                    yc0 = (y0 + yc0) / 2;
                    xc1 = (xc1 + x1) / 2;
                    yc1 = (yc1 + y1) / 2;
                    var xc0m = (xc0 + xmid) / 2;
                    var yc0m = (yc0 + ymid) / 2;
                    var xmc1 = (xmid + xc1) / 2;
                    var ymc1 = (ymid + yc1) / 2;
                    xmid = (xc0m + xmc1) / 2;
                    ymid = (yc0m + ymc1) / 2;
                    if (isNaN(xmid) || isNaN(ymid)) {
                        return 0;
                    }
                    return (Curve.pointCrossingsForCubic(px, py, x0, y0, xc0, yc0, xc0m, yc0m, xmid, ymid, level + 1) + Curve.pointCrossingsForCubic(px, py, xmid, ymid, xmc1, ymc1, xc1, yc1, x1, y1, level + 1));
                };
                /**
                 * Accumulate the number of times the path crosses the shadow extending to
                 * the right of the rectangle. See the comment for the RECT_INTERSECTS
                 * constant for more complete details. The return value is the sum of all
                 * crossings for both the top and bottom of the shadow for every segment in
                 * the path, or the special value RECT_INTERSECTS if the path ever enters
                 * the interior of the rectangle. The path must start with a SEG_MOVETO,
                 * otherwise an exception is thrown. The caller must check r[xy]{min,max}
                 * for NaN values.
                 * @param {PathIterator} pi
                 * @param {number} rxmin
                 * @param {number} rymin
                 * @param {number} rxmax
                 * @param {number} rymax
                 * @return {number}
                 */
                Curve.rectCrossingsForPath = function (pi, rxmin, rymin, rxmax, rymax) {
                    if (rxmax <= rxmin || rymax <= rymin) {
                        return 0;
                    }
                    if (pi.isDone()) {
                        return 0;
                    }
                    var coords = [0, 0, 0, 0, 0, 0];
                    if (pi['currentSegment$double_A'](coords) !== PathIterator.SEG_MOVETO) {
                        throw Object.defineProperty(new Error("missing initial moveto in path definition"), '__class', { configurable: true, value: 'java.awt.geom.IllegalPathStateException' });
                    }
                    pi.next();
                    var curx;
                    var cury;
                    var movx;
                    var movy;
                    var endx;
                    var endy;
                    curx = movx = coords[0];
                    cury = movy = coords[1];
                    var crossings = 0;
                    while ((crossings !== Curve.RECT_INTERSECTS && !pi.isDone())) {
                        switch ((pi['currentSegment$double_A'](coords))) {
                            case PathIterator.SEG_MOVETO:
                                if (curx !== movx || cury !== movy) {
                                    crossings = Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                                }
                                movx = curx = coords[0];
                                movy = cury = coords[1];
                                break;
                            case PathIterator.SEG_LINETO:
                                endx = coords[0];
                                endy = coords[1];
                                crossings = Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, endx, endy);
                                curx = endx;
                                cury = endy;
                                break;
                            case PathIterator.SEG_QUADTO:
                                endx = coords[2];
                                endy = coords[3];
                                crossings = Curve.rectCrossingsForQuad(crossings, rxmin, rymin, rxmax, rymax, curx, cury, coords[0], coords[1], endx, endy, 0);
                                curx = endx;
                                cury = endy;
                                break;
                            case PathIterator.SEG_CUBICTO:
                                endx = coords[4];
                                endy = coords[5];
                                crossings = Curve.rectCrossingsForCubic(crossings, rxmin, rymin, rxmax, rymax, curx, cury, coords[0], coords[1], coords[2], coords[3], endx, endy, 0);
                                curx = endx;
                                cury = endy;
                                break;
                            case PathIterator.SEG_CLOSE:
                                if (curx !== movx || cury !== movy) {
                                    crossings = Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                                }
                                curx = movx;
                                cury = movy;
                                break;
                        }
                        pi.next();
                    }
                    ;
                    if (crossings !== Curve.RECT_INTERSECTS && (curx !== movx || cury !== movy)) {
                        crossings = Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                    }
                    return crossings;
                };
                /**
                 * Accumulate the number of times the line crosses the shadow extending to
                 * the right of the rectangle. See the comment for the RECT_INTERSECTS
                 * constant for more complete details.
                 * @param {number} crossings
                 * @param {number} rxmin
                 * @param {number} rymin
                 * @param {number} rxmax
                 * @param {number} rymax
                 * @param {number} x0
                 * @param {number} y0
                 * @param {number} x1
                 * @param {number} y1
                 * @return {number}
                 */
                Curve.rectCrossingsForLine = function (crossings, rxmin, rymin, rxmax, rymax, x0, y0, x1, y1) {
                    if (y0 >= rymax && y1 >= rymax)
                        return crossings;
                    if (y0 <= rymin && y1 <= rymin)
                        return crossings;
                    if (x0 <= rxmin && x1 <= rxmin)
                        return crossings;
                    if (x0 >= rxmax && x1 >= rxmax) {
                        if (y0 < y1) {
                            if (y0 <= rymin)
                                crossings++;
                            if (y1 >= rymax)
                                crossings++;
                        }
                        else if (y1 < y0) {
                            if (y1 <= rymin)
                                crossings--;
                            if (y0 >= rymax)
                                crossings--;
                        }
                        return crossings;
                    }
                    if ((x0 > rxmin && x0 < rxmax && y0 > rymin && y0 < rymax) || (x1 > rxmin && x1 < rxmax && y1 > rymin && y1 < rymax)) {
                        return Curve.RECT_INTERSECTS;
                    }
                    var xi0 = x0;
                    if (y0 < rymin) {
                        xi0 += ((rymin - y0) * (x1 - x0) / (y1 - y0));
                    }
                    else if (y0 > rymax) {
                        xi0 += ((rymax - y0) * (x1 - x0) / (y1 - y0));
                    }
                    var xi1 = x1;
                    if (y1 < rymin) {
                        xi1 += ((rymin - y1) * (x0 - x1) / (y0 - y1));
                    }
                    else if (y1 > rymax) {
                        xi1 += ((rymax - y1) * (x0 - x1) / (y0 - y1));
                    }
                    if (xi0 <= rxmin && xi1 <= rxmin)
                        return crossings;
                    if (xi0 >= rxmax && xi1 >= rxmax) {
                        if (y0 < y1) {
                            if (y0 <= rymin)
                                crossings++;
                            if (y1 >= rymax)
                                crossings++;
                        }
                        else if (y1 < y0) {
                            if (y1 <= rymin)
                                crossings--;
                            if (y0 >= rymax)
                                crossings--;
                        }
                        return crossings;
                    }
                    return Curve.RECT_INTERSECTS;
                };
                /**
                 * Accumulate the number of times the quad crosses the shadow extending to
                 * the right of the rectangle. See the comment for the RECT_INTERSECTS
                 * constant for more complete details.
                 * @param {number} crossings
                 * @param {number} rxmin
                 * @param {number} rymin
                 * @param {number} rxmax
                 * @param {number} rymax
                 * @param {number} x0
                 * @param {number} y0
                 * @param {number} xc
                 * @param {number} yc
                 * @param {number} x1
                 * @param {number} y1
                 * @param {number} level
                 * @return {number}
                 */
                Curve.rectCrossingsForQuad = function (crossings, rxmin, rymin, rxmax, rymax, x0, y0, xc, yc, x1, y1, level) {
                    if (y0 >= rymax && yc >= rymax && y1 >= rymax)
                        return crossings;
                    if (y0 <= rymin && yc <= rymin && y1 <= rymin)
                        return crossings;
                    if (x0 <= rxmin && xc <= rxmin && x1 <= rxmin)
                        return crossings;
                    if (x0 >= rxmax && xc >= rxmax && x1 >= rxmax) {
                        if (y0 < y1) {
                            if (y0 <= rymin && y1 > rymin)
                                crossings++;
                            if (y0 < rymax && y1 >= rymax)
                                crossings++;
                        }
                        else if (y1 < y0) {
                            if (y1 <= rymin && y0 > rymin)
                                crossings--;
                            if (y1 < rymax && y0 >= rymax)
                                crossings--;
                        }
                        return crossings;
                    }
                    if ((x0 < rxmax && x0 > rxmin && y0 < rymax && y0 > rymin) || (x1 < rxmax && x1 > rxmin && y1 < rymax && y1 > rymin)) {
                        return Curve.RECT_INTERSECTS;
                    }
                    if (level > 52) {
                        return Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, x0, y0, x1, y1);
                    }
                    var x0c = (x0 + xc) / 2;
                    var y0c = (y0 + yc) / 2;
                    var xc1 = (xc + x1) / 2;
                    var yc1 = (yc + y1) / 2;
                    xc = (x0c + xc1) / 2;
                    yc = (y0c + yc1) / 2;
                    if (isNaN(xc) || isNaN(yc)) {
                        return 0;
                    }
                    crossings = Curve.rectCrossingsForQuad(crossings, rxmin, rymin, rxmax, rymax, x0, y0, x0c, y0c, xc, yc, level + 1);
                    if (crossings !== Curve.RECT_INTERSECTS) {
                        crossings = Curve.rectCrossingsForQuad(crossings, rxmin, rymin, rxmax, rymax, xc, yc, xc1, yc1, x1, y1, level + 1);
                    }
                    return crossings;
                };
                /**
                 * Accumulate the number of times the cubic crosses the shadow extending to
                 * the right of the rectangle. See the comment for the RECT_INTERSECTS
                 * constant for more complete details.
                 * @param {number} crossings
                 * @param {number} rxmin
                 * @param {number} rymin
                 * @param {number} rxmax
                 * @param {number} rymax
                 * @param {number} x0
                 * @param {number} y0
                 * @param {number} xc0
                 * @param {number} yc0
                 * @param {number} xc1
                 * @param {number} yc1
                 * @param {number} x1
                 * @param {number} y1
                 * @param {number} level
                 * @return {number}
                 */
                Curve.rectCrossingsForCubic = function (crossings, rxmin, rymin, rxmax, rymax, x0, y0, xc0, yc0, xc1, yc1, x1, y1, level) {
                    if (y0 >= rymax && yc0 >= rymax && yc1 >= rymax && y1 >= rymax) {
                        return crossings;
                    }
                    if (y0 <= rymin && yc0 <= rymin && yc1 <= rymin && y1 <= rymin) {
                        return crossings;
                    }
                    if (x0 <= rxmin && xc0 <= rxmin && xc1 <= rxmin && x1 <= rxmin) {
                        return crossings;
                    }
                    if (x0 >= rxmax && xc0 >= rxmax && xc1 >= rxmax && x1 >= rxmax) {
                        if (y0 < y1) {
                            if (y0 <= rymin && y1 > rymin)
                                crossings++;
                            if (y0 < rymax && y1 >= rymax)
                                crossings++;
                        }
                        else if (y1 < y0) {
                            if (y1 <= rymin && y0 > rymin)
                                crossings--;
                            if (y1 < rymax && y0 >= rymax)
                                crossings--;
                        }
                        return crossings;
                    }
                    if ((x0 > rxmin && x0 < rxmax && y0 > rymin && y0 < rymax) || (x1 > rxmin && x1 < rxmax && y1 > rymin && y1 < rymax)) {
                        return Curve.RECT_INTERSECTS;
                    }
                    if (level > 52) {
                        return Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, x0, y0, x1, y1);
                    }
                    var xmid = (xc0 + xc1) / 2;
                    var ymid = (yc0 + yc1) / 2;
                    xc0 = (x0 + xc0) / 2;
                    yc0 = (y0 + yc0) / 2;
                    xc1 = (xc1 + x1) / 2;
                    yc1 = (yc1 + y1) / 2;
                    var xc0m = (xc0 + xmid) / 2;
                    var yc0m = (yc0 + ymid) / 2;
                    var xmc1 = (xmid + xc1) / 2;
                    var ymc1 = (ymid + yc1) / 2;
                    xmid = (xc0m + xmc1) / 2;
                    ymid = (yc0m + ymc1) / 2;
                    if (isNaN(xmid) || isNaN(ymid)) {
                        return 0;
                    }
                    crossings = Curve.rectCrossingsForCubic(crossings, rxmin, rymin, rxmax, rymax, x0, y0, xc0, yc0, xc0m, yc0m, xmid, ymid, level + 1);
                    if (crossings !== Curve.RECT_INTERSECTS) {
                        crossings = Curve.rectCrossingsForCubic(crossings, rxmin, rymin, rxmax, rymax, xmid, ymid, xmc1, ymc1, xc1, yc1, x1, y1, level + 1);
                    }
                    return crossings;
                };
                Curve.prototype.getDirection = function () {
                    return this.direction;
                };
                Curve.prototype.getWithDirection = function (direction) {
                    return (this.direction === direction ? this : this.getReversedCurve());
                };
                Curve.round = function (v) {
                    return v;
                };
                Curve.orderof = function (x1, x2) {
                    if (x1 < x2) {
                        return -1;
                    }
                    if (x1 > x2) {
                        return 1;
                    }
                    return 0;
                };
                Curve.signeddiffbits = function (y1, y2) {
                    return (javaemul.internal.DoubleHelper.doubleToLongBits(y1) - javaemul.internal.DoubleHelper.doubleToLongBits(y2));
                };
                Curve.diffbits = function (y1, y2) {
                    return Math.abs(javaemul.internal.DoubleHelper.doubleToLongBits(y1) - javaemul.internal.DoubleHelper.doubleToLongBits(y2));
                };
                Curve.prev = function (v) {
                    return javaemul.internal.DoubleHelper.longBitsToDouble(javaemul.internal.DoubleHelper.doubleToLongBits(v) - 1);
                };
                Curve.next = function (v) {
                    return javaemul.internal.DoubleHelper.longBitsToDouble(javaemul.internal.DoubleHelper.doubleToLongBits(v) + 1);
                };
                Curve.prototype.toString = function () {
                    return ("Curve[" + this.getOrder() + ", " + ("(" + Curve.round(this.getX0()) + ", " + Curve.round(this.getY0()) + "), ") + this.controlPointString() + ("(" + Curve.round(this.getX1()) + ", " + Curve.round(this.getY1()) + "), ") + (this.direction === Curve.INCREASING ? "D" : "U") + "]");
                };
                Curve.prototype.controlPointString = function () {
                    return "";
                };
                Curve.prototype.crossingsFor = function (x, y) {
                    if (y >= this.getYTop() && y < this.getYBot()) {
                        if (x < this.getXMax() && (x < this.getXMin() || x < this.XforY(y))) {
                            return 1;
                        }
                    }
                    return 0;
                };
                Curve.prototype.accumulateCrossings = function (c) {
                    var xhi = c.getXHi();
                    if (this.getXMin() >= xhi) {
                        return false;
                    }
                    var xlo = c.getXLo();
                    var ylo = c.getYLo();
                    var yhi = c.getYHi();
                    var y0 = this.getYTop();
                    var y1 = this.getYBot();
                    var tstart;
                    var ystart;
                    var tend;
                    var yend;
                    if (y0 < ylo) {
                        if (y1 <= ylo) {
                            return false;
                        }
                        ystart = ylo;
                        tstart = this.TforY(ylo);
                    }
                    else {
                        if (y0 >= yhi) {
                            return false;
                        }
                        ystart = y0;
                        tstart = 0;
                    }
                    if (y1 > yhi) {
                        yend = yhi;
                        tend = this.TforY(yhi);
                    }
                    else {
                        yend = y1;
                        tend = 1;
                    }
                    var hitLo = false;
                    var hitHi = false;
                    while ((true)) {
                        var x = this.XforT(tstart);
                        if (x < xhi) {
                            if (hitHi || x > xlo) {
                                return true;
                            }
                            hitLo = true;
                        }
                        else {
                            if (hitLo) {
                                return true;
                            }
                            hitHi = true;
                        }
                        if (tstart >= tend) {
                            break;
                        }
                        tstart = this.nextVertical(tstart, tend);
                    }
                    ;
                    if (hitLo) {
                        c.record(ystart, yend, this.direction);
                    }
                    return false;
                };
                Curve.prototype.getSubCurve$double$double = function (ystart, yend) {
                    return this.getSubCurve$double$double$int(ystart, yend, this.direction);
                };
                Curve.prototype.getSubCurve$double$double$int = function (ystart, yend, dir) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                Curve.prototype.getSubCurve = function (ystart, yend, dir) {
                    if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && ((typeof dir === 'number') || dir === null)) {
                        return this.getSubCurve$double$double$int(ystart, yend, dir);
                    }
                    else if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && dir === undefined) {
                        return this.getSubCurve$double$double(ystart, yend);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Curve.prototype.compareTo = function (that, yrange) {
                    var y0 = yrange[0];
                    var y1 = yrange[1];
                    y1 = Math.min(Math.min(y1, this.getYBot()), that.getYBot());
                    if (y1 <= yrange[0]) {
                        console.error("this == " + this);
                        console.error("that == " + that);
                        console.info("target range = " + yrange[0] + "=>" + yrange[1]);
                        throw Object.defineProperty(new Error("backstepping from " + yrange[0] + " to " + y1), '__class', { configurable: true, value: 'java.lang.InternalError' });
                    }
                    yrange[1] = y1;
                    if (this.getXMax() <= that.getXMin()) {
                        if (this.getXMin() === that.getXMax()) {
                            return 0;
                        }
                        return -1;
                    }
                    if (this.getXMin() >= that.getXMax()) {
                        return 1;
                    }
                    var s0 = this.TforY(y0);
                    var ys0 = this.YforT(s0);
                    if (ys0 < y0) {
                        s0 = this.refineTforY(s0, ys0, y0);
                        ys0 = this.YforT(s0);
                    }
                    var s1 = this.TforY(y1);
                    if (this.YforT(s1) < y0) {
                        s1 = this.refineTforY(s1, this.YforT(s1), y0);
                    }
                    var t0 = that.TforY(y0);
                    var yt0 = that.YforT(t0);
                    if (yt0 < y0) {
                        t0 = that.refineTforY(t0, yt0, y0);
                        yt0 = that.YforT(t0);
                    }
                    var t1 = that.TforY(y1);
                    if (that.YforT(t1) < y0) {
                        t1 = that.refineTforY(t1, that.YforT(t1), y0);
                    }
                    var xs0 = this.XforT(s0);
                    var xt0 = that.XforT(t0);
                    var scale = Math.max(Math.abs(y0), Math.abs(y1));
                    var ymin = Math.max(scale * 1.0E-14, 1.0E-300);
                    if (this.fairlyClose(xs0, xt0)) {
                        var bump = ymin;
                        var maxbump = Math.min(ymin * 1.0E13, (y1 - y0) * 0.1);
                        var y = y0 + bump;
                        while ((y <= y1)) {
                            if (this.fairlyClose(this.XforY(y), that.XforY(y))) {
                                if ((bump *= 2) > maxbump) {
                                    bump = maxbump;
                                }
                            }
                            else {
                                y -= bump;
                                while ((true)) {
                                    bump /= 2;
                                    var newy = y + bump;
                                    if (newy <= y) {
                                        break;
                                    }
                                    if (this.fairlyClose(this.XforY(newy), that.XforY(newy))) {
                                        y = newy;
                                    }
                                }
                                ;
                                break;
                            }
                            y += bump;
                        }
                        ;
                        if (y > y0) {
                            if (y < y1) {
                                yrange[1] = y;
                            }
                            return 0;
                        }
                    }
                    if (ymin <= 0) {
                        console.info("ymin = " + ymin);
                    }
                    while ((s0 < s1 && t0 < t1)) {
                        var sh = this.nextVertical(s0, s1);
                        var xsh = this.XforT(sh);
                        var ysh = this.YforT(sh);
                        var th = that.nextVertical(t0, t1);
                        var xth = that.XforT(th);
                        var yth = that.YforT(th);
                        try {
                            if (this.findIntersect(that, yrange, ymin, 0, 0, s0, xs0, ys0, sh, xsh, ysh, t0, xt0, yt0, th, xth, yth)) {
                                break;
                            }
                        }
                        catch (t) {
                            console.error("Error: " + t);
                            console.error("y range was " + yrange[0] + "=>" + yrange[1]);
                            console.error("s y range is " + ys0 + "=>" + ysh);
                            console.error("t y range is " + yt0 + "=>" + yth);
                            console.error("ymin is " + ymin);
                            return 0;
                        }
                        ;
                        if (ysh < yth) {
                            if (ysh > yrange[0]) {
                                if (ysh < yrange[1]) {
                                    yrange[1] = ysh;
                                }
                                break;
                            }
                            s0 = sh;
                            xs0 = xsh;
                            ys0 = ysh;
                        }
                        else {
                            if (yth > yrange[0]) {
                                if (yth < yrange[1]) {
                                    yrange[1] = yth;
                                }
                                break;
                            }
                            t0 = th;
                            xt0 = xth;
                            yt0 = yth;
                        }
                    }
                    ;
                    var ymid = (yrange[0] + yrange[1]) / 2;
                    return Curve.orderof(this.XforY(ymid), that.XforY(ymid));
                };
                Curve.prototype.findIntersect = function (that, yrange, ymin, slevel, tlevel, s0, xs0, ys0, s1, xs1, ys1, t0, xt0, yt0, t1, xt1, yt1) {
                    if (ys0 > yt1 || yt0 > ys1) {
                        return false;
                    }
                    if (Math.min(xs0, xs1) > Math.max(xt0, xt1) || Math.max(xs0, xs1) < Math.min(xt0, xt1)) {
                        return false;
                    }
                    if (s1 - s0 > Curve.TMIN) {
                        var s = (s0 + s1) / 2;
                        var xs = this.XforT(s);
                        var ys = this.YforT(s);
                        if (s === s0 || s === s1) {
                            console.info("s0 = " + s0);
                            console.info("s1 = " + s1);
                            throw Object.defineProperty(new Error("no s progress!"), '__class', { configurable: true, value: 'java.lang.InternalError' });
                        }
                        if (t1 - t0 > Curve.TMIN) {
                            var t = (t0 + t1) / 2;
                            var xt = that.XforT(t);
                            var yt = that.YforT(t);
                            if (t === t0 || t === t1) {
                                console.info("t0 = " + t0);
                                console.info("t1 = " + t1);
                                throw Object.defineProperty(new Error("no t progress!"), '__class', { configurable: true, value: 'java.lang.InternalError' });
                            }
                            if (ys >= yt0 && yt >= ys0) {
                                if (this.findIntersect(that, yrange, ymin, slevel + 1, tlevel + 1, s0, xs0, ys0, s, xs, ys, t0, xt0, yt0, t, xt, yt)) {
                                    return true;
                                }
                            }
                            if (ys >= yt) {
                                if (this.findIntersect(that, yrange, ymin, slevel + 1, tlevel + 1, s0, xs0, ys0, s, xs, ys, t, xt, yt, t1, xt1, yt1)) {
                                    return true;
                                }
                            }
                            if (yt >= ys) {
                                if (this.findIntersect(that, yrange, ymin, slevel + 1, tlevel + 1, s, xs, ys, s1, xs1, ys1, t0, xt0, yt0, t, xt, yt)) {
                                    return true;
                                }
                            }
                            if (ys1 >= yt && yt1 >= ys) {
                                if (this.findIntersect(that, yrange, ymin, slevel + 1, tlevel + 1, s, xs, ys, s1, xs1, ys1, t, xt, yt, t1, xt1, yt1)) {
                                    return true;
                                }
                            }
                        }
                        else {
                            if (ys >= yt0) {
                                if (this.findIntersect(that, yrange, ymin, slevel + 1, tlevel, s0, xs0, ys0, s, xs, ys, t0, xt0, yt0, t1, xt1, yt1)) {
                                    return true;
                                }
                            }
                            if (yt1 >= ys) {
                                if (this.findIntersect(that, yrange, ymin, slevel + 1, tlevel, s, xs, ys, s1, xs1, ys1, t0, xt0, yt0, t1, xt1, yt1)) {
                                    return true;
                                }
                            }
                        }
                    }
                    else if (t1 - t0 > Curve.TMIN) {
                        var t = (t0 + t1) / 2;
                        var xt = that.XforT(t);
                        var yt = that.YforT(t);
                        if (t === t0 || t === t1) {
                            console.info("t0 = " + t0);
                            console.info("t1 = " + t1);
                            throw Object.defineProperty(new Error("no t progress!"), '__class', { configurable: true, value: 'java.lang.InternalError' });
                        }
                        if (yt >= ys0) {
                            if (this.findIntersect(that, yrange, ymin, slevel, tlevel + 1, s0, xs0, ys0, s1, xs1, ys1, t0, xt0, yt0, t, xt, yt)) {
                                return true;
                            }
                        }
                        if (ys1 >= yt) {
                            if (this.findIntersect(that, yrange, ymin, slevel, tlevel + 1, s0, xs0, ys0, s1, xs1, ys1, t, xt, yt, t1, xt1, yt1)) {
                                return true;
                            }
                        }
                    }
                    else {
                        var xlk = xs1 - xs0;
                        var ylk = ys1 - ys0;
                        var xnm = xt1 - xt0;
                        var ynm = yt1 - yt0;
                        var xmk = xt0 - xs0;
                        var ymk = yt0 - ys0;
                        var det = xnm * ylk - ynm * xlk;
                        if (det !== 0) {
                            var detinv = 1 / det;
                            var s = (xnm * ymk - ynm * xmk) * detinv;
                            var t = (xlk * ymk - ylk * xmk) * detinv;
                            if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
                                s = s0 + s * (s1 - s0);
                                t = t0 + t * (t1 - t0);
                                if (s < 0 || s > 1 || t < 0 || t > 1) {
                                    console.info("Uh oh!");
                                }
                                var y = (this.YforT(s) + that.YforT(t)) / 2;
                                if (y <= yrange[1] && y > yrange[0]) {
                                    yrange[1] = y;
                                    return true;
                                }
                            }
                        }
                    }
                    return false;
                };
                Curve.prototype.refineTforY = function (t0, yt0, y0) {
                    var t1 = 1;
                    while ((true)) {
                        var th = (t0 + t1) / 2;
                        if (th === t0 || th === t1) {
                            return t1;
                        }
                        var y = this.YforT(th);
                        if (y < y0) {
                            t0 = th;
                            yt0 = y;
                        }
                        else if (y > y0) {
                            t1 = th;
                        }
                        else {
                            return t1;
                        }
                    }
                    ;
                };
                Curve.prototype.fairlyClose = function (v1, v2) {
                    return (Math.abs(v1 - v2) < Math.max(Math.abs(v1), Math.abs(v2)) * 1.0E-10);
                };
                return Curve;
            }());
            Curve.INCREASING = 1;
            Curve.DECREASING = -1;
            /**
             * The rectangle intersection test counts the number of times that the path
             * crosses through the shadow that the rectangle projects to the right
             * towards (x => +INFINITY).
             *
             * During processing of the path it actually counts every time the path
             * crosses either or both of the top and bottom edges of that shadow. If the
             * path enters from the top, the count is incremented. If it then exits back
             * through the top, the same way it came in, the count is decremented and
             * there is no impact on the winding count. If, instead, the path exits out
             * the bottom, then the count is incremented again and a full pass through
             * the shadow is indicated by the winding count having been incremented by
             * 2.
             *
             * Thus, the winding count that it accumulates is actually double the real
             * winding count. Since the path is continuous, the final answer should be a
             * multiple of 2, otherwise there is a logic error somewhere.
             *
             * If the path ever has a direct hit on the rectangle, then a special value
             * is returned. This special value terminates all ongoing accumulation on up
             * through the call chain and ends up getting returned to the calling
             * function which can then produce an answer directly. For intersection
             * tests, the answer is always "true" if the path intersects the rectangle.
             * For containment tests, the answer is always "false" if the path
             * intersects the rectangle. Thus, no further processing is ever needed if
             * an intersection occurs.
             */
            Curve.RECT_INTERSECTS = -2147483648;
            Curve.TMIN = 0.001;
            geom.Curve = Curve;
            Curve["__class"] = "sun.awt.geom.Curve";
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var CurveLink = (function () {
                function CurveLink(curve, ystart, yend, etag) {
                    this.curve = null;
                    this.ytop = 0;
                    this.ybot = 0;
                    this.etag = 0;
                    this.next = null;
                    this.curve = curve;
                    this.ytop = ystart;
                    this.ybot = yend;
                    this.etag = etag;
                    if (this.ytop < curve.getYTop() || this.ybot > curve.getYBot()) {
                        throw Object.defineProperty(new Error("bad curvelink [" + this.ytop + "=>" + this.ybot + "] for " + curve), '__class', { configurable: true, value: 'java.lang.InternalError' });
                    }
                }
                CurveLink.prototype.absorb$sun_awt_geom_CurveLink = function (link) {
                    return this.absorb$sun_awt_geom_Curve$double$double$int(link.curve, link.ytop, link.ybot, link.etag);
                };
                CurveLink.prototype.absorb$sun_awt_geom_Curve$double$double$int = function (curve, ystart, yend, etag) {
                    if (this.curve !== curve || this.etag !== etag || this.ybot < ystart || this.ytop > yend) {
                        return false;
                    }
                    if (ystart < curve.getYTop() || yend > curve.getYBot()) {
                        throw Object.defineProperty(new Error("bad curvelink [" + ystart + "=>" + yend + "] for " + curve), '__class', { configurable: true, value: 'java.lang.InternalError' });
                    }
                    this.ytop = Math.min(this.ytop, ystart);
                    this.ybot = Math.max(this.ybot, yend);
                    return true;
                };
                CurveLink.prototype.absorb = function (curve, ystart, yend, etag) {
                    if (((curve != null && curve instanceof sun.awt.geom.Curve) || curve === null) && ((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && ((typeof etag === 'number') || etag === null)) {
                        return this.absorb$sun_awt_geom_Curve$double$double$int(curve, ystart, yend, etag);
                    }
                    else if (((curve != null && curve instanceof sun.awt.geom.CurveLink) || curve === null) && ystart === undefined && yend === undefined && etag === undefined) {
                        return this.absorb$sun_awt_geom_CurveLink(curve);
                    }
                    else
                        throw new Error('invalid overload');
                };
                CurveLink.prototype.isEmpty = function () {
                    return (this.ytop === this.ybot);
                };
                CurveLink.prototype.getCurve = function () {
                    return this.curve;
                };
                CurveLink.prototype.getSubCurve = function () {
                    if (this.ytop === this.curve.getYTop() && this.ybot === this.curve.getYBot()) {
                        return this.curve.getWithDirection(this.etag);
                    }
                    return this.curve.getSubCurve$double$double$int(this.ytop, this.ybot, this.etag);
                };
                CurveLink.prototype.getMoveto = function () {
                    return new sun.awt.geom.Order0(this.getXTop(), this.getYTop());
                };
                CurveLink.prototype.getXTop = function () {
                    return this.curve.XforY(this.ytop);
                };
                CurveLink.prototype.getYTop = function () {
                    return this.ytop;
                };
                CurveLink.prototype.getXBot = function () {
                    return this.curve.XforY(this.ybot);
                };
                CurveLink.prototype.getYBot = function () {
                    return this.ybot;
                };
                CurveLink.prototype.getX = function () {
                    return this.curve.XforY(this.ytop);
                };
                CurveLink.prototype.getEdgeTag = function () {
                    return this.etag;
                };
                CurveLink.prototype.setNext = function (link) {
                    this.next = link;
                };
                CurveLink.prototype.getNext = function () {
                    return this.next;
                };
                return CurveLink;
            }());
            geom.CurveLink = CurveLink;
            CurveLink["__class"] = "sun.awt.geom.CurveLink";
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var Edge = (function () {
                function Edge(c, ctag, etag) {
                    var _this = this;
                    if (((c != null && c instanceof sun.awt.geom.Curve) || c === null) && ((typeof ctag === 'number') || ctag === null) && ((typeof etag === 'number') || etag === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        this.curve = null;
                        this.ctag = 0;
                        this.etag = 0;
                        this.activey = 0;
                        this.equivalence = 0;
                        this.lastEdge = null;
                        this.lastResult = 0;
                        this.lastLimit = 0;
                        this.curve = null;
                        this.ctag = 0;
                        this.etag = 0;
                        this.activey = 0;
                        this.equivalence = 0;
                        this.lastEdge = null;
                        this.lastResult = 0;
                        this.lastLimit = 0;
                        (function () {
                            _this.curve = c;
                            _this.ctag = ctag;
                            _this.etag = etag;
                        })();
                    }
                    else if (((c != null && c instanceof sun.awt.geom.Curve) || c === null) && ((typeof ctag === 'number') || ctag === null) && etag === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        {
                            var __args_2 = Array.prototype.slice.call(arguments);
                            var etag_1 = sun.awt.geom.AreaOp.ETAG_IGNORE;
                            this.curve = null;
                            this.ctag = 0;
                            this.etag = 0;
                            this.activey = 0;
                            this.equivalence = 0;
                            this.lastEdge = null;
                            this.lastResult = 0;
                            this.lastLimit = 0;
                            this.curve = null;
                            this.ctag = 0;
                            this.etag = 0;
                            this.activey = 0;
                            this.equivalence = 0;
                            this.lastEdge = null;
                            this.lastResult = 0;
                            this.lastLimit = 0;
                            (function () {
                                _this.curve = c;
                                _this.ctag = ctag;
                                _this.etag = etag_1;
                            })();
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                Edge.prototype.getCurve = function () {
                    return this.curve;
                };
                Edge.prototype.getCurveTag = function () {
                    return this.ctag;
                };
                Edge.prototype.getEdgeTag = function () {
                    return this.etag;
                };
                Edge.prototype.setEdgeTag = function (etag) {
                    this.etag = etag;
                };
                Edge.prototype.getEquivalence = function () {
                    return this.equivalence;
                };
                Edge.prototype.setEquivalence = function (eq) {
                    this.equivalence = eq;
                };
                Edge.prototype.compareTo = function (other, yrange) {
                    if (other === this.lastEdge && yrange[0] < this.lastLimit) {
                        if (yrange[1] > this.lastLimit) {
                            yrange[1] = this.lastLimit;
                        }
                        return this.lastResult;
                    }
                    if (this === other.lastEdge && yrange[0] < other.lastLimit) {
                        if (yrange[1] > other.lastLimit) {
                            yrange[1] = other.lastLimit;
                        }
                        return 0 - other.lastResult;
                    }
                    var ret = this.curve.compareTo(other.curve, yrange);
                    this.lastEdge = other;
                    this.lastLimit = yrange[1];
                    this.lastResult = ret;
                    return ret;
                };
                Edge.prototype.record = function (yend, etag) {
                    this.activey = yend;
                    this.etag = etag;
                };
                Edge.prototype.isActiveFor = function (y, etag) {
                    return (this.etag === etag && this.activey >= y);
                };
                Edge.prototype.toString = function () {
                    return ("Edge[" + this.curve + ", " + (this.ctag === sun.awt.geom.AreaOp.CTAG_LEFT ? "L" : "R") + ", " + (this.etag === sun.awt.geom.AreaOp.ETAG_ENTER ? "I" : (this.etag === sun.awt.geom.AreaOp.ETAG_EXIT ? "O" : "N")) + "]");
                };
                return Edge;
            }());
            Edge.INIT_PARTS = 4;
            Edge.GROW_PARTS = 10;
            geom.Edge = Edge;
            Edge["__class"] = "sun.awt.geom.Edge";
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
/**
 * Constructs a new {@code Path2D} object from the given specified initial
 * values. This method is only intended for internal use and should not be
 * made public if the other constructors for this class are ever exposed.
 *
 * @param {number} rule
 * the winding rule
 * @param {number} initialTypes
 * the size to make the initial array to store the path segment
 * types
 * @since 1.6
 * @class
 */
var Path2D = (function () {
    function Path2D(rule, initialTypes) {
        var _this = this;
        if (((typeof rule === 'number') || rule === null) && ((typeof initialTypes === 'number') || initialTypes === null)) {
            var __args = Array.prototype.slice.call(arguments);
            this.pointTypes = null;
            this.numTypes = 0;
            this.numCoords = 0;
            this.windingRule = 0;
            this.pointTypes = null;
            this.numTypes = 0;
            this.numCoords = 0;
            this.windingRule = 0;
            (function () {
                _this.setWindingRule(rule);
                _this.pointTypes = (function (s) { var a = []; while (s-- > 0)
                    a.push(0); return a; })(initialTypes);
            })();
        }
        else if (rule === undefined && initialTypes === undefined) {
            var __args = Array.prototype.slice.call(arguments);
            this.pointTypes = null;
            this.numTypes = 0;
            this.numCoords = 0;
            this.windingRule = 0;
            this.pointTypes = null;
            this.numTypes = 0;
            this.numCoords = 0;
            this.windingRule = 0;
        }
        else
            throw new Error('invalid overload');
    }
    Path2D.WIND_EVEN_ODD_$LI$ = function () { if (Path2D.WIND_EVEN_ODD == null)
        Path2D.WIND_EVEN_ODD = PathIterator.WIND_EVEN_ODD; return Path2D.WIND_EVEN_ODD; };
    ;
    Path2D.WIND_NON_ZERO_$LI$ = function () { if (Path2D.WIND_NON_ZERO == null)
        Path2D.WIND_NON_ZERO = PathIterator.WIND_NON_ZERO; return Path2D.WIND_NON_ZERO; };
    ;
    Path2D.SEG_MOVETO_$LI$ = function () { if (Path2D.SEG_MOVETO == null)
        Path2D.SEG_MOVETO = (PathIterator.SEG_MOVETO | 0); return Path2D.SEG_MOVETO; };
    ;
    Path2D.SEG_LINETO_$LI$ = function () { if (Path2D.SEG_LINETO == null)
        Path2D.SEG_LINETO = (PathIterator.SEG_LINETO | 0); return Path2D.SEG_LINETO; };
    ;
    Path2D.SEG_QUADTO_$LI$ = function () { if (Path2D.SEG_QUADTO == null)
        Path2D.SEG_QUADTO = (PathIterator.SEG_QUADTO | 0); return Path2D.SEG_QUADTO; };
    ;
    Path2D.SEG_CUBICTO_$LI$ = function () { if (Path2D.SEG_CUBICTO == null)
        Path2D.SEG_CUBICTO = (PathIterator.SEG_CUBICTO | 0); return Path2D.SEG_CUBICTO; };
    ;
    Path2D.SEG_CLOSE_$LI$ = function () { if (Path2D.SEG_CLOSE == null)
        Path2D.SEG_CLOSE = (PathIterator.SEG_CLOSE | 0); return Path2D.SEG_CLOSE; };
    ;
    Path2D.prototype.append$float$float = function (x, y) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
    Path2D.prototype.append$double$double = function (x, y) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
    /**
     * Adds a point to the path by moving to the specified coordinates
     * specified in float precision.
     * <p>
     * This method provides a single precision variant of the double
     * precision {@code moveTo()} method on the base {@code Path2D} class.
     *
     * @param {number} x
     * the specified X coordinate
     * @param {number} y
     * the specified Y coordinate
     * @see Path2D#moveTo
     * @since 1.6
     */
    Path2D.prototype.moveTo = function (x, y) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
            return this.moveTo$double$double(x, y);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Adds a point to the path by moving to the specified coordinates specified
     * in double precision.
     *
     * @param {number} x
     * the specified X coordinate
     * @param {number} y
     * the specified Y coordinate
     * @since 1.6
     */
    Path2D.prototype.moveTo$double$double = function (x, y) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
    /**
     * Adds a point to the path by drawing a straight line from the current
     * coordinates to the new specified coordinates specified in float
     * precision.
     * <p>
     * This method provides a single precision variant of the double
     * precision {@code lineTo()} method on the base {@code Path2D} class.
     *
     * @param {number} x
     * the specified X coordinate
     * @param {number} y
     * the specified Y coordinate
     * @see Path2D#lineTo
     * @since 1.6
     */
    Path2D.prototype.lineTo = function (x, y) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
            return this.lineTo$double$double(x, y);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Adds a point to the path by drawing a straight line from the current
     * coordinates to the new specified coordinates specified in double
     * precision.
     *
     * @param {number} x
     * the specified X coordinate
     * @param {number} y
     * the specified Y coordinate
     * @since 1.6
     */
    Path2D.prototype.lineTo$double$double = function (x, y) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
    /**
     * Adds a curved segment, defined by two new points, to the path by
     * drawing a Quadratic curve that intersects both the current
     * coordinates and the specified coordinates {@code (x2,y2)}, using the
     * specified point {@code (x1,y1)} as a quadratic parametric control
     * point. All coordinates are specified in float precision.
     * <p>
     * This method provides a single precision variant of the double
     * precision {@code quadTo()} method on the base {@code Path2D} class.
     *
     * @param {number} x1
     * the X coordinate of the quadratic control point
     * @param {number} y1
     * the Y coordinate of the quadratic control point
     * @param {number} x2
     * the X coordinate of the final end point
     * @param {number} y2
     * the Y coordinate of the final end point
     * @see Path2D#quadTo
     * @since 1.6
     */
    Path2D.prototype.quadTo = function (x1, y1, x2, y2) {
        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
            return this.quadTo$double$double$double$double(x1, y1, x2, y2);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Adds a curved segment, defined by two new points, to the path by drawing
     * a Quadratic curve that intersects both the current coordinates and the
     * specified coordinates {@code (x2,y2)}, using the specified point
     * {@code (x1,y1)} as a quadratic parametric control point. All coordinates
     * are specified in double precision.
     *
     * @param {number} x1
     * the X coordinate of the quadratic control point
     * @param {number} y1
     * the Y coordinate of the quadratic control point
     * @param {number} x2
     * the X coordinate of the final end point
     * @param {number} y2
     * the Y coordinate of the final end point
     * @since 1.6
     */
    Path2D.prototype.quadTo$double$double$double$double = function (x1, y1, x2, y2) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
    /**
     * Adds a curved segment, defined by three new points, to the path by
     * drawing a B&eacute;zier curve that intersects both the current
     * coordinates and the specified coordinates {@code (x3,y3)}, using the
     * specified points {@code (x1,y1)} and {@code (x2,y2)} as B&eacute;zier
     * control points. All coordinates are specified in float precision.
     * <p>
     * This method provides a single precision variant of the double
     * precision {@code curveTo()} method on the base {@code Path2D} class.
     *
     * @param {number} x1
     * the X coordinate of the first B&eacute;zier control point
     * @param {number} y1
     * the Y coordinate of the first B&eacute;zier control point
     * @param {number} x2
     * the X coordinate of the second B&eacute;zier control point
     * @param {number} y2
     * the Y coordinate of the second B&eacute;zier control point
     * @param {number} x3
     * the X coordinate of the final end point
     * @param {number} y3
     * the Y coordinate of the final end point
     * @see Path2D#curveTo
     * @since 1.6
     */
    Path2D.prototype.curveTo = function (x1, y1, x2, y2, x3, y3) {
        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null) && ((typeof x3 === 'number') || x3 === null) && ((typeof y3 === 'number') || y3 === null)) {
            return this.curveTo$double$double$double$double$double$double(x1, y1, x2, y2, x3, y3);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Adds a curved segment, defined by three new points, to the path by
     * drawing a B&eacute;zier curve that intersects both the current
     * coordinates and the specified coordinates {@code (x3,y3)}, using the
     * specified points {@code (x1,y1)} and {@code (x2,y2)} as B&eacute;zier
     * control points. All coordinates are specified in double precision.
     *
     * @param {number} x1
     * the X coordinate of the first B&eacute;zier control point
     * @param {number} y1
     * the Y coordinate of the first B&eacute;zier control point
     * @param {number} x2
     * the X coordinate of the second B&eacute;zier control point
     * @param {number} y2
     * the Y coordinate of the second B&eacute;zier control point
     * @param {number} x3
     * the X coordinate of the final end point
     * @param {number} y3
     * the Y coordinate of the final end point
     * @since 1.6
     */
    Path2D.prototype.curveTo$double$double$double$double$double$double = function (x1, y1, x2, y2, x3, y3) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
    /**
     * Closes the current subpath by drawing a straight line back to the
     * coordinates of the last {@code moveTo}. If the path is already closed
     * then this method has no effect.
     *
     * @since 1.6
     */
    Path2D.prototype.closePath = function () {
        if (this.numTypes === 0 || this.pointTypes[this.numTypes - 1] !== Path2D.SEG_CLOSE_$LI$()) {
            this.needRoom(true, 0);
            this.pointTypes[this.numTypes++] = Path2D.SEG_CLOSE_$LI$();
        }
    };
    /**
     * Appends the geometry of the specified {@code Shape} object to the path,
     * possibly connecting the new geometry to the existing path segments with a
     * line segment. If the {@code connect} parameter is {@code true} and the
     * path is not empty then any initial {@code moveTo} in the geometry of the
     * appended {@code Shape} is turned into a {@code lineTo} segment. If the
     * destination coordinates of such a connecting {@code lineTo} segment match
     * the ending coordinates of a currently open subpath then the segment is
     * omitted as superfluous. The winding rule of the specified {@code Shape}
     * is ignored and the appended geometry is governed by the winding rule
     * specified for this path.
     *
     * @param {java.awt.Shape} s
     * the {@code Shape} whose geometry is appended to this path
     * @param {boolean} connect
     * a boolean to control whether or not to turn an initial
     * {@code moveTo} segment into a {@code lineTo} segment to
     * connect the new geometry to the existing path
     * @since 1.6
     */
    Path2D.prototype.append$java_awt_Shape$boolean = function (s, connect) {
        this.append$java_awt_geom_PathIterator$boolean(s['getPathIterator$java_awt_geom_AffineTransform'](null), connect);
    };
    /**
     * Appends the geometry of the specified {@code Shape} object to the path,
     * possibly connecting the new geometry to the existing path segments with a
     * line segment. If the {@code connect} parameter is {@code true} and the
     * path is not empty then any initial {@code moveTo} in the geometry of the
     * appended {@code Shape} is turned into a {@code lineTo} segment. If the
     * destination coordinates of such a connecting {@code lineTo} segment match
     * the ending coordinates of a currently open subpath then the segment is
     * omitted as superfluous. The winding rule of the specified {@code Shape}
     * is ignored and the appended geometry is governed by the winding rule
     * specified for this path.
     *
     * @param {java.awt.Shape} s
     * the {@code Shape} whose geometry is appended to this path
     * @param {boolean} connect
     * a boolean to control whether or not to turn an initial
     * {@code moveTo} segment into a {@code lineTo} segment to
     * connect the new geometry to the existing path
     * @since 1.6
     */
    Path2D.prototype.append = function (s, connect) {
        if (((s != null && (s["__interfaces"] != null && s["__interfaces"].indexOf("java.awt.Shape") >= 0 || s.constructor != null && s.constructor["__interfaces"] != null && s.constructor["__interfaces"].indexOf("java.awt.Shape") >= 0)) || s === null) && ((typeof connect === 'boolean') || connect === null)) {
            return this.append$java_awt_Shape$boolean(s, connect);
        }
        else if (((s != null && (s["__interfaces"] != null && s["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || s.constructor != null && s.constructor["__interfaces"] != null && s.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || s === null) && ((typeof connect === 'boolean') || connect === null)) {
            return this.append$java_awt_geom_PathIterator$boolean(s, connect);
        }
        else if (((typeof s === 'number') || s === null) && ((typeof connect === 'number') || connect === null)) {
            return this.append$float$float(s, connect);
        }
        else if (((typeof s === 'number') || s === null) && ((typeof connect === 'number') || connect === null)) {
            return this.append$double$double(s, connect);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Appends the geometry of the specified {@link PathIterator} object to the
     * path, possibly connecting the new geometry to the existing path segments
     * with a line segment. If the {@code connect} parameter is {@code true} and
     * the path is not empty then any initial {@code moveTo} in the geometry of
     * the appended {@code Shape} is turned into a {@code lineTo} segment. If
     * the destination coordinates of such a connecting {@code lineTo} segment
     * match the ending coordinates of a currently open subpath then the segment
     * is omitted as superfluous. The winding rule of the specified
     * {@code Shape} is ignored and the appended geometry is governed by the
     * winding rule specified for this path.
     *
     * @param {PathIterator} pi
     * the {@code PathIterator} whose geometry is appended to this
     * path
     * @param {boolean} connect
     * a boolean to control whether or not to turn an initial
     * {@code moveTo} segment into a {@code lineTo} segment to
     * connect the new geometry to the existing path
     * @since 1.6
     */
    Path2D.prototype.append$java_awt_geom_PathIterator$boolean = function (pi, connect) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
    /**
     * Returns the fill style winding rule.
     *
     * @return {number} an integer representing the current winding rule.
     * @see #WIND_EVEN_ODD
     * @see #WIND_NON_ZERO
     * @see #setWindingRule
     * @since 1.6
     */
    Path2D.prototype.getWindingRule = function () {
        return this.windingRule;
    };
    /**
     * Sets the winding rule for this path to the specified value.
     *
     * @param {number} rule
     * an integer representing the specified winding rule
     * @exception IllegalArgumentException
     * if {@code rule} is not either {@link #WIND_EVEN_ODD} or
     * {@link #WIND_NON_ZERO}
     * @see #getWindingRule
     * @since 1.6
     */
    Path2D.prototype.setWindingRule = function (rule) {
        if (rule !== Path2D.WIND_EVEN_ODD_$LI$() && rule !== Path2D.WIND_NON_ZERO_$LI$()) {
            throw Object.defineProperty(new Error("winding rule must be WIND_EVEN_ODD or WIND_NON_ZERO"), '__class', { configurable: true, value: 'java.lang.IllegalArgumentException' });
        }
        this.windingRule = rule;
    };
    /**
     * Returns the coordinates most recently added to the end of the path as a
     * {@link Point2D} object.
     *
     * @return {Point2D} a {@code Point2D} object containing the ending coordinates of the
     * path or {@code null} if there are no points in the path.
     * @since 1.6
     */
    Path2D.prototype.getCurrentPoint = function () {
        var index = this.numCoords;
        if (this.numTypes < 1 || index < 1) {
            return null;
        }
        if (this.pointTypes[this.numTypes - 1] === Path2D.SEG_CLOSE_$LI$()) {
            loop: for (var i = this.numTypes - 2; i > 0; i--) {
                switch ((this.pointTypes[i])) {
                    case Path2D.SEG_MOVETO_$LI$():
                        break loop;
                    case Path2D.SEG_LINETO_$LI$():
                        index -= 2;
                        break;
                    case Path2D.SEG_QUADTO_$LI$():
                        index -= 4;
                        break;
                    case Path2D.SEG_CUBICTO_$LI$():
                        index -= 6;
                        break;
                    case Path2D.SEG_CLOSE_$LI$():
                        break;
                }
            }
        }
        return this.getPoint(index - 2);
    };
    /**
     * Resets the path to empty. The append position is set back to the
     * beginning of the path and all coordinates and point types are forgotten.
     *
     * @since 1.6
     */
    Path2D.prototype.reset = function () {
        this.numTypes = this.numCoords = 0;
    };
    /**
     * Returns a new {@code Shape} representing a transformed version of this
     * {@code Path2D}. Note that the exact type and coordinate precision of the
     * return value is not specified for this method. The method will return a
     * Shape that contains no less precision for the transformed geometry than
     * this {@code Path2D} currently maintains, but it may contain no more
     * precision either. If the tradeoff of precision vs. storage size in the
     * result is important then the convenience constructors in the
     * {@link Path2D.Float#Path2D.Float(Shape, AffineTransform) Path2D.Float}
     * and {@link Path2D.Double#Path2D.Double(Shape, AffineTransform)
     * Path2D.Double} subclasses should be used to make the choice explicit.
     *
     * @param {AffineTransform} at
     * the {@code AffineTransform} used to transform a new
     * {@code Shape}.
     * @return {java.awt.Shape} a new {@code Shape}, transformed with the specified
     * {@code AffineTransform}.
     * @since 1.6
     */
    Path2D.prototype.createTransformedShape = function (at) {
        var p2d = this.clone();
        if (at != null) {
            p2d.transform(at);
        }
        return p2d;
    };
    /**
     * Tests if the specified coordinates are inside the closed boundary of the
     * specified {@link PathIterator}.
     * <p>
     * This method provides a basic facility for implementors of the
     * {@link Shape} interface to implement support for the
     * {@link Shape#contains(double, double)} method.
     *
     * @param {PathIterator} pi
     * the specified {@code PathIterator}
     * @param {number} x
     * the specified X coordinate
     * @param {number} y
     * the specified Y coordinate
     * @return {boolean} {@code true} if the specified coordinates are inside the
     * specified {@code PathIterator}; {@code false} otherwise
     * @since 1.6
     */
    Path2D.contains$java_awt_geom_PathIterator$double$double = function (pi, x, y) {
        if (x * 0.0 + y * 0.0 === 0.0) {
            var mask = (pi.getWindingRule() === Path2D.WIND_NON_ZERO_$LI$() ? -1 : 1);
            var cross = sun.awt.geom.Curve.pointCrossingsForPath(pi, x, y);
            return ((cross & mask) !== 0);
        }
        else {
            return false;
        }
    };
    /**
     * Tests if the specified {@link Point2D} is inside the closed boundary of
     * the specified {@link PathIterator}.
     * <p>
     * This method provides a basic facility for implementors of the
     * {@link Shape} interface to implement support for the
     * {@link Shape#contains(Point2D)} method.
     *
     * @param {PathIterator} pi
     * the specified {@code PathIterator}
     * @param {Point2D} p
     * the specified {@code Point2D}
     * @return {boolean} {@code true} if the specified coordinates are inside the
     * specified {@code PathIterator}; {@code false} otherwise
     * @since 1.6
     */
    Path2D.contains$java_awt_geom_PathIterator$java_awt_geom_Point2D = function (pi, p) {
        return Path2D.contains$java_awt_geom_PathIterator$double$double(pi, p.getX(), p.getY());
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.6
     * @param {number} x
     * @param {number} y
     * @return {boolean}
     */
    Path2D.prototype.contains$double$double = function (x, y) {
        if (x * 0.0 + y * 0.0 === 0.0) {
            if (this.numTypes < 2) {
                return false;
            }
            var mask = (this.windingRule === Path2D.WIND_NON_ZERO_$LI$() ? -1 : 1);
            return ((this.pointCrossings(x, y) & mask) !== 0);
        }
        else {
            return false;
        }
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.6
     * @param {Point2D} p
     * @return {boolean}
     */
    Path2D.prototype.contains$java_awt_geom_Point2D = function (p) {
        return this.contains$double$double(p.getX(), p.getY());
    };
    /**
     * Tests if the specified rectangular area is entirely inside the closed
     * boundary of the specified {@link PathIterator}.
     * <p>
     * This method provides a basic facility for implementors of the
     * {@link Shape} interface to implement support for the
     * {@link Shape#contains(double, double, double, double)} method.
     * <p>
     * This method object may conservatively return false in cases where the
     * specified rectangular area intersects a segment of the path, but that
     * segment does not represent a boundary between the interior and exterior
     * of the path. Such segments could lie entirely within the interior of the
     * path if they are part of a path with a {@link #WIND_NON_ZERO} winding
     * rule or if the segments are retraced in the reverse direction such that
     * the two sets of segments cancel each other out without any exterior area
     * falling between them. To determine whether segments represent true
     * boundaries of the interior of the path would require extensive
     * calculations involving all of the segments of the path and the winding
     * rule and are thus beyond the scope of this implementation.
     *
     * @param {PathIterator} pi
     * the specified {@code PathIterator}
     * @param {number} x
     * the specified X coordinate
     * @param {number} y
     * the specified Y coordinate
     * @param {number} w
     * the width of the specified rectangular area
     * @param {number} h
     * the height of the specified rectangular area
     * @return {boolean} {@code true} if the specified {@code PathIterator} contains the
     * specified rectangular area; {@code false} otherwise.
     * @since 1.6
     */
    Path2D.contains$java_awt_geom_PathIterator$double$double$double$double = function (pi, x, y, w, h) {
        if (isNaN(x + w) || isNaN(y + h)) {
            return false;
        }
        if (w <= 0 || h <= 0) {
            return false;
        }
        var mask = (pi.getWindingRule() === Path2D.WIND_NON_ZERO_$LI$() ? -1 : 2);
        var crossings = sun.awt.geom.Curve.rectCrossingsForPath(pi, x, y, x + w, y + h);
        return (crossings !== sun.awt.geom.Curve.RECT_INTERSECTS && (crossings & mask) !== 0);
    };
    /**
     * Tests if the specified rectangular area is entirely inside the closed
     * boundary of the specified {@link PathIterator}.
     * <p>
     * This method provides a basic facility for implementors of the
     * {@link Shape} interface to implement support for the
     * {@link Shape#contains(double, double, double, double)} method.
     * <p>
     * This method object may conservatively return false in cases where the
     * specified rectangular area intersects a segment of the path, but that
     * segment does not represent a boundary between the interior and exterior
     * of the path. Such segments could lie entirely within the interior of the
     * path if they are part of a path with a {@link #WIND_NON_ZERO} winding
     * rule or if the segments are retraced in the reverse direction such that
     * the two sets of segments cancel each other out without any exterior area
     * falling between them. To determine whether segments represent true
     * boundaries of the interior of the path would require extensive
     * calculations involving all of the segments of the path and the winding
     * rule and are thus beyond the scope of this implementation.
     *
     * @param {PathIterator} pi
     * the specified {@code PathIterator}
     * @param {number} x
     * the specified X coordinate
     * @param {number} y
     * the specified Y coordinate
     * @param {number} w
     * the width of the specified rectangular area
     * @param {number} h
     * the height of the specified rectangular area
     * @return {boolean} {@code true} if the specified {@code PathIterator} contains the
     * specified rectangular area; {@code false} otherwise.
     * @since 1.6
     */
    Path2D.contains = function (pi, x, y, w, h) {
        if (((pi != null && (pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || pi.constructor != null && pi.constructor["__interfaces"] != null && pi.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || pi === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
            return Path2D.contains$java_awt_geom_PathIterator$double$double$double$double(pi, x, y, w, h);
        }
        else if (((pi != null && (pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || pi.constructor != null && pi.constructor["__interfaces"] != null && pi.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || pi === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined) {
            return Path2D.contains$java_awt_geom_PathIterator$double$double(pi, x, y);
        }
        else if (((pi != null && (pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || pi.constructor != null && pi.constructor["__interfaces"] != null && pi.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || pi === null) && ((x != null && x instanceof Point2D) || x === null) && y === undefined && w === undefined && h === undefined) {
            return Path2D.contains$java_awt_geom_PathIterator$java_awt_geom_Point2D(pi, x);
        }
        else if (((pi != null && (pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || pi.constructor != null && pi.constructor["__interfaces"] != null && pi.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || pi === null) && ((x != null && x instanceof Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
            return Path2D.contains$java_awt_geom_PathIterator$java_awt_geom_Rectangle2D(pi, x);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Tests if the specified {@link Rectangle2D} is entirely inside the closed
     * boundary of the specified {@link PathIterator}.
     * <p>
     * This method provides a basic facility for implementors of the
     * {@link Shape} interface to implement support for the
     * {@link Shape#contains(Rectangle2D)} method.
     * <p>
     * This method object may conservatively return false in cases where the
     * specified rectangular area intersects a segment of the path, but that
     * segment does not represent a boundary between the interior and exterior
     * of the path. Such segments could lie entirely within the interior of the
     * path if they are part of a path with a {@link #WIND_NON_ZERO} winding
     * rule or if the segments are retraced in the reverse direction such that
     * the two sets of segments cancel each other out without any exterior area
     * falling between them. To determine whether segments represent true
     * boundaries of the interior of the path would require extensive
     * calculations involving all of the segments of the path and the winding
     * rule and are thus beyond the scope of this implementation.
     *
     * @param {PathIterator} pi
     * the specified {@code PathIterator}
     * @param {Rectangle2D} r
     * a specified {@code Rectangle2D}
     * @return {boolean} {@code true} if the specified {@code PathIterator} contains the
     * specified {@code Rectangle2D}; {@code false} otherwise.
     * @since 1.6
     */
    Path2D.contains$java_awt_geom_PathIterator$java_awt_geom_Rectangle2D = function (pi, r) {
        return Path2D.contains$java_awt_geom_PathIterator$double$double$double$double(pi, r.getX(), r.getY(), r.getWidth(), r.getHeight());
    };
    /**
     * {@inheritDoc}
     * <p>
     * This method object may conservatively return false in cases where the
     * specified rectangular area intersects a segment of the path, but that
     * segment does not represent a boundary between the interior and exterior
     * of the path. Such segments could lie entirely within the interior of the
     * path if they are part of a path with a {@link #WIND_NON_ZERO} winding
     * rule or if the segments are retraced in the reverse direction such that
     * the two sets of segments cancel each other out without any exterior area
     * falling between them. To determine whether segments represent true
     * boundaries of the interior of the path would require extensive
     * calculations involving all of the segments of the path and the winding
     * rule and are thus beyond the scope of this implementation.
     *
     * @since 1.6
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @return {boolean}
     */
    Path2D.prototype.contains$double$double$double$double = function (x, y, w, h) {
        if (isNaN(x + w) || isNaN(y + h)) {
            return false;
        }
        if (w <= 0 || h <= 0) {
            return false;
        }
        var mask = (this.windingRule === Path2D.WIND_NON_ZERO_$LI$() ? -1 : 2);
        var crossings = this.rectCrossings(x, y, x + w, y + h);
        return (crossings !== sun.awt.geom.Curve.RECT_INTERSECTS && (crossings & mask) !== 0);
    };
    /**
     * {@inheritDoc}
     * <p>
     * This method object may conservatively return false in cases where the
     * specified rectangular area intersects a segment of the path, but that
     * segment does not represent a boundary between the interior and exterior
     * of the path. Such segments could lie entirely within the interior of the
     * path if they are part of a path with a {@link #WIND_NON_ZERO} winding
     * rule or if the segments are retraced in the reverse direction such that
     * the two sets of segments cancel each other out without any exterior area
     * falling between them. To determine whether segments represent true
     * boundaries of the interior of the path would require extensive
     * calculations involving all of the segments of the path and the winding
     * rule and are thus beyond the scope of this implementation.
     *
     * @since 1.6
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @return {boolean}
     */
    Path2D.prototype.contains = function (x, y, w, h) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
            return this.contains$double$double$double$double(x, y, w, h);
        }
        else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined) {
            return this.contains$double$double(x, y);
        }
        else if (((x != null && x instanceof Point2D) || x === null) && y === undefined && w === undefined && h === undefined) {
            return this.contains$java_awt_geom_Point2D(x);
        }
        else if (((x != null && x instanceof Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
            return this.contains$java_awt_geom_Rectangle2D(x);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * {@inheritDoc}
     * <p>
     * This method object may conservatively return false in cases where the
     * specified rectangular area intersects a segment of the path, but that
     * segment does not represent a boundary between the interior and exterior
     * of the path. Such segments could lie entirely within the interior of the
     * path if they are part of a path with a {@link #WIND_NON_ZERO} winding
     * rule or if the segments are retraced in the reverse direction such that
     * the two sets of segments cancel each other out without any exterior area
     * falling between them. To determine whether segments represent true
     * boundaries of the interior of the path would require extensive
     * calculations involving all of the segments of the path and the winding
     * rule and are thus beyond the scope of this implementation.
     *
     * @since 1.6
     * @param {Rectangle2D} r
     * @return {boolean}
     */
    Path2D.prototype.contains$java_awt_geom_Rectangle2D = function (r) {
        return this.contains$double$double$double$double(r.getX(), r.getY(), r.getWidth(), r.getHeight());
    };
    /**
     * Tests if the interior of the specified {@link PathIterator} intersects
     * the interior of a specified set of rectangular coordinates.
     * <p>
     * This method provides a basic facility for implementors of the
     * {@link Shape} interface to implement support for the
     * {@link Shape#intersects(double, double, double, double)} method.
     * <p>
     * This method object may conservatively return true in cases where the
     * specified rectangular area intersects a segment of the path, but that
     * segment does not represent a boundary between the interior and exterior
     * of the path. Such a case may occur if some set of segments of the path
     * are retraced in the reverse direction such that the two sets of segments
     * cancel each other out without any interior area between them. To
     * determine whether segments represent true boundaries of the interior of
     * the path would require extensive calculations involving all of the
     * segments of the path and the winding rule and are thus beyond the scope
     * of this implementation.
     *
     * @param {PathIterator} pi
     * the specified {@code PathIterator}
     * @param {number} x
     * the specified X coordinate
     * @param {number} y
     * the specified Y coordinate
     * @param {number} w
     * the width of the specified rectangular coordinates
     * @param {number} h
     * the height of the specified rectangular coordinates
     * @return {boolean} {@code true} if the specified {@code PathIterator} and the
     * interior of the specified set of rectangular coordinates
     * intersect each other; {@code false} otherwise.
     * @since 1.6
     */
    Path2D.intersects$java_awt_geom_PathIterator$double$double$double$double = function (pi, x, y, w, h) {
        if (isNaN(x + w) || isNaN(y + h)) {
            return false;
        }
        if (w <= 0 || h <= 0) {
            return false;
        }
        var mask = (pi.getWindingRule() === Path2D.WIND_NON_ZERO_$LI$() ? -1 : 2);
        var crossings = sun.awt.geom.Curve.rectCrossingsForPath(pi, x, y, x + w, y + h);
        return (crossings === sun.awt.geom.Curve.RECT_INTERSECTS || (crossings & mask) !== 0);
    };
    /**
     * Tests if the interior of the specified {@link PathIterator} intersects
     * the interior of a specified set of rectangular coordinates.
     * <p>
     * This method provides a basic facility for implementors of the
     * {@link Shape} interface to implement support for the
     * {@link Shape#intersects(double, double, double, double)} method.
     * <p>
     * This method object may conservatively return true in cases where the
     * specified rectangular area intersects a segment of the path, but that
     * segment does not represent a boundary between the interior and exterior
     * of the path. Such a case may occur if some set of segments of the path
     * are retraced in the reverse direction such that the two sets of segments
     * cancel each other out without any interior area between them. To
     * determine whether segments represent true boundaries of the interior of
     * the path would require extensive calculations involving all of the
     * segments of the path and the winding rule and are thus beyond the scope
     * of this implementation.
     *
     * @param {PathIterator} pi
     * the specified {@code PathIterator}
     * @param {number} x
     * the specified X coordinate
     * @param {number} y
     * the specified Y coordinate
     * @param {number} w
     * the width of the specified rectangular coordinates
     * @param {number} h
     * the height of the specified rectangular coordinates
     * @return {boolean} {@code true} if the specified {@code PathIterator} and the
     * interior of the specified set of rectangular coordinates
     * intersect each other; {@code false} otherwise.
     * @since 1.6
     */
    Path2D.intersects = function (pi, x, y, w, h) {
        if (((pi != null && (pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || pi.constructor != null && pi.constructor["__interfaces"] != null && pi.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || pi === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
            return Path2D.intersects$java_awt_geom_PathIterator$double$double$double$double(pi, x, y, w, h);
        }
        else if (((pi != null && (pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || pi.constructor != null && pi.constructor["__interfaces"] != null && pi.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || pi === null) && ((x != null && x instanceof Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
            return Path2D.intersects$java_awt_geom_PathIterator$java_awt_geom_Rectangle2D(pi, x);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Tests if the interior of the specified {@link PathIterator} intersects
     * the interior of a specified {@link Rectangle2D}.
     * <p>
     * This method provides a basic facility for implementors of the
     * {@link Shape} interface to implement support for the
     * {@link Shape#intersects(Rectangle2D)} method.
     * <p>
     * This method object may conservatively return true in cases where the
     * specified rectangular area intersects a segment of the path, but that
     * segment does not represent a boundary between the interior and exterior
     * of the path. Such a case may occur if some set of segments of the path
     * are retraced in the reverse direction such that the two sets of segments
     * cancel each other out without any interior area between them. To
     * determine whether segments represent true boundaries of the interior of
     * the path would require extensive calculations involving all of the
     * segments of the path and the winding rule and are thus beyond the scope
     * of this implementation.
     *
     * @param {PathIterator} pi
     * the specified {@code PathIterator}
     * @param {Rectangle2D} r
     * the specified {@code Rectangle2D}
     * @return {boolean} {@code true} if the specified {@code PathIterator} and the
     * interior of the specified {@code Rectangle2D} intersect each
     * other; {@code false} otherwise.
     * @since 1.6
     */
    Path2D.intersects$java_awt_geom_PathIterator$java_awt_geom_Rectangle2D = function (pi, r) {
        return Path2D.intersects$java_awt_geom_PathIterator$double$double$double$double(pi, r.getX(), r.getY(), r.getWidth(), r.getHeight());
    };
    /**
     * {@inheritDoc}
     * <p>
     * This method object may conservatively return true in cases where the
     * specified rectangular area intersects a segment of the path, but that
     * segment does not represent a boundary between the interior and exterior
     * of the path. Such a case may occur if some set of segments of the path
     * are retraced in the reverse direction such that the two sets of segments
     * cancel each other out without any interior area between them. To
     * determine whether segments represent true boundaries of the interior of
     * the path would require extensive calculations involving all of the
     * segments of the path and the winding rule and are thus beyond the scope
     * of this implementation.
     *
     * @since 1.6
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @return {boolean}
     */
    Path2D.prototype.intersects$double$double$double$double = function (x, y, w, h) {
        if (isNaN(x + w) || isNaN(y + h)) {
            return false;
        }
        if (w <= 0 || h <= 0) {
            return false;
        }
        var mask = (this.windingRule === Path2D.WIND_NON_ZERO_$LI$() ? -1 : 2);
        var crossings = this.rectCrossings(x, y, x + w, y + h);
        return (crossings === sun.awt.geom.Curve.RECT_INTERSECTS || (crossings & mask) !== 0);
    };
    /**
     * {@inheritDoc}
     * <p>
     * This method object may conservatively return true in cases where the
     * specified rectangular area intersects a segment of the path, but that
     * segment does not represent a boundary between the interior and exterior
     * of the path. Such a case may occur if some set of segments of the path
     * are retraced in the reverse direction such that the two sets of segments
     * cancel each other out without any interior area between them. To
     * determine whether segments represent true boundaries of the interior of
     * the path would require extensive calculations involving all of the
     * segments of the path and the winding rule and are thus beyond the scope
     * of this implementation.
     *
     * @since 1.6
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @return {boolean}
     */
    Path2D.prototype.intersects = function (x, y, w, h) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
            return this.intersects$double$double$double$double(x, y, w, h);
        }
        else if (((x != null && x instanceof Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
            return this.intersects$java_awt_geom_Rectangle2D(x);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * {@inheritDoc}
     * <p>
     * This method object may conservatively return true in cases where the
     * specified rectangular area intersects a segment of the path, but that
     * segment does not represent a boundary between the interior and exterior
     * of the path. Such a case may occur if some set of segments of the path
     * are retraced in the reverse direction such that the two sets of segments
     * cancel each other out without any interior area between them. To
     * determine whether segments represent true boundaries of the interior of
     * the path would require extensive calculations involving all of the
     * segments of the path and the winding rule and are thus beyond the scope
     * of this implementation.
     *
     * @since 1.6
     * @param {Rectangle2D} r
     * @return {boolean}
     */
    Path2D.prototype.intersects$java_awt_geom_Rectangle2D = function (r) {
        return this.intersects$double$double$double$double(r.getX(), r.getY(), r.getWidth(), r.getHeight());
    };
    /**
     * {@inheritDoc}
     * <p>
     * The iterator for this class is not multi-threaded safe, which means that
     * this {@code Path2D} class does not guarantee that modifications to the
     * geometry of this {@code Path2D} object do not affect any iterations of
     * that geometry that are already in process.
     *
     * @since 1.6
     * @param {AffineTransform} at
     * @param {number} flatness
     * @return {PathIterator}
     */
    Path2D.prototype.getPathIterator$java_awt_geom_AffineTransform$double = function (at, flatness) {
        return new FlatteningPathIterator(this['getPathIterator$java_awt_geom_AffineTransform'](at), flatness);
    };
    /**
     * {@inheritDoc}
     * <p>
     * The iterator for this class is not multi-threaded safe, which means that
     * this {@code Path2D} class does not guarantee that modifications to the
     * geometry of this {@code Path2D} object do not affect any iterations of
     * that geometry that are already in process.
     *
     * @since 1.6
     * @param {AffineTransform} at
     * @param {number} flatness
     * @return {PathIterator}
     */
    Path2D.prototype.getPathIterator = function (at, flatness) {
        if (((at != null && at instanceof AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
            return this.getPathIterator$java_awt_geom_AffineTransform$double(at, flatness);
        }
        else
            throw new Error('invalid overload');
    };
    return Path2D;
}());
Path2D.INIT_SIZE = 20;
Path2D.EXPAND_MAX = 500;
Path2D["__class"] = "Path2D";
Path2D["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable"];
(function (Path2D) {
    var Iterator = (function () {
        function Iterator(path) {
            this.typeIdx = 0;
            this.pointIdx = 0;
            this.path = null;
            this.path = path;
        }
        Iterator.curvecoords_$LI$ = function () { if (Iterator.curvecoords == null)
            Iterator.curvecoords = [2, 2, 4, 6, 0]; return Iterator.curvecoords; };
        ;
        Iterator.prototype.getWindingRule = function () {
            return this.path.getWindingRule();
        };
        Iterator.prototype.isDone = function () {
            return (this.typeIdx >= this.path.numTypes);
        };
        Iterator.prototype.next = function (doNext) {
            if (doNext === undefined) {
                return this.next$();
            }
            else
                throw new Error('invalid overload');
        };
        Iterator.prototype.next$ = function () {
            var type = this.path.pointTypes[this.typeIdx++];
            this.pointIdx += Iterator.curvecoords_$LI$()[type];
        };
        return Iterator;
    }());
    Path2D.Iterator = Iterator;
    Iterator["__class"] = "Path2D.Iterator";
    Iterator["__interfaces"] = ["java.awt.geom.PathIterator"];
    /**
     * Constructs a new empty single precision {@code Path2D} object with
     * the specified winding rule and the specified initial capacity to
     * store path segments. This number is an initial guess as to how many
     * path segments will be added to the path, but the storage is expanded
     * as needed to store whatever path segments are added.
     *
     * @param {number} rule
     * the winding rule
     * @param {number} initialCapacity
     * the estimate for the number of path segments in the path
     * @see #WIND_EVEN_ODD
     * @see #WIND_NON_ZERO
     * @since 1.6
     * @class
     */
    var Float = (function (_super) {
        __extends(Float, _super);
        function Float(s, at) {
            var _this = this;
            if (((s != null && (s["__interfaces"] != null && s["__interfaces"].indexOf("java.awt.Shape") >= 0 || s.constructor != null && s.constructor["__interfaces"] != null && s.constructor["__interfaces"].indexOf("java.awt.Shape") >= 0)) || s === null) && ((at != null && at instanceof AffineTransform) || at === null)) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this) || this;
                _this.floatCoords = null;
                _this.floatCoords = null;
                (function () {
                    if (s != null && s instanceof Path2D) {
                        var p2d = s;
                        _this.setWindingRule(p2d.windingRule);
                        _this.numTypes = p2d.numTypes;
                        _this.pointTypes = p2d.pointTypes.slice(0, p2d.pointTypes.length);
                        _this.numCoords = p2d.numCoords;
                        _this.floatCoords = p2d.cloneCoordsFloat(at);
                    }
                    else {
                        var pi = s['getPathIterator$java_awt_geom_AffineTransform'](at);
                        _this.setWindingRule(pi.getWindingRule());
                        _this.pointTypes = (function (s) { var a = []; while (s-- > 0)
                            a.push(0); return a; })(Path2D.INIT_SIZE);
                        _this.floatCoords = (function (s) { var a = []; while (s-- > 0)
                            a.push(0); return a; })(Path2D.INIT_SIZE * 2);
                        _this.append$java_awt_geom_PathIterator$boolean(pi, false);
                    }
                })();
            }
            else if (((typeof s === 'number') || s === null) && ((typeof at === 'number') || at === null)) {
                var __args = Array.prototype.slice.call(arguments);
                var rule = __args[0];
                var initialCapacity_1 = __args[1];
                _this = _super.call(this, rule, initialCapacity_1) || this;
                _this.floatCoords = null;
                _this.floatCoords = null;
                (function () {
                    _this.floatCoords = (function (s) { var a = []; while (s-- > 0)
                        a.push(0); return a; })(initialCapacity_1 * 2);
                })();
            }
            else if (((s != null && (s["__interfaces"] != null && s["__interfaces"].indexOf("java.awt.Shape") >= 0 || s.constructor != null && s.constructor["__interfaces"] != null && s.constructor["__interfaces"].indexOf("java.awt.Shape") >= 0)) || s === null) && at === undefined) {
                var __args = Array.prototype.slice.call(arguments);
                {
                    var __args_3 = Array.prototype.slice.call(arguments);
                    var at_1 = null;
                    _this = _super.call(this) || this;
                    _this.floatCoords = null;
                    _this.floatCoords = null;
                    (function () {
                        if (s != null && s instanceof Path2D) {
                            var p2d = s;
                            _this.setWindingRule(p2d.windingRule);
                            _this.numTypes = p2d.numTypes;
                            _this.pointTypes = p2d.pointTypes.slice(0, p2d.pointTypes.length);
                            _this.numCoords = p2d.numCoords;
                            _this.floatCoords = p2d.cloneCoordsFloat(at_1);
                        }
                        else {
                            var pi = s['getPathIterator$java_awt_geom_AffineTransform'](at_1);
                            _this.setWindingRule(pi.getWindingRule());
                            _this.pointTypes = (function (s) { var a = []; while (s-- > 0)
                                a.push(0); return a; })(Path2D.INIT_SIZE);
                            _this.floatCoords = (function (s) { var a = []; while (s-- > 0)
                                a.push(0); return a; })(Path2D.INIT_SIZE * 2);
                            _this.append$java_awt_geom_PathIterator$boolean(pi, false);
                        }
                    })();
                }
            }
            else if (((typeof s === 'number') || s === null) && at === undefined) {
                var __args = Array.prototype.slice.call(arguments);
                var rule = __args[0];
                {
                    var __args_4 = Array.prototype.slice.call(arguments);
                    var initialCapacity_2 = Path2D.INIT_SIZE;
                    _this = _super.call(this, rule, initialCapacity_2) || this;
                    _this.floatCoords = null;
                    _this.floatCoords = null;
                    (function () {
                        _this.floatCoords = (function (s) { var a = []; while (s-- > 0)
                            a.push(0); return a; })(initialCapacity_2 * 2);
                    })();
                }
            }
            else if (s === undefined && at === undefined) {
                var __args = Array.prototype.slice.call(arguments);
                {
                    var __args_5 = Array.prototype.slice.call(arguments);
                    var rule = Path2D.WIND_NON_ZERO_$LI$();
                    var initialCapacity_3 = Path2D.INIT_SIZE;
                    _this = _super.call(this, rule, initialCapacity_3) || this;
                    _this.floatCoords = null;
                    _this.floatCoords = null;
                    (function () {
                        _this.floatCoords = (function (s) { var a = []; while (s-- > 0)
                            a.push(0); return a; })(initialCapacity_3 * 2);
                    })();
                }
            }
            else
                throw new Error('invalid overload');
            return _this;
        }
        Float.prototype.cloneCoordsFloat = function (at) {
            var ret;
            if (at == null) {
                ret = this.floatCoords.slice(0, this.floatCoords.length);
            }
            else {
                ret = (function (s) { var a = []; while (s-- > 0)
                    a.push(0); return a; })(this.floatCoords.length);
                at.transform$float_A$int$float_A$int$int(this.floatCoords, 0, ret, 0, (this.numCoords / 2 | 0));
            }
            return ret;
        };
        Float.prototype.cloneCoordsDouble = function (at) {
            var ret = (function (s) { var a = []; while (s-- > 0)
                a.push(0); return a; })(this.floatCoords.length);
            if (at == null) {
                for (var i = 0; i < this.numCoords; i++) {
                    ret[i] = this.floatCoords[i];
                }
            }
            else {
                at.transform$float_A$int$double_A$int$int(this.floatCoords, 0, ret, 0, (this.numCoords / 2 | 0));
            }
            return ret;
        };
        Float.prototype.append$float$float = function (x, y) {
            this.floatCoords[this.numCoords++] = x;
            this.floatCoords[this.numCoords++] = y;
        };
        Float.prototype.append$double$double = function (x, y) {
            this.floatCoords[this.numCoords++] = x;
            this.floatCoords[this.numCoords++] = y;
        };
        Float.prototype.getPoint = function (coordindex) {
            return new Point2D.Float(this.floatCoords[coordindex], this.floatCoords[coordindex + 1]);
        };
        Float.prototype.needRoom = function (needMove, newCoords) {
            if (needMove && this.numTypes === 0) {
                throw Object.defineProperty(new Error("missing initial moveto in path definition"), '__class', { configurable: true, value: 'java.awt.geom.IllegalPathStateException' });
            }
            var size = this.pointTypes.length;
            if (this.numTypes >= size) {
                var grow = size;
                if (grow > Path2D.EXPAND_MAX) {
                    grow = Path2D.EXPAND_MAX;
                }
                this.pointTypes = this.pointTypes.slice(0, size + grow);
            }
            size = this.floatCoords.length;
            if (this.numCoords + newCoords > size) {
                var grow = size;
                if (grow > Path2D.EXPAND_MAX * 2) {
                    grow = Path2D.EXPAND_MAX * 2;
                }
                if (grow < newCoords) {
                    grow = newCoords;
                }
                this.floatCoords = this.floatCoords.slice(0, size + grow);
            }
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.6
         * @param {number} x
         * @param {number} y
         */
        Float.prototype.moveTo$double$double = function (x, y) {
            if (this.numTypes > 0 && this.pointTypes[this.numTypes - 1] === Path2D.SEG_MOVETO_$LI$()) {
                this.floatCoords[this.numCoords - 2] = x;
                this.floatCoords[this.numCoords - 1] = y;
            }
            else {
                this.needRoom(false, 2);
                this.pointTypes[this.numTypes++] = Path2D.SEG_MOVETO_$LI$();
                this.floatCoords[this.numCoords++] = x;
                this.floatCoords[this.numCoords++] = y;
            }
        };
        /**
         * Adds a point to the path by moving to the specified coordinates
         * specified in float precision.
         * <p>
         * This method provides a single precision variant of the double
         * precision {@code moveTo()} method on the base {@code Path2D} class.
         *
         * @param {number} x
         * the specified X coordinate
         * @param {number} y
         * the specified Y coordinate
         * @see Path2D#moveTo
         * @since 1.6
         */
        Float.prototype.moveTo$float$float = function (x, y) {
            if (this.numTypes > 0 && this.pointTypes[this.numTypes - 1] === Path2D.SEG_MOVETO_$LI$()) {
                this.floatCoords[this.numCoords - 2] = x;
                this.floatCoords[this.numCoords - 1] = y;
            }
            else {
                this.needRoom(false, 2);
                this.pointTypes[this.numTypes++] = Path2D.SEG_MOVETO_$LI$();
                this.floatCoords[this.numCoords++] = x;
                this.floatCoords[this.numCoords++] = y;
            }
        };
        /**
         * Adds a point to the path by moving to the specified coordinates
         * specified in float precision.
         * <p>
         * This method provides a single precision variant of the double
         * precision {@code moveTo()} method on the base {@code Path2D} class.
         *
         * @param {number} x
         * the specified X coordinate
         * @param {number} y
         * the specified Y coordinate
         * @see Path2D#moveTo
         * @since 1.6
         */
        Float.prototype.moveTo = function (x, y) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.moveTo$float$float(x, y);
            }
            else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.moveTo$double$double(x, y);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.6
         * @param {number} x
         * @param {number} y
         */
        Float.prototype.lineTo$double$double = function (x, y) {
            this.needRoom(true, 2);
            this.pointTypes[this.numTypes++] = Path2D.SEG_LINETO_$LI$();
            this.floatCoords[this.numCoords++] = x;
            this.floatCoords[this.numCoords++] = y;
        };
        /**
         * Adds a point to the path by drawing a straight line from the current
         * coordinates to the new specified coordinates specified in float
         * precision.
         * <p>
         * This method provides a single precision variant of the double
         * precision {@code lineTo()} method on the base {@code Path2D} class.
         *
         * @param {number} x
         * the specified X coordinate
         * @param {number} y
         * the specified Y coordinate
         * @see Path2D#lineTo
         * @since 1.6
         */
        Float.prototype.lineTo$float$float = function (x, y) {
            this.needRoom(true, 2);
            this.pointTypes[this.numTypes++] = Path2D.SEG_LINETO_$LI$();
            this.floatCoords[this.numCoords++] = x;
            this.floatCoords[this.numCoords++] = y;
        };
        /**
         * Adds a point to the path by drawing a straight line from the current
         * coordinates to the new specified coordinates specified in float
         * precision.
         * <p>
         * This method provides a single precision variant of the double
         * precision {@code lineTo()} method on the base {@code Path2D} class.
         *
         * @param {number} x
         * the specified X coordinate
         * @param {number} y
         * the specified Y coordinate
         * @see Path2D#lineTo
         * @since 1.6
         */
        Float.prototype.lineTo = function (x, y) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.lineTo$float$float(x, y);
            }
            else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.lineTo$double$double(x, y);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.6
         * @param {number} x1
         * @param {number} y1
         * @param {number} x2
         * @param {number} y2
         */
        Float.prototype.quadTo$double$double$double$double = function (x1, y1, x2, y2) {
            this.needRoom(true, 4);
            this.pointTypes[this.numTypes++] = Path2D.SEG_QUADTO_$LI$();
            this.floatCoords[this.numCoords++] = x1;
            this.floatCoords[this.numCoords++] = y1;
            this.floatCoords[this.numCoords++] = x2;
            this.floatCoords[this.numCoords++] = y2;
        };
        /**
         * Adds a curved segment, defined by two new points, to the path by
         * drawing a Quadratic curve that intersects both the current
         * coordinates and the specified coordinates {@code (x2,y2)}, using the
         * specified point {@code (x1,y1)} as a quadratic parametric control
         * point. All coordinates are specified in float precision.
         * <p>
         * This method provides a single precision variant of the double
         * precision {@code quadTo()} method on the base {@code Path2D} class.
         *
         * @param {number} x1
         * the X coordinate of the quadratic control point
         * @param {number} y1
         * the Y coordinate of the quadratic control point
         * @param {number} x2
         * the X coordinate of the final end point
         * @param {number} y2
         * the Y coordinate of the final end point
         * @see Path2D#quadTo
         * @since 1.6
         */
        Float.prototype.quadTo$float$float$float$float = function (x1, y1, x2, y2) {
            this.needRoom(true, 4);
            this.pointTypes[this.numTypes++] = Path2D.SEG_QUADTO_$LI$();
            this.floatCoords[this.numCoords++] = x1;
            this.floatCoords[this.numCoords++] = y1;
            this.floatCoords[this.numCoords++] = x2;
            this.floatCoords[this.numCoords++] = y2;
        };
        /**
         * Adds a curved segment, defined by two new points, to the path by
         * drawing a Quadratic curve that intersects both the current
         * coordinates and the specified coordinates {@code (x2,y2)}, using the
         * specified point {@code (x1,y1)} as a quadratic parametric control
         * point. All coordinates are specified in float precision.
         * <p>
         * This method provides a single precision variant of the double
         * precision {@code quadTo()} method on the base {@code Path2D} class.
         *
         * @param {number} x1
         * the X coordinate of the quadratic control point
         * @param {number} y1
         * the Y coordinate of the quadratic control point
         * @param {number} x2
         * the X coordinate of the final end point
         * @param {number} y2
         * the Y coordinate of the final end point
         * @see Path2D#quadTo
         * @since 1.6
         */
        Float.prototype.quadTo = function (x1, y1, x2, y2) {
            if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                return this.quadTo$float$float$float$float(x1, y1, x2, y2);
            }
            else if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                return this.quadTo$double$double$double$double(x1, y1, x2, y2);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.6
         * @param {number} x1
         * @param {number} y1
         * @param {number} x2
         * @param {number} y2
         * @param {number} x3
         * @param {number} y3
         */
        Float.prototype.curveTo$double$double$double$double$double$double = function (x1, y1, x2, y2, x3, y3) {
            this.needRoom(true, 6);
            this.pointTypes[this.numTypes++] = Path2D.SEG_CUBICTO_$LI$();
            this.floatCoords[this.numCoords++] = x1;
            this.floatCoords[this.numCoords++] = y1;
            this.floatCoords[this.numCoords++] = x2;
            this.floatCoords[this.numCoords++] = y2;
            this.floatCoords[this.numCoords++] = x3;
            this.floatCoords[this.numCoords++] = y3;
        };
        /**
         * Adds a curved segment, defined by three new points, to the path by
         * drawing a B&eacute;zier curve that intersects both the current
         * coordinates and the specified coordinates {@code (x3,y3)}, using the
         * specified points {@code (x1,y1)} and {@code (x2,y2)} as B&eacute;zier
         * control points. All coordinates are specified in float precision.
         * <p>
         * This method provides a single precision variant of the double
         * precision {@code curveTo()} method on the base {@code Path2D} class.
         *
         * @param {number} x1
         * the X coordinate of the first B&eacute;zier control point
         * @param {number} y1
         * the Y coordinate of the first B&eacute;zier control point
         * @param {number} x2
         * the X coordinate of the second B&eacute;zier control point
         * @param {number} y2
         * the Y coordinate of the second B&eacute;zier control point
         * @param {number} x3
         * the X coordinate of the final end point
         * @param {number} y3
         * the Y coordinate of the final end point
         * @see Path2D#curveTo
         * @since 1.6
         */
        Float.prototype.curveTo$float$float$float$float$float$float = function (x1, y1, x2, y2, x3, y3) {
            this.needRoom(true, 6);
            this.pointTypes[this.numTypes++] = Path2D.SEG_CUBICTO_$LI$();
            this.floatCoords[this.numCoords++] = x1;
            this.floatCoords[this.numCoords++] = y1;
            this.floatCoords[this.numCoords++] = x2;
            this.floatCoords[this.numCoords++] = y2;
            this.floatCoords[this.numCoords++] = x3;
            this.floatCoords[this.numCoords++] = y3;
        };
        /**
         * Adds a curved segment, defined by three new points, to the path by
         * drawing a B&eacute;zier curve that intersects both the current
         * coordinates and the specified coordinates {@code (x3,y3)}, using the
         * specified points {@code (x1,y1)} and {@code (x2,y2)} as B&eacute;zier
         * control points. All coordinates are specified in float precision.
         * <p>
         * This method provides a single precision variant of the double
         * precision {@code curveTo()} method on the base {@code Path2D} class.
         *
         * @param {number} x1
         * the X coordinate of the first B&eacute;zier control point
         * @param {number} y1
         * the Y coordinate of the first B&eacute;zier control point
         * @param {number} x2
         * the X coordinate of the second B&eacute;zier control point
         * @param {number} y2
         * the Y coordinate of the second B&eacute;zier control point
         * @param {number} x3
         * the X coordinate of the final end point
         * @param {number} y3
         * the Y coordinate of the final end point
         * @see Path2D#curveTo
         * @since 1.6
         */
        Float.prototype.curveTo = function (x1, y1, x2, y2, x3, y3) {
            if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null) && ((typeof x3 === 'number') || x3 === null) && ((typeof y3 === 'number') || y3 === null)) {
                return this.curveTo$float$float$float$float$float$float(x1, y1, x2, y2, x3, y3);
            }
            else if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null) && ((typeof x3 === 'number') || x3 === null) && ((typeof y3 === 'number') || y3 === null)) {
                return this.curveTo$double$double$double$double$double$double(x1, y1, x2, y2, x3, y3);
            }
            else
                throw new Error('invalid overload');
        };
        Float.prototype.pointCrossings = function (px, py) {
            var movx;
            var movy;
            var curx;
            var cury;
            var endx;
            var endy;
            var coords = this.floatCoords;
            curx = movx = coords[0];
            cury = movy = coords[1];
            var crossings = 0;
            var ci = 2;
            for (var i = 1; i < this.numTypes; i++) {
                switch ((this.pointTypes[i])) {
                    case PathIterator.SEG_MOVETO:
                        if (cury !== movy) {
                            crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                        }
                        movx = curx = coords[ci++];
                        movy = cury = coords[ci++];
                        break;
                    case PathIterator.SEG_LINETO:
                        crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, endx = coords[ci++], endy = coords[ci++]);
                        curx = endx;
                        cury = endy;
                        break;
                    case PathIterator.SEG_QUADTO:
                        crossings += sun.awt.geom.Curve.pointCrossingsForQuad(px, py, curx, cury, coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                        curx = endx;
                        cury = endy;
                        break;
                    case PathIterator.SEG_CUBICTO:
                        crossings += sun.awt.geom.Curve.pointCrossingsForCubic(px, py, curx, cury, coords[ci++], coords[ci++], coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                        curx = endx;
                        cury = endy;
                        break;
                    case PathIterator.SEG_CLOSE:
                        if (cury !== movy) {
                            crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                        }
                        curx = movx;
                        cury = movy;
                        break;
                }
            }
            if (cury !== movy) {
                crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
            }
            return crossings;
        };
        Float.prototype.rectCrossings = function (rxmin, rymin, rxmax, rymax) {
            var coords = this.floatCoords;
            var curx;
            var cury;
            var movx;
            var movy;
            var endx;
            var endy;
            curx = movx = coords[0];
            cury = movy = coords[1];
            var crossings = 0;
            var ci = 2;
            for (var i = 1; crossings !== sun.awt.geom.Curve.RECT_INTERSECTS && i < this.numTypes; i++) {
                switch ((this.pointTypes[i])) {
                    case PathIterator.SEG_MOVETO:
                        if (curx !== movx || cury !== movy) {
                            crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                        }
                        movx = curx = coords[ci++];
                        movy = cury = coords[ci++];
                        break;
                    case PathIterator.SEG_LINETO:
                        crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, endx = coords[ci++], endy = coords[ci++]);
                        curx = endx;
                        cury = endy;
                        break;
                    case PathIterator.SEG_QUADTO:
                        crossings = sun.awt.geom.Curve.rectCrossingsForQuad(crossings, rxmin, rymin, rxmax, rymax, curx, cury, coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                        curx = endx;
                        cury = endy;
                        break;
                    case PathIterator.SEG_CUBICTO:
                        crossings = sun.awt.geom.Curve.rectCrossingsForCubic(crossings, rxmin, rymin, rxmax, rymax, curx, cury, coords[ci++], coords[ci++], coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                        curx = endx;
                        cury = endy;
                        break;
                    case PathIterator.SEG_CLOSE:
                        if (curx !== movx || cury !== movy) {
                            crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                        }
                        curx = movx;
                        cury = movy;
                        break;
                }
            }
            if (crossings !== sun.awt.geom.Curve.RECT_INTERSECTS && (curx !== movx || cury !== movy)) {
                crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
            }
            return crossings;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.6
         * @param {PathIterator} pi
         * @param {boolean} connect
         */
        Float.prototype.append$java_awt_geom_PathIterator$boolean = function (pi, connect) {
            var coords = [0, 0, 0, 0, 0, 0];
            while ((!pi.isDone())) {
                switch ((pi['currentSegment$float_A'](coords))) {
                    case Path2D.SEG_MOVETO_$LI$():
                        if (!connect || this.numTypes < 1 || this.numCoords < 1) {
                            this.moveTo$double$double(coords[0], coords[1]);
                            break;
                        }
                        if (this.pointTypes[this.numTypes - 1] !== Path2D.SEG_CLOSE_$LI$() && this.floatCoords[this.numCoords - 2] === coords[0] && this.floatCoords[this.numCoords - 1] === coords[1]) {
                            break;
                        }
                        this.lineTo$double$double(coords[0], coords[1]);
                        break;
                    case Path2D.SEG_LINETO_$LI$():
                        this.lineTo$double$double(coords[0], coords[1]);
                        break;
                    case Path2D.SEG_QUADTO_$LI$():
                        this.quadTo$double$double$double$double(coords[0], coords[1], coords[2], coords[3]);
                        break;
                    case Path2D.SEG_CUBICTO_$LI$():
                        this.curveTo$double$double$double$double$double$double(coords[0], coords[1], coords[2], coords[3], coords[4], coords[5]);
                        break;
                    case Path2D.SEG_CLOSE_$LI$():
                        this.closePath();
                        break;
                }
                pi.next();
                connect = false;
            }
            ;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.6
         * @param {PathIterator} pi
         * @param {boolean} connect
         */
        Float.prototype.append = function (pi, connect) {
            if (((pi != null && (pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || pi.constructor != null && pi.constructor["__interfaces"] != null && pi.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || pi === null) && ((typeof connect === 'boolean') || connect === null)) {
                return this.append$java_awt_geom_PathIterator$boolean(pi, connect);
            }
            else if (((pi != null && (pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.Shape") >= 0 || pi.constructor != null && pi.constructor["__interfaces"] != null && pi.constructor["__interfaces"].indexOf("java.awt.Shape") >= 0)) || pi === null) && ((typeof connect === 'boolean') || connect === null)) {
                _super.prototype.append.call(this, pi, connect);
            }
            else if (((typeof pi === 'number') || pi === null) && ((typeof connect === 'number') || connect === null)) {
                return this.append$float$float(pi, connect);
            }
            else if (((typeof pi === 'number') || pi === null) && ((typeof connect === 'number') || connect === null)) {
                return this.append$double$double(pi, connect);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.6
         * @param {AffineTransform} at
         */
        Float.prototype.transform = function (at) {
            at.transform$float_A$int$float_A$int$int(this.floatCoords, 0, this.floatCoords, 0, (this.numCoords / 2 | 0));
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.6
         * @return {Rectangle2D}
         */
        Float.prototype.getBounds2D = function () {
            var x1;
            var y1;
            var x2;
            var y2;
            var i = this.numCoords;
            if (i > 0) {
                y1 = y2 = this.floatCoords[--i];
                x1 = x2 = this.floatCoords[--i];
                while ((i > 0)) {
                    var y = this.floatCoords[--i];
                    var x = this.floatCoords[--i];
                    if (x < x1)
                        x1 = x;
                    if (y < y1)
                        y1 = y;
                    if (x > x2)
                        x2 = x;
                    if (y > y2)
                        y2 = y;
                }
                ;
            }
            else {
                x1 = y1 = x2 = y2 = 0.0;
            }
            return new Rectangle2D.Float(x1, y1, x2 - x1, y2 - y1);
        };
        /**
         * {@inheritDoc}
         * <p>
         * The iterator for this class is not multi-threaded safe, which means that
         * this {@code Path2D} class does not guarantee that modifications to the
         * geometry of this {@code Path2D} object do not affect any iterations of
         * that geometry that are already in process.
         *
         * @since 1.6
         * @param {AffineTransform} at
         * @param {number} flatness
         * @return {PathIterator}
         */
        Float.prototype.getPathIterator = function (at, flatness) {
            if (((at != null && at instanceof AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
                _super.prototype.getPathIterator.call(this, at, flatness);
            }
            else if (((at != null && at instanceof AffineTransform) || at === null) && flatness === undefined) {
                return this.getPathIterator$java_awt_geom_AffineTransform(at);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * {@inheritDoc}
         * <p>
         * The iterator for this class is not multi-threaded safe, which means
         * that the {@code Path2D} class does not guarantee that modifications
         * to the geometry of this {@code Path2D} object do not affect any
         * iterations of that geometry that are already in process.
         *
         * @since 1.6
         * @param {AffineTransform} at
         * @return {PathIterator}
         */
        Float.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
            if (at == null) {
                return new Float.CopyIterator(this);
            }
            else {
                return new Float.TxIterator(this, at);
            }
        };
        /**
         * Creates a new object of the same class as this object.
         *
         * @return {*} a clone of this instance.
         * @exception OutOfMemoryError
         * if there is not enough memory.
         * @see java.lang.Cloneable
         * @since 1.6
         */
        Float.prototype.clone = function () {
            if (this != null && this instanceof GeneralPath) {
                return new GeneralPath(this);
            }
            else {
                return new Path2D.Float(this);
            }
        };
        return Float;
    }(Path2D));
    Float.serialVersionUID = 6990832515060788886;
    Path2D.Float = Float;
    Float["__class"] = "Path2D.Float";
    Float["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
    (function (Float) {
        var CopyIterator = (function (_super) {
            __extends(CopyIterator, _super);
            function CopyIterator(p2df) {
                var _this = _super.call(this, p2df) || this;
                _this.floatCoords = null;
                _this.floatCoords = p2df.floatCoords;
                return _this;
            }
            CopyIterator.prototype.currentSegment$float_A = function (coords) {
                var type = this.path.pointTypes[this.typeIdx];
                var numCoords = Path2D.Iterator.curvecoords_$LI$()[type];
                if (numCoords > 0) {
                    Helper.arraycopy(this.floatCoords, this.pointIdx, coords, 0, numCoords);
                }
                return type;
            };
            CopyIterator.prototype.currentSegment = function (coords) {
                if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                    return this.currentSegment$float_A(coords);
                }
                else if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                    return this.currentSegment$double_A(coords);
                }
                else
                    throw new Error('invalid overload');
            };
            CopyIterator.prototype.currentSegment$double_A = function (coords) {
                var type = this.path.pointTypes[this.typeIdx];
                var numCoords = Path2D.Iterator.curvecoords_$LI$()[type];
                if (numCoords > 0) {
                    for (var i = 0; i < numCoords; i++) {
                        coords[i] = this.floatCoords[this.pointIdx + i];
                    }
                }
                return type;
            };
            return CopyIterator;
        }(Path2D.Iterator));
        Float.CopyIterator = CopyIterator;
        CopyIterator["__class"] = "Path2D.Float.CopyIterator";
        CopyIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
        var TxIterator = (function (_super) {
            __extends(TxIterator, _super);
            function TxIterator(p2df, at) {
                var _this = _super.call(this, p2df) || this;
                _this.floatCoords = null;
                _this.affine = null;
                _this.floatCoords = p2df.floatCoords;
                _this.affine = at;
                return _this;
            }
            TxIterator.prototype.currentSegment$float_A = function (coords) {
                var type = this.path.pointTypes[this.typeIdx];
                var numCoords = Path2D.Iterator.curvecoords_$LI$()[type];
                if (numCoords > 0) {
                    this.affine.transform$float_A$int$float_A$int$int(this.floatCoords, this.pointIdx, coords, 0, (numCoords / 2 | 0));
                }
                return type;
            };
            TxIterator.prototype.currentSegment = function (coords) {
                if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                    return this.currentSegment$float_A(coords);
                }
                else if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                    return this.currentSegment$double_A(coords);
                }
                else
                    throw new Error('invalid overload');
            };
            TxIterator.prototype.currentSegment$double_A = function (coords) {
                var type = this.path.pointTypes[this.typeIdx];
                var numCoords = Path2D.Iterator.curvecoords_$LI$()[type];
                if (numCoords > 0) {
                    this.affine.transform$float_A$int$double_A$int$int(this.floatCoords, this.pointIdx, coords, 0, (numCoords / 2 | 0));
                }
                return type;
            };
            return TxIterator;
        }(Path2D.Iterator));
        Float.TxIterator = TxIterator;
        TxIterator["__class"] = "Path2D.Float.TxIterator";
        TxIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
    })(Float = Path2D.Float || (Path2D.Float = {}));
    /**
     * Constructs a new empty double precision {@code Path2D} object with
     * the specified winding rule and the specified initial capacity to
     * store path segments. This number is an initial guess as to how many
     * path segments are in the path, but the storage is expanded as needed
     * to store whatever path segments are added to this path.
     *
     * @param {number} rule
     * the winding rule
     * @param {number} initialCapacity
     * the estimate for the number of path segments in the path
     * @see #WIND_EVEN_ODD
     * @see #WIND_NON_ZERO
     * @since 1.6
     * @class
     */
    var Double = (function (_super) {
        __extends(Double, _super);
        function Double(s, at) {
            var _this = this;
            if (((s != null && (s["__interfaces"] != null && s["__interfaces"].indexOf("java.awt.Shape") >= 0 || s.constructor != null && s.constructor["__interfaces"] != null && s.constructor["__interfaces"].indexOf("java.awt.Shape") >= 0)) || s === null) && ((at != null && at instanceof AffineTransform) || at === null)) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this) || this;
                _this.doubleCoords = null;
                _this.doubleCoords = null;
                (function () {
                    if (s != null && s instanceof Path2D) {
                        var p2d = s;
                        _this.setWindingRule(p2d.windingRule);
                        _this.numTypes = p2d.numTypes;
                        _this.pointTypes = p2d.pointTypes.slice(0, p2d.pointTypes.length);
                        _this.numCoords = p2d.numCoords;
                        _this.doubleCoords = p2d.cloneCoordsDouble(at);
                    }
                    else {
                        var pi = s['getPathIterator$java_awt_geom_AffineTransform'](at);
                        _this.setWindingRule(pi.getWindingRule());
                        _this.pointTypes = (function (s) { var a = []; while (s-- > 0)
                            a.push(0); return a; })(Path2D.INIT_SIZE);
                        _this.doubleCoords = (function (s) { var a = []; while (s-- > 0)
                            a.push(0); return a; })(Path2D.INIT_SIZE * 2);
                        _this.append$java_awt_geom_PathIterator$boolean(pi, false);
                    }
                })();
            }
            else if (((typeof s === 'number') || s === null) && ((typeof at === 'number') || at === null)) {
                var __args = Array.prototype.slice.call(arguments);
                var rule = __args[0];
                var initialCapacity_4 = __args[1];
                _this = _super.call(this, rule, initialCapacity_4) || this;
                _this.doubleCoords = null;
                _this.doubleCoords = null;
                (function () {
                    _this.doubleCoords = (function (s) { var a = []; while (s-- > 0)
                        a.push(0); return a; })(initialCapacity_4 * 2);
                })();
            }
            else if (((s != null && (s["__interfaces"] != null && s["__interfaces"].indexOf("java.awt.Shape") >= 0 || s.constructor != null && s.constructor["__interfaces"] != null && s.constructor["__interfaces"].indexOf("java.awt.Shape") >= 0)) || s === null) && at === undefined) {
                var __args = Array.prototype.slice.call(arguments);
                {
                    var __args_6 = Array.prototype.slice.call(arguments);
                    var at_2 = null;
                    _this = _super.call(this) || this;
                    _this.doubleCoords = null;
                    _this.doubleCoords = null;
                    (function () {
                        if (s != null && s instanceof Path2D) {
                            var p2d = s;
                            _this.setWindingRule(p2d.windingRule);
                            _this.numTypes = p2d.numTypes;
                            _this.pointTypes = p2d.pointTypes.slice(0, p2d.pointTypes.length);
                            _this.numCoords = p2d.numCoords;
                            _this.doubleCoords = p2d.cloneCoordsDouble(at_2);
                        }
                        else {
                            var pi = s['getPathIterator$java_awt_geom_AffineTransform'](at_2);
                            _this.setWindingRule(pi.getWindingRule());
                            _this.pointTypes = (function (s) { var a = []; while (s-- > 0)
                                a.push(0); return a; })(Path2D.INIT_SIZE);
                            _this.doubleCoords = (function (s) { var a = []; while (s-- > 0)
                                a.push(0); return a; })(Path2D.INIT_SIZE * 2);
                            _this.append$java_awt_geom_PathIterator$boolean(pi, false);
                        }
                    })();
                }
            }
            else if (((typeof s === 'number') || s === null) && at === undefined) {
                var __args = Array.prototype.slice.call(arguments);
                var rule = __args[0];
                {
                    var __args_7 = Array.prototype.slice.call(arguments);
                    var initialCapacity_5 = Path2D.INIT_SIZE;
                    _this = _super.call(this, rule, initialCapacity_5) || this;
                    _this.doubleCoords = null;
                    _this.doubleCoords = null;
                    (function () {
                        _this.doubleCoords = (function (s) { var a = []; while (s-- > 0)
                            a.push(0); return a; })(initialCapacity_5 * 2);
                    })();
                }
            }
            else if (s === undefined && at === undefined) {
                var __args = Array.prototype.slice.call(arguments);
                {
                    var __args_8 = Array.prototype.slice.call(arguments);
                    var rule = Path2D.WIND_NON_ZERO_$LI$();
                    var initialCapacity_6 = Path2D.INIT_SIZE;
                    _this = _super.call(this, rule, initialCapacity_6) || this;
                    _this.doubleCoords = null;
                    _this.doubleCoords = null;
                    (function () {
                        _this.doubleCoords = (function (s) { var a = []; while (s-- > 0)
                            a.push(0); return a; })(initialCapacity_6 * 2);
                    })();
                }
            }
            else
                throw new Error('invalid overload');
            return _this;
        }
        Double.prototype.cloneCoordsFloat = function (at) {
            var ret = (function (s) { var a = []; while (s-- > 0)
                a.push(0); return a; })(this.doubleCoords.length);
            if (at == null) {
                for (var i = 0; i < this.numCoords; i++) {
                    ret[i] = this.doubleCoords[i];
                }
            }
            else {
                at.transform$double_A$int$float_A$int$int(this.doubleCoords, 0, ret, 0, (this.numCoords / 2 | 0));
            }
            return ret;
        };
        Double.prototype.cloneCoordsDouble = function (at) {
            var ret;
            if (at == null) {
                ret = this.doubleCoords.slice(0, this.doubleCoords.length);
            }
            else {
                ret = (function (s) { var a = []; while (s-- > 0)
                    a.push(0); return a; })(this.doubleCoords.length);
                at.transform$double_A$int$double_A$int$int(this.doubleCoords, 0, ret, 0, (this.numCoords / 2 | 0));
            }
            return ret;
        };
        Double.prototype.append$float$float = function (x, y) {
            this.doubleCoords[this.numCoords++] = x;
            this.doubleCoords[this.numCoords++] = y;
        };
        Double.prototype.append$double$double = function (x, y) {
            this.doubleCoords[this.numCoords++] = x;
            this.doubleCoords[this.numCoords++] = y;
        };
        Double.prototype.getPoint = function (coordindex) {
            return new Point2D.Double(this.doubleCoords[coordindex], this.doubleCoords[coordindex + 1]);
        };
        Double.prototype.needRoom = function (needMove, newCoords) {
            if (needMove && this.numTypes === 0) {
                throw Object.defineProperty(new Error("missing initial moveto in path definition"), '__class', { configurable: true, value: 'java.awt.geom.IllegalPathStateException' });
            }
            var size = this.pointTypes.length;
            if (this.numTypes >= size) {
                var grow = size;
                if (grow > Path2D.EXPAND_MAX) {
                    grow = Path2D.EXPAND_MAX;
                }
                this.pointTypes = this.pointTypes.slice(0, size + grow);
            }
            size = this.doubleCoords.length;
            if (this.numCoords + newCoords > size) {
                var grow = size;
                if (grow > Path2D.EXPAND_MAX * 2) {
                    grow = Path2D.EXPAND_MAX * 2;
                }
                if (grow < newCoords) {
                    grow = newCoords;
                }
                this.doubleCoords = this.doubleCoords.slice(0, size + grow);
            }
        };
        /**
         * Adds a point to the path by moving to the specified coordinates
         * specified in float precision.
         * <p>
         * This method provides a single precision variant of the double
         * precision {@code moveTo()} method on the base {@code Path2D} class.
         *
         * @param {number} x
         * the specified X coordinate
         * @param {number} y
         * the specified Y coordinate
         * @see Path2D#moveTo
         * @since 1.6
         */
        Double.prototype.moveTo = function (x, y) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.moveTo$double$double(x, y);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.6
         * @param {number} x
         * @param {number} y
         */
        Double.prototype.moveTo$double$double = function (x, y) {
            if (this.numTypes > 0 && this.pointTypes[this.numTypes - 1] === Path2D.SEG_MOVETO_$LI$()) {
                this.doubleCoords[this.numCoords - 2] = x;
                this.doubleCoords[this.numCoords - 1] = y;
            }
            else {
                this.needRoom(false, 2);
                this.pointTypes[this.numTypes++] = Path2D.SEG_MOVETO_$LI$();
                this.doubleCoords[this.numCoords++] = x;
                this.doubleCoords[this.numCoords++] = y;
            }
        };
        /**
         * Adds a point to the path by drawing a straight line from the current
         * coordinates to the new specified coordinates specified in float
         * precision.
         * <p>
         * This method provides a single precision variant of the double
         * precision {@code lineTo()} method on the base {@code Path2D} class.
         *
         * @param {number} x
         * the specified X coordinate
         * @param {number} y
         * the specified Y coordinate
         * @see Path2D#lineTo
         * @since 1.6
         */
        Double.prototype.lineTo = function (x, y) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.lineTo$double$double(x, y);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.6
         * @param {number} x
         * @param {number} y
         */
        Double.prototype.lineTo$double$double = function (x, y) {
            this.needRoom(true, 2);
            this.pointTypes[this.numTypes++] = Path2D.SEG_LINETO_$LI$();
            this.doubleCoords[this.numCoords++] = x;
            this.doubleCoords[this.numCoords++] = y;
        };
        /**
         * Adds a curved segment, defined by two new points, to the path by
         * drawing a Quadratic curve that intersects both the current
         * coordinates and the specified coordinates {@code (x2,y2)}, using the
         * specified point {@code (x1,y1)} as a quadratic parametric control
         * point. All coordinates are specified in float precision.
         * <p>
         * This method provides a single precision variant of the double
         * precision {@code quadTo()} method on the base {@code Path2D} class.
         *
         * @param {number} x1
         * the X coordinate of the quadratic control point
         * @param {number} y1
         * the Y coordinate of the quadratic control point
         * @param {number} x2
         * the X coordinate of the final end point
         * @param {number} y2
         * the Y coordinate of the final end point
         * @see Path2D#quadTo
         * @since 1.6
         */
        Double.prototype.quadTo = function (x1, y1, x2, y2) {
            if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                return this.quadTo$double$double$double$double(x1, y1, x2, y2);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.6
         * @param {number} x1
         * @param {number} y1
         * @param {number} x2
         * @param {number} y2
         */
        Double.prototype.quadTo$double$double$double$double = function (x1, y1, x2, y2) {
            this.needRoom(true, 4);
            this.pointTypes[this.numTypes++] = Path2D.SEG_QUADTO_$LI$();
            this.doubleCoords[this.numCoords++] = x1;
            this.doubleCoords[this.numCoords++] = y1;
            this.doubleCoords[this.numCoords++] = x2;
            this.doubleCoords[this.numCoords++] = y2;
        };
        /**
         * Adds a curved segment, defined by three new points, to the path by
         * drawing a B&eacute;zier curve that intersects both the current
         * coordinates and the specified coordinates {@code (x3,y3)}, using the
         * specified points {@code (x1,y1)} and {@code (x2,y2)} as B&eacute;zier
         * control points. All coordinates are specified in float precision.
         * <p>
         * This method provides a single precision variant of the double
         * precision {@code curveTo()} method on the base {@code Path2D} class.
         *
         * @param {number} x1
         * the X coordinate of the first B&eacute;zier control point
         * @param {number} y1
         * the Y coordinate of the first B&eacute;zier control point
         * @param {number} x2
         * the X coordinate of the second B&eacute;zier control point
         * @param {number} y2
         * the Y coordinate of the second B&eacute;zier control point
         * @param {number} x3
         * the X coordinate of the final end point
         * @param {number} y3
         * the Y coordinate of the final end point
         * @see Path2D#curveTo
         * @since 1.6
         */
        Double.prototype.curveTo = function (x1, y1, x2, y2, x3, y3) {
            if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null) && ((typeof x3 === 'number') || x3 === null) && ((typeof y3 === 'number') || y3 === null)) {
                return this.curveTo$double$double$double$double$double$double(x1, y1, x2, y2, x3, y3);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.6
         * @param {number} x1
         * @param {number} y1
         * @param {number} x2
         * @param {number} y2
         * @param {number} x3
         * @param {number} y3
         */
        Double.prototype.curveTo$double$double$double$double$double$double = function (x1, y1, x2, y2, x3, y3) {
            this.needRoom(true, 6);
            this.pointTypes[this.numTypes++] = Path2D.SEG_CUBICTO_$LI$();
            this.doubleCoords[this.numCoords++] = x1;
            this.doubleCoords[this.numCoords++] = y1;
            this.doubleCoords[this.numCoords++] = x2;
            this.doubleCoords[this.numCoords++] = y2;
            this.doubleCoords[this.numCoords++] = x3;
            this.doubleCoords[this.numCoords++] = y3;
        };
        Double.prototype.pointCrossings = function (px, py) {
            var movx;
            var movy;
            var curx;
            var cury;
            var endx;
            var endy;
            var coords = this.doubleCoords;
            curx = movx = coords[0];
            cury = movy = coords[1];
            var crossings = 0;
            var ci = 2;
            for (var i = 1; i < this.numTypes; i++) {
                switch ((this.pointTypes[i])) {
                    case PathIterator.SEG_MOVETO:
                        if (cury !== movy) {
                            crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                        }
                        movx = curx = coords[ci++];
                        movy = cury = coords[ci++];
                        break;
                    case PathIterator.SEG_LINETO:
                        crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, endx = coords[ci++], endy = coords[ci++]);
                        curx = endx;
                        cury = endy;
                        break;
                    case PathIterator.SEG_QUADTO:
                        crossings += sun.awt.geom.Curve.pointCrossingsForQuad(px, py, curx, cury, coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                        curx = endx;
                        cury = endy;
                        break;
                    case PathIterator.SEG_CUBICTO:
                        crossings += sun.awt.geom.Curve.pointCrossingsForCubic(px, py, curx, cury, coords[ci++], coords[ci++], coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                        curx = endx;
                        cury = endy;
                        break;
                    case PathIterator.SEG_CLOSE:
                        if (cury !== movy) {
                            crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                        }
                        curx = movx;
                        cury = movy;
                        break;
                }
            }
            if (cury !== movy) {
                crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
            }
            return crossings;
        };
        Double.prototype.rectCrossings = function (rxmin, rymin, rxmax, rymax) {
            var coords = this.doubleCoords;
            var curx;
            var cury;
            var movx;
            var movy;
            var endx;
            var endy;
            curx = movx = coords[0];
            cury = movy = coords[1];
            var crossings = 0;
            var ci = 2;
            for (var i = 1; crossings !== sun.awt.geom.Curve.RECT_INTERSECTS && i < this.numTypes; i++) {
                switch ((this.pointTypes[i])) {
                    case PathIterator.SEG_MOVETO:
                        if (curx !== movx || cury !== movy) {
                            crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                        }
                        movx = curx = coords[ci++];
                        movy = cury = coords[ci++];
                        break;
                    case PathIterator.SEG_LINETO:
                        endx = coords[ci++];
                        endy = coords[ci++];
                        crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, endx, endy);
                        curx = endx;
                        cury = endy;
                        break;
                    case PathIterator.SEG_QUADTO:
                        crossings = sun.awt.geom.Curve.rectCrossingsForQuad(crossings, rxmin, rymin, rxmax, rymax, curx, cury, coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                        curx = endx;
                        cury = endy;
                        break;
                    case PathIterator.SEG_CUBICTO:
                        crossings = sun.awt.geom.Curve.rectCrossingsForCubic(crossings, rxmin, rymin, rxmax, rymax, curx, cury, coords[ci++], coords[ci++], coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                        curx = endx;
                        cury = endy;
                        break;
                    case PathIterator.SEG_CLOSE:
                        if (curx !== movx || cury !== movy) {
                            crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                        }
                        curx = movx;
                        cury = movy;
                        break;
                }
            }
            if (crossings !== sun.awt.geom.Curve.RECT_INTERSECTS && (curx !== movx || cury !== movy)) {
                crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
            }
            return crossings;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.6
         * @param {PathIterator} pi
         * @param {boolean} connect
         */
        Double.prototype.append$java_awt_geom_PathIterator$boolean = function (pi, connect) {
            var coords = [0, 0, 0, 0, 0, 0];
            while ((!pi.isDone())) {
                switch ((pi['currentSegment$double_A'](coords))) {
                    case Path2D.SEG_MOVETO_$LI$():
                        if (!connect || this.numTypes < 1 || this.numCoords < 1) {
                            this.moveTo$double$double(coords[0], coords[1]);
                            break;
                        }
                        if (this.pointTypes[this.numTypes - 1] !== Path2D.SEG_CLOSE_$LI$() && this.doubleCoords[this.numCoords - 2] === coords[0] && this.doubleCoords[this.numCoords - 1] === coords[1]) {
                            break;
                        }
                        this.lineTo$double$double(coords[0], coords[1]);
                        break;
                    case Path2D.SEG_LINETO_$LI$():
                        this.lineTo$double$double(coords[0], coords[1]);
                        break;
                    case Path2D.SEG_QUADTO_$LI$():
                        this.quadTo$double$double$double$double(coords[0], coords[1], coords[2], coords[3]);
                        break;
                    case Path2D.SEG_CUBICTO_$LI$():
                        this.curveTo$double$double$double$double$double$double(coords[0], coords[1], coords[2], coords[3], coords[4], coords[5]);
                        break;
                    case Path2D.SEG_CLOSE_$LI$():
                        this.closePath();
                        break;
                }
                pi.next();
                connect = false;
            }
            ;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.6
         * @param {PathIterator} pi
         * @param {boolean} connect
         */
        Double.prototype.append = function (pi, connect) {
            if (((pi != null && (pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || pi.constructor != null && pi.constructor["__interfaces"] != null && pi.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || pi === null) && ((typeof connect === 'boolean') || connect === null)) {
                return this.append$java_awt_geom_PathIterator$boolean(pi, connect);
            }
            else if (((pi != null && (pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.Shape") >= 0 || pi.constructor != null && pi.constructor["__interfaces"] != null && pi.constructor["__interfaces"].indexOf("java.awt.Shape") >= 0)) || pi === null) && ((typeof connect === 'boolean') || connect === null)) {
                _super.prototype.append.call(this, pi, connect);
            }
            else if (((typeof pi === 'number') || pi === null) && ((typeof connect === 'number') || connect === null)) {
                return this.append$float$float(pi, connect);
            }
            else if (((typeof pi === 'number') || pi === null) && ((typeof connect === 'number') || connect === null)) {
                return this.append$double$double(pi, connect);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.6
         * @param {AffineTransform} at
         */
        Double.prototype.transform = function (at) {
            at.transform$double_A$int$double_A$int$int(this.doubleCoords, 0, this.doubleCoords, 0, (this.numCoords / 2 | 0));
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.6
         * @return {Rectangle2D}
         */
        Double.prototype.getBounds2D = function () {
            var x1;
            var y1;
            var x2;
            var y2;
            var i = this.numCoords;
            if (i > 0) {
                y1 = y2 = this.doubleCoords[--i];
                x1 = x2 = this.doubleCoords[--i];
                while ((i > 0)) {
                    var y = this.doubleCoords[--i];
                    var x = this.doubleCoords[--i];
                    if (x < x1)
                        x1 = x;
                    if (y < y1)
                        y1 = y;
                    if (x > x2)
                        x2 = x;
                    if (y > y2)
                        y2 = y;
                }
                ;
            }
            else {
                x1 = y1 = x2 = y2 = 0.0;
            }
            return new Rectangle2D.Double(x1, y1, x2 - x1, y2 - y1);
        };
        /**
         * {@inheritDoc}
         * <p>
         * The iterator for this class is not multi-threaded safe, which means that
         * this {@code Path2D} class does not guarantee that modifications to the
         * geometry of this {@code Path2D} object do not affect any iterations of
         * that geometry that are already in process.
         *
         * @since 1.6
         * @param {AffineTransform} at
         * @param {number} flatness
         * @return {PathIterator}
         */
        Double.prototype.getPathIterator = function (at, flatness) {
            if (((at != null && at instanceof AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
                _super.prototype.getPathIterator.call(this, at, flatness);
            }
            else if (((at != null && at instanceof AffineTransform) || at === null) && flatness === undefined) {
                return this.getPathIterator$java_awt_geom_AffineTransform(at);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * {@inheritDoc}
         * <p>
         * The iterator for this class is not multi-threaded safe, which means
         * that the {@code Path2D} class does not guarantee that modifications
         * to the geometry of this {@code Path2D} object do not affect any
         * iterations of that geometry that are already in process.
         *
         * @param {AffineTransform} at
         * an {@code AffineTransform}
         * @return {PathIterator} a new {@code PathIterator} that iterates along the boundary
         * of this {@code Shape} and provides access to the geometry of
         * this {@code Shape}'s outline
         * @since 1.6
         */
        Double.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
            if (at == null) {
                return new Double.CopyIterator(this);
            }
            else {
                return new Double.TxIterator(this, at);
            }
        };
        /**
         * Creates a new object of the same class as this object.
         *
         * @return {*} a clone of this instance.
         * @exception OutOfMemoryError
         * if there is not enough memory.
         * @see java.lang.Cloneable
         * @since 1.6
         */
        Double.prototype.clone = function () {
            return new Path2D.Double(this);
        };
        return Double;
    }(Path2D));
    Double.serialVersionUID = 1826762518450014216;
    Path2D.Double = Double;
    Double["__class"] = "Path2D.Double";
    Double["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
    (function (Double) {
        var CopyIterator = (function (_super) {
            __extends(CopyIterator, _super);
            function CopyIterator(p2dd) {
                var _this = _super.call(this, p2dd) || this;
                _this.doubleCoords = null;
                _this.doubleCoords = p2dd.doubleCoords;
                return _this;
            }
            CopyIterator.prototype.currentSegment$float_A = function (coords) {
                var type = this.path.pointTypes[this.typeIdx];
                var numCoords = Path2D.Iterator.curvecoords_$LI$()[type];
                if (numCoords > 0) {
                    for (var i = 0; i < numCoords; i++) {
                        coords[i] = this.doubleCoords[this.pointIdx + i];
                    }
                }
                return type;
            };
            CopyIterator.prototype.currentSegment = function (coords) {
                if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                    return this.currentSegment$float_A(coords);
                }
                else if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                    return this.currentSegment$double_A(coords);
                }
                else
                    throw new Error('invalid overload');
            };
            CopyIterator.prototype.currentSegment$double_A = function (coords) {
                var type = this.path.pointTypes[this.typeIdx];
                var numCoords = Path2D.Iterator.curvecoords_$LI$()[type];
                if (numCoords > 0) {
                    Helper.arraycopy(this.doubleCoords, this.pointIdx, coords, 0, numCoords);
                }
                return type;
            };
            return CopyIterator;
        }(Path2D.Iterator));
        Double.CopyIterator = CopyIterator;
        CopyIterator["__class"] = "Path2D.Double.CopyIterator";
        CopyIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
        var TxIterator = (function (_super) {
            __extends(TxIterator, _super);
            function TxIterator(p2dd, at) {
                var _this = _super.call(this, p2dd) || this;
                _this.doubleCoords = null;
                _this.affine = null;
                _this.doubleCoords = p2dd.doubleCoords;
                _this.affine = at;
                return _this;
            }
            TxIterator.prototype.currentSegment$float_A = function (coords) {
                var type = this.path.pointTypes[this.typeIdx];
                var numCoords = Path2D.Iterator.curvecoords_$LI$()[type];
                if (numCoords > 0) {
                    this.affine.transform$double_A$int$float_A$int$int(this.doubleCoords, this.pointIdx, coords, 0, (numCoords / 2 | 0));
                }
                return type;
            };
            TxIterator.prototype.currentSegment = function (coords) {
                if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                    return this.currentSegment$float_A(coords);
                }
                else if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                    return this.currentSegment$double_A(coords);
                }
                else
                    throw new Error('invalid overload');
            };
            TxIterator.prototype.currentSegment$double_A = function (coords) {
                var type = this.path.pointTypes[this.typeIdx];
                var numCoords = Path2D.Iterator.curvecoords_$LI$()[type];
                if (numCoords > 0) {
                    this.affine.transform$double_A$int$double_A$int$int(this.doubleCoords, this.pointIdx, coords, 0, (numCoords / 2 | 0));
                }
                return type;
            };
            return TxIterator;
        }(Path2D.Iterator));
        Double.TxIterator = TxIterator;
        TxIterator["__class"] = "Path2D.Double.TxIterator";
        TxIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
    })(Double = Path2D.Double || (Path2D.Double = {}));
})(Path2D || (Path2D = {}));
/**
 * This is an abstract class that cannot be instantiated directly.
 * Type-specific implementation subclasses are available for
 * instantiation and provide a number of formats for storing
 * the information necessary to satisfy the various accessor
 * methods below.
 *
 * @param {number} type The closure type of this arc:
 * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.
 * @see java.awt.geom.Arc2D.Float
 * @see java.awt.geom.Arc2D.Double
 * @since 1.2
 * @class
 */
var Arc2D = (function (_super) {
    __extends(Arc2D, _super);
    function Arc2D(type) {
        var _this = this;
        if (((typeof type === 'number') || type === null)) {
            var __args = Array.prototype.slice.call(arguments);
            _this = _super.call(this) || this;
            _this.type = 0;
            _this.type = 0;
            (function () {
                _this.setArcType(type);
            })();
        }
        else if (type === undefined) {
            var __args = Array.prototype.slice.call(arguments);
            {
                var __args_9 = Array.prototype.slice.call(arguments);
                var type_1 = Arc2D.OPEN;
                _this = _super.call(this) || this;
                _this.type = 0;
                _this.type = 0;
                (function () {
                    _this.setArcType(type_1);
                })();
            }
        }
        else
            throw new Error('invalid overload');
        return _this;
    }
    /**
     * Returns the arc closure type of the arc: {@link #OPEN},
     * {@link #CHORD}, or {@link #PIE}.
     * @return {number} One of the integer constant closure types defined
     * in this class.
     * @see #setArcType
     * @since 1.2
     */
    Arc2D.prototype.getArcType = function () {
        return this.type;
    };
    /**
     * Returns the starting point of the arc.  This point is the
     * intersection of the ray from the center defined by the
     * starting angle and the elliptical boundary of the arc.
     *
     * @return {Point2D} A <CODE>Point2D</CODE> object representing the
     * x,y coordinates of the starting point of the arc.
     * @since 1.2
     */
    Arc2D.prototype.getStartPoint = function () {
        var angle = (function (x) { return x * Math.PI / 180; })(-this.getAngleStart());
        var x = this.getX() + (Math.cos(angle) * 0.5 + 0.5) * this.getWidth();
        var y = this.getY() + (Math.sin(angle) * 0.5 + 0.5) * this.getHeight();
        return new Point2D.Double(x, y);
    };
    /**
     * Returns the ending point of the arc.  This point is the
     * intersection of the ray from the center defined by the
     * starting angle plus the angular extent of the arc and the
     * elliptical boundary of the arc.
     *
     * @return {Point2D} A <CODE>Point2D</CODE> object representing the
     * x,y coordinates  of the ending point of the arc.
     * @since 1.2
     */
    Arc2D.prototype.getEndPoint = function () {
        var angle = (function (x) { return x * Math.PI / 180; })(-this.getAngleStart() - this.getAngleExtent());
        var x = this.getX() + (Math.cos(angle) * 0.5 + 0.5) * this.getWidth();
        var y = this.getY() + (Math.sin(angle) * 0.5 + 0.5) * this.getHeight();
        return new Point2D.Double(x, y);
    };
    /**
     * Sets the location, size, angular extents, and closure type of
     * this arc to the specified double values.
     *
     * @param {number} x The X coordinate of the upper-left corner of the arc.
     * @param {number} y The Y coordinate of the upper-left corner of the arc.
     * @param {number} w The overall width of the full ellipse of which
     * this arc is a partial section.
     * @param {number} h The overall height of the full ellipse of which
     * this arc is a partial section.
     * @param {number} angSt The starting angle of the arc in degrees.
     * @param {number} angExt The angular extent of the arc in degrees.
     * @param {number} closure The closure type for the arc:
     * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.
     * @since 1.2
     */
    Arc2D.prototype.setArc$double$double$double$double$double$double$int = function (x, y, w, h, angSt, angExt, closure) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
    /**
     * Sets the location, size, angular extents, and closure type of
     * this arc to the specified double values.
     *
     * @param {number} x The X coordinate of the upper-left corner of the arc.
     * @param {number} y The Y coordinate of the upper-left corner of the arc.
     * @param {number} w The overall width of the full ellipse of which
     * this arc is a partial section.
     * @param {number} h The overall height of the full ellipse of which
     * this arc is a partial section.
     * @param {number} angSt The starting angle of the arc in degrees.
     * @param {number} angExt The angular extent of the arc in degrees.
     * @param {number} closure The closure type for the arc:
     * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.
     * @since 1.2
     */
    Arc2D.prototype.setArc = function (x, y, w, h, angSt, angExt, closure) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof angSt === 'number') || angSt === null) && ((typeof angExt === 'number') || angExt === null) && ((typeof closure === 'number') || closure === null)) {
            return this.setArc$double$double$double$double$double$double$int(x, y, w, h, angSt, angExt, closure);
        }
        else if (((x != null && x instanceof Point2D) || x === null) && ((y != null && y instanceof Dimension2D) || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof angSt === 'number') || angSt === null) && angExt === undefined && closure === undefined) {
            return this.setArc$java_awt_geom_Point2D$java_awt_geom_Dimension2D$double$double$int(x, y, w, h, angSt);
        }
        else if (((x != null && x instanceof Rectangle2D) || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && angSt === undefined && angExt === undefined && closure === undefined) {
            return this.setArc$java_awt_geom_Rectangle2D$double$double$int(x, y, w, h);
        }
        else if (((x != null && x instanceof Arc2D) || x === null) && y === undefined && w === undefined && h === undefined && angSt === undefined && angExt === undefined && closure === undefined) {
            return this.setArc$java_awt_geom_Arc2D(x);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Sets the location, size, angular extents, and closure type of
     * this arc to the specified values.
     *
     * @param {Point2D} loc The <CODE>Point2D</CODE> representing the coordinates of
     * the upper-left corner of the arc.
     * @param {Dimension2D} size The <CODE>Dimension2D</CODE> representing the width
     * and height of the full ellipse of which this arc is
     * a partial section.
     * @param {number} angSt The starting angle of the arc in degrees.
     * @param {number} angExt The angular extent of the arc in degrees.
     * @param {number} closure The closure type for the arc:
     * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.
     * @since 1.2
     */
    Arc2D.prototype.setArc$java_awt_geom_Point2D$java_awt_geom_Dimension2D$double$double$int = function (loc, size, angSt, angExt, closure) {
        this.setArc$double$double$double$double$double$double$int(loc.getX(), loc.getY(), size.getWidth(), size.getHeight(), angSt, angExt, closure);
    };
    /**
     * Sets the location, size, angular extents, and closure type of
     * this arc to the specified values.
     *
     * @param {Rectangle2D} rect The framing rectangle that defines the
     * outer boundary of the full ellipse of which this arc is a
     * partial section.
     * @param {number} angSt The starting angle of the arc in degrees.
     * @param {number} angExt The angular extent of the arc in degrees.
     * @param {number} closure The closure type for the arc:
     * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.
     * @since 1.2
     */
    Arc2D.prototype.setArc$java_awt_geom_Rectangle2D$double$double$int = function (rect, angSt, angExt, closure) {
        this.setArc$double$double$double$double$double$double$int(rect.getX(), rect.getY(), rect.getWidth(), rect.getHeight(), angSt, angExt, closure);
    };
    /**
     * Sets this arc to be the same as the specified arc.
     *
     * @param {Arc2D} a The <CODE>Arc2D</CODE> to use to set the arc's values.
     * @since 1.2
     */
    Arc2D.prototype.setArc$java_awt_geom_Arc2D = function (a) {
        this.setArc$double$double$double$double$double$double$int(a.getX(), a.getY(), a.getWidth(), a.getHeight(), a.getAngleStart(), a.getAngleExtent(), a.type);
    };
    /**
     * Sets the position, bounds, angular extents, and closure type of
     * this arc to the specified values. The arc is defined by a center
     * point and a radius rather than a framing rectangle for the full ellipse.
     *
     * @param {number} x The X coordinate of the center of the arc.
     * @param {number} y The Y coordinate of the center of the arc.
     * @param {number} radius The radius of the arc.
     * @param {number} angSt The starting angle of the arc in degrees.
     * @param {number} angExt The angular extent of the arc in degrees.
     * @param {number} closure The closure type for the arc:
     * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.
     * @since 1.2
     */
    Arc2D.prototype.setArcByCenter = function (x, y, radius, angSt, angExt, closure) {
        this.setArc$double$double$double$double$double$double$int(x - radius, y - radius, radius * 2.0, radius * 2.0, angSt, angExt, closure);
    };
    /**
     * Sets the position, bounds, and angular extents of this arc to the
     * specified value. The starting angle of the arc is tangent to the
     * line specified by points (p1, p2), the ending angle is tangent to
     * the line specified by points (p2, p3), and the arc has the
     * specified radius.
     *
     * @param {Point2D} p1 The first point that defines the arc. The starting
     * angle of the arc is tangent to the line specified by points (p1, p2).
     * @param {Point2D} p2 The second point that defines the arc. The starting
     * angle of the arc is tangent to the line specified by points (p1, p2).
     * The ending angle of the arc is tangent to the line specified by
     * points (p2, p3).
     * @param {Point2D} p3 The third point that defines the arc. The ending angle
     * of the arc is tangent to the line specified by points (p2, p3).
     * @param {number} radius The radius of the arc.
     * @since 1.2
     */
    Arc2D.prototype.setArcByTangent = function (p1, p2, p3, radius) {
        var ang1 = Math.atan2(p1.getY() - p2.getY(), p1.getX() - p2.getX());
        var ang2 = Math.atan2(p3.getY() - p2.getY(), p3.getX() - p2.getX());
        var diff = ang2 - ang1;
        if (diff > Math.PI) {
            ang2 -= Math.PI * 2.0;
        }
        else if (diff < -Math.PI) {
            ang2 += Math.PI * 2.0;
        }
        var bisect = (ang1 + ang2) / 2.0;
        var theta = Math.abs(ang2 - bisect);
        var dist = radius / Math.sin(theta);
        var x = p2.getX() + dist * Math.cos(bisect);
        var y = p2.getY() + dist * Math.sin(bisect);
        if (ang1 < ang2) {
            ang1 -= Math.PI / 2.0;
            ang2 += Math.PI / 2.0;
        }
        else {
            ang1 += Math.PI / 2.0;
            ang2 -= Math.PI / 2.0;
        }
        ang1 = (function (x) { return x * 180 / Math.PI; })(-ang1);
        ang2 = (function (x) { return x * 180 / Math.PI; })(-ang2);
        diff = ang2 - ang1;
        if (diff < 0) {
            diff += 360;
        }
        else {
            diff -= 360;
        }
        this.setArcByCenter(x, y, radius, ang1, diff, this.type);
    };
    /**
     * Sets the starting angle of this arc to the specified double
     * value.
     *
     * @param {number} angSt The starting angle of the arc in degrees.
     * @see #getAngleStart
     * @since 1.2
     */
    Arc2D.prototype.setAngleStart$double = function (angSt) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
    /**
     * Sets the starting angle of this arc to the angle that the
     * specified point defines relative to the center of this arc.
     * The angular extent of the arc will remain the same.
     *
     * @param {Point2D} p The <CODE>Point2D</CODE> that defines the starting angle.
     * @see #getAngleStart
     * @since 1.2
     */
    Arc2D.prototype.setAngleStart$java_awt_geom_Point2D = function (p) {
        var dx = this.getHeight() * (p.getX() - this.getCenterX());
        var dy = this.getWidth() * (p.getY() - this.getCenterY());
        this.setAngleStart$double(-(function (x) { return x * 180 / Math.PI; })(Math.atan2(dy, dx)));
    };
    /**
     * Sets the starting angle of this arc to the angle that the
     * specified point defines relative to the center of this arc.
     * The angular extent of the arc will remain the same.
     *
     * @param {Point2D} p The <CODE>Point2D</CODE> that defines the starting angle.
     * @see #getAngleStart
     * @since 1.2
     */
    Arc2D.prototype.setAngleStart = function (p) {
        if (((p != null && p instanceof Point2D) || p === null)) {
            return this.setAngleStart$java_awt_geom_Point2D(p);
        }
        else if (((typeof p === 'number') || p === null)) {
            return this.setAngleStart$double(p);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Sets the starting angle and angular extent of this arc using two
     * sets of coordinates. The first set of coordinates is used to
     * determine the angle of the starting point relative to the arc's
     * center. The second set of coordinates is used to determine the
     * angle of the end point relative to the arc's center.
     * The arc will always be non-empty and extend counterclockwise
     * from the first point around to the second point.
     *
     * @param {number} x1 The X coordinate of the arc's starting point.
     * @param {number} y1 The Y coordinate of the arc's starting point.
     * @param {number} x2 The X coordinate of the arc's ending point.
     * @param {number} y2 The Y coordinate of the arc's ending point.
     * @since 1.2
     */
    Arc2D.prototype.setAngles$double$double$double$double = function (x1, y1, x2, y2) {
        var x = this.getCenterX();
        var y = this.getCenterY();
        var w = this.getWidth();
        var h = this.getHeight();
        var ang1 = Math.atan2(w * (y - y1), h * (x1 - x));
        var ang2 = Math.atan2(w * (y - y2), h * (x2 - x));
        ang2 -= ang1;
        if (ang2 <= 0.0) {
            ang2 += Math.PI * 2.0;
        }
        this.setAngleStart$double(/* toDegrees */ (function (x) { return x * 180 / Math.PI; })(ang1));
        this.setAngleExtent(/* toDegrees */ (function (x) { return x * 180 / Math.PI; })(ang2));
    };
    /**
     * Sets the starting angle and angular extent of this arc using two
     * sets of coordinates. The first set of coordinates is used to
     * determine the angle of the starting point relative to the arc's
     * center. The second set of coordinates is used to determine the
     * angle of the end point relative to the arc's center.
     * The arc will always be non-empty and extend counterclockwise
     * from the first point around to the second point.
     *
     * @param {number} x1 The X coordinate of the arc's starting point.
     * @param {number} y1 The Y coordinate of the arc's starting point.
     * @param {number} x2 The X coordinate of the arc's ending point.
     * @param {number} y2 The Y coordinate of the arc's ending point.
     * @since 1.2
     */
    Arc2D.prototype.setAngles = function (x1, y1, x2, y2) {
        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
            return this.setAngles$double$double$double$double(x1, y1, x2, y2);
        }
        else if (((x1 != null && x1 instanceof Point2D) || x1 === null) && ((y1 != null && y1 instanceof Point2D) || y1 === null) && x2 === undefined && y2 === undefined) {
            return this.setAngles$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Sets the starting angle and angular extent of this arc using
     * two points. The first point is used to determine the angle of
     * the starting point relative to the arc's center.
     * The second point is used to determine the angle of the end point
     * relative to the arc's center.
     * The arc will always be non-empty and extend counterclockwise
     * from the first point around to the second point.
     *
     * @param {Point2D} p1 The <CODE>Point2D</CODE> that defines the arc's
     * starting point.
     * @param {Point2D} p2 The <CODE>Point2D</CODE> that defines the arc's
     * ending point.
     * @since 1.2
     */
    Arc2D.prototype.setAngles$java_awt_geom_Point2D$java_awt_geom_Point2D = function (p1, p2) {
        this.setAngles$double$double$double$double(p1.getX(), p1.getY(), p2.getX(), p2.getY());
    };
    /**
     * Sets the closure type of this arc to the specified value:
     * <CODE>OPEN</CODE>, <CODE>CHORD</CODE>, or <CODE>PIE</CODE>.
     *
     * @param {number} type The integer constant that represents the closure
     * type of this arc: {@link #OPEN}, {@link #CHORD}, or
     * {@link #PIE}.
     *
     * @throws IllegalArgumentException if <code>type</code> is not
     * 0, 1, or 2.+
     * @see #getArcType
     * @since 1.2
     */
    Arc2D.prototype.setArcType = function (type) {
        if (type < Arc2D.OPEN || type > Arc2D.PIE) {
            throw Object.defineProperty(new Error("invalid type for Arc: " + type), '__class', { configurable: true, value: 'java.lang.IllegalArgumentException' });
        }
        this.type = type;
    };
    /**
     * {@inheritDoc}
     * Note that the arc
     * <a href="Arc2D.html#inscribes">partially inscribes</a>
     * the framing rectangle of this {@code RectangularShape}.
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     */
    Arc2D.prototype.setFrame$double$double$double$double = function (x, y, w, h) {
        this.setArc$double$double$double$double$double$double$int(x, y, w, h, this.getAngleStart(), this.getAngleExtent(), this.type);
    };
    /**
     * {@inheritDoc}
     * Note that the arc
     * <a href="Arc2D.html#inscribes">partially inscribes</a>
     * the framing rectangle of this {@code RectangularShape}.
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     */
    Arc2D.prototype.setFrame = function (x, y, w, h) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
            return this.setFrame$double$double$double$double(x, y, w, h);
        }
        else if (((x != null && x instanceof Point2D) || x === null) && ((y != null && y instanceof Dimension2D) || y === null) && w === undefined && h === undefined) {
            return this.setFrame$java_awt_geom_Point2D$java_awt_geom_Dimension2D(x, y);
        }
        else if (((x != null && x instanceof Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
            return this.setFrame$java_awt_geom_Rectangle2D(x);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Returns the high-precision framing rectangle of the arc.  The framing
     * rectangle contains only the part of this <code>Arc2D</code> that is
     * in between the starting and ending angles and contains the pie
     * wedge, if this <code>Arc2D</code> has a <code>PIE</code> closure type.
     * <p>
     * This method differs from the
     * {@link RectangularShape#getBounds() getBounds} in that the
     * <code>getBounds</code> method only returns the bounds of the
     * enclosing ellipse of this <code>Arc2D</code> without considering
     * the starting and ending angles of this <code>Arc2D</code>.
     *
     * @return {Rectangle2D} the <CODE>Rectangle2D</CODE> that represents the arc's
     * framing rectangle.
     * @since 1.2
     */
    Arc2D.prototype.getBounds2D = function () {
        if (this.isEmpty()) {
            return this.makeBounds(this.getX(), this.getY(), this.getWidth(), this.getHeight());
        }
        var x1;
        var y1;
        var x2;
        var y2;
        if (this.getArcType() === Arc2D.PIE) {
            x1 = y1 = x2 = y2 = 0.0;
        }
        else {
            x1 = y1 = 1.0;
            x2 = y2 = -1.0;
        }
        var angle = 0.0;
        for (var i = 0; i < 6; i++) {
            if (i < 4) {
                angle += 90.0;
                if (!this.containsAngle(angle)) {
                    continue;
                }
            }
            else if (i === 4) {
                angle = this.getAngleStart();
            }
            else {
                angle += this.getAngleExtent();
            }
            var rads = (function (x) { return x * Math.PI / 180; })(-angle);
            var xe = Math.cos(rads);
            var ye = Math.sin(rads);
            x1 = Math.min(x1, xe);
            y1 = Math.min(y1, ye);
            x2 = Math.max(x2, xe);
            y2 = Math.max(y2, ye);
        }
        var w = this.getWidth();
        var h = this.getHeight();
        x2 = (x2 - x1) * 0.5 * w;
        y2 = (y2 - y1) * 0.5 * h;
        x1 = this.getX() + (x1 * 0.5 + 0.5) * w;
        y1 = this.getY() + (y1 * 0.5 + 0.5) * h;
        return this.makeBounds(x1, y1, x2, y2);
    };
    Arc2D.normalizeDegrees = function (angle) {
        if (angle > 180.0) {
            if (angle <= (180.0 + 360.0)) {
                angle = angle - 360.0;
            }
            else {
                angle = javaemul.internal.MathHelper.IEEEremainder(angle, 360.0);
                if (angle === -180.0) {
                    angle = 180.0;
                }
            }
        }
        else if (angle <= -180.0) {
            if (angle > (-180.0 - 360.0)) {
                angle = angle + 360.0;
            }
            else {
                angle = javaemul.internal.MathHelper.IEEEremainder(angle, 360.0);
                if (angle === -180.0) {
                    angle = 180.0;
                }
            }
        }
        return angle;
    };
    /**
     * Determines whether or not the specified angle is within the
     * angular extents of the arc.
     *
     * @param {number} angle The angle to test.
     *
     * @return {boolean} <CODE>true</CODE> if the arc contains the angle,
     * <CODE>false</CODE> if the arc doesn't contain the angle.
     * @since 1.2
     */
    Arc2D.prototype.containsAngle = function (angle) {
        var angExt = this.getAngleExtent();
        var backwards = (angExt < 0.0);
        if (backwards) {
            angExt = -angExt;
        }
        if (angExt >= 360.0) {
            return true;
        }
        angle = Arc2D.normalizeDegrees(angle) - Arc2D.normalizeDegrees(this.getAngleStart());
        if (backwards) {
            angle = -angle;
        }
        if (angle < 0.0) {
            angle += 360.0;
        }
        return (angle >= 0.0) && (angle < angExt);
    };
    /**
     * Determines whether or not the specified point is inside the boundary
     * of the arc.
     *
     * @param {number} x The X coordinate of the point to test.
     * @param {number} y The Y coordinate of the point to test.
     *
     * @return {boolean} <CODE>true</CODE> if the point lies within the bound of
     * the arc, <CODE>false</CODE> if the point lies outside of the
     * arc's bounds.
     * @since 1.2
     */
    Arc2D.prototype.contains$double$double = function (x, y) {
        var ellw = this.getWidth();
        if (ellw <= 0.0) {
            return false;
        }
        var normx = (x - this.getX()) / ellw - 0.5;
        var ellh = this.getHeight();
        if (ellh <= 0.0) {
            return false;
        }
        var normy = (y - this.getY()) / ellh - 0.5;
        var distSq = (normx * normx + normy * normy);
        if (distSq >= 0.25) {
            return false;
        }
        var angExt = Math.abs(this.getAngleExtent());
        if (angExt >= 360.0) {
            return true;
        }
        var inarc = this.containsAngle(-(function (x) { return x * 180 / Math.PI; })(Math.atan2(normy, normx)));
        if (this.type === Arc2D.PIE) {
            return inarc;
        }
        if (inarc) {
            if (angExt >= 180.0) {
                return true;
            }
        }
        else {
            if (angExt <= 180.0) {
                return false;
            }
        }
        var angle = (function (x) { return x * Math.PI / 180; })(-this.getAngleStart());
        var x1 = Math.cos(angle);
        var y1 = Math.sin(angle);
        angle += (function (x) { return x * Math.PI / 180; })(-this.getAngleExtent());
        var x2 = Math.cos(angle);
        var y2 = Math.sin(angle);
        var inside = (Line2D.relativeCCW(x1, y1, x2, y2, 2 * normx, 2 * normy) * Line2D.relativeCCW(x1, y1, x2, y2, 0, 0) >= 0);
        return inarc ? !inside : inside;
    };
    /**
     * Determines whether or not the interior of the arc intersects
     * the interior of the specified rectangle.
     *
     * @param {number} x The X coordinate of the rectangle's upper-left corner.
     * @param {number} y The Y coordinate of the rectangle's upper-left corner.
     * @param {number} w The width of the rectangle.
     * @param {number} h The height of the rectangle.
     *
     * @return {boolean} <CODE>true</CODE> if the arc intersects the rectangle,
     * <CODE>false</CODE> if the arc doesn't intersect the rectangle.
     * @since 1.2
     */
    Arc2D.prototype.intersects$double$double$double$double = function (x, y, w, h) {
        var aw = this.getWidth();
        var ah = this.getHeight();
        if (w <= 0 || h <= 0 || aw <= 0 || ah <= 0) {
            return false;
        }
        var ext = this.getAngleExtent();
        if (ext === 0) {
            return false;
        }
        var ax = this.getX();
        var ay = this.getY();
        var axw = ax + aw;
        var ayh = ay + ah;
        var xw = x + w;
        var yh = y + h;
        if (x >= axw || y >= ayh || xw <= ax || yh <= ay) {
            return false;
        }
        var axc = this.getCenterX();
        var ayc = this.getCenterY();
        var sp = this.getStartPoint();
        var ep = this.getEndPoint();
        var sx = sp.getX();
        var sy = sp.getY();
        var ex = ep.getX();
        var ey = ep.getY();
        if (ayc >= y && ayc <= yh) {
            if ((sx < xw && ex < xw && axc < xw && axw > x && this.containsAngle(0)) || (sx > x && ex > x && axc > x && ax < xw && this.containsAngle(180))) {
                return true;
            }
        }
        if (axc >= x && axc <= xw) {
            if ((sy > y && ey > y && ayc > y && ay < yh && this.containsAngle(90)) || (sy < yh && ey < yh && ayc < yh && ayh > y && this.containsAngle(270))) {
                return true;
            }
        }
        var rect = new Rectangle2D.Double(x, y, w, h);
        if (this.type === Arc2D.PIE || Math.abs(ext) > 180) {
            if (rect.intersectsLine$double$double$double$double(axc, ayc, sx, sy) || rect.intersectsLine$double$double$double$double(axc, ayc, ex, ey)) {
                return true;
            }
        }
        else {
            if (rect.intersectsLine$double$double$double$double(sx, sy, ex, ey)) {
                return true;
            }
        }
        if (this.contains$double$double(x, y) || this.contains$double$double(x + w, y) || this.contains$double$double(x, y + h) || this.contains$double$double(x + w, y + h)) {
            return true;
        }
        return false;
    };
    /**
     * Determines whether or not the interior of the arc intersects
     * the interior of the specified rectangle.
     *
     * @param {number} x The X coordinate of the rectangle's upper-left corner.
     * @param {number} y The Y coordinate of the rectangle's upper-left corner.
     * @param {number} w The width of the rectangle.
     * @param {number} h The height of the rectangle.
     *
     * @return {boolean} <CODE>true</CODE> if the arc intersects the rectangle,
     * <CODE>false</CODE> if the arc doesn't intersect the rectangle.
     * @since 1.2
     */
    Arc2D.prototype.intersects = function (x, y, w, h) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
            return this.intersects$double$double$double$double(x, y, w, h);
        }
        else if (((x != null && x instanceof Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
            return this.intersects$java_awt_geom_Rectangle2D(x);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Determines whether or not the interior of the arc entirely contains
     * the specified rectangle.
     *
     * @param {number} x The X coordinate of the rectangle's upper-left corner.
     * @param {number} y The Y coordinate of the rectangle's upper-left corner.
     * @param {number} w The width of the rectangle.
     * @param {number} h The height of the rectangle.
     *
     * @return {boolean} <CODE>true</CODE> if the arc contains the rectangle,
     * <CODE>false</CODE> if the arc doesn't contain the rectangle.
     * @since 1.2
     */
    Arc2D.prototype.contains$double$double$double$double = function (x, y, w, h) {
        return this.contains$double$double$double$double$java_awt_geom_Rectangle2D(x, y, w, h, null);
    };
    /**
     * Determines whether or not the interior of the arc entirely contains
     * the specified rectangle.
     *
     * @param {Rectangle2D} r The <CODE>Rectangle2D</CODE> to test.
     *
     * @return {boolean} <CODE>true</CODE> if the arc contains the rectangle,
     * <CODE>false</CODE> if the arc doesn't contain the rectangle.
     * @since 1.2
     */
    Arc2D.prototype.contains$java_awt_geom_Rectangle2D = function (r) {
        return this.contains$double$double$double$double$java_awt_geom_Rectangle2D(r.getX(), r.getY(), r.getWidth(), r.getHeight(), r);
    };
    Arc2D.prototype.contains$double$double$double$double$java_awt_geom_Rectangle2D = function (x, y, w, h, origrect) {
        if (!(this.contains$double$double(x, y) && this.contains$double$double(x + w, y) && this.contains$double$double(x, y + h) && this.contains$double$double(x + w, y + h))) {
            return false;
        }
        if (this.type !== Arc2D.PIE || Math.abs(this.getAngleExtent()) <= 180.0) {
            return true;
        }
        if (origrect == null) {
            origrect = new Rectangle2D.Double(x, y, w, h);
        }
        var halfW = this.getWidth() / 2.0;
        var halfH = this.getHeight() / 2.0;
        var xc = this.getX() + halfW;
        var yc = this.getY() + halfH;
        var angle = (function (x) { return x * Math.PI / 180; })(-this.getAngleStart());
        var xe = xc + halfW * Math.cos(angle);
        var ye = yc + halfH * Math.sin(angle);
        if (origrect.intersectsLine$double$double$double$double(xc, yc, xe, ye)) {
            return false;
        }
        angle += (function (x) { return x * Math.PI / 180; })(-this.getAngleExtent());
        xe = xc + halfW * Math.cos(angle);
        ye = yc + halfH * Math.sin(angle);
        return !origrect.intersectsLine$double$double$double$double(xc, yc, xe, ye);
    };
    Arc2D.prototype.contains = function (x, y, w, h, origrect) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((origrect != null && origrect instanceof Rectangle2D) || origrect === null)) {
            return this.contains$double$double$double$double$java_awt_geom_Rectangle2D(x, y, w, h, origrect);
        }
        else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && origrect === undefined) {
            return this.contains$double$double$double$double(x, y, w, h);
        }
        else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined && origrect === undefined) {
            return this.contains$double$double(x, y);
        }
        else if (((x != null && x instanceof Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
            return this.contains$java_awt_geom_Rectangle2D(x);
        }
        else if (((x != null && x instanceof Point2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
            return this.contains$java_awt_geom_Point2D(x);
        }
        else
            throw new Error('invalid overload');
    };
    Arc2D.prototype.getPathIterator = function (at, flatness) {
        if (((at != null && at instanceof AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
            _super.prototype.getPathIterator.call(this, at, flatness);
        }
        else if (((at != null && at instanceof AffineTransform) || at === null) && flatness === undefined) {
            return this.getPathIterator$java_awt_geom_AffineTransform(at);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Returns an iteration object that defines the boundary of the
     * arc.
     * This iterator is multithread safe.
     * <code>Arc2D</code> guarantees that
     * modifications to the geometry of the arc
     * do not affect any iterations of that geometry that
     * are already in process.
     *
     * @param {AffineTransform} at an optional <CODE>AffineTransform</CODE> to be applied
     * to the coordinates as they are returned in the iteration, or null
     * if the untransformed coordinates are desired.
     *
     * @return {PathIterator} A <CODE>PathIterator</CODE> that defines the arc's boundary.
     * @since 1.2
     */
    Arc2D.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
        return new ArcIterator(this, at);
    };
    /**
     * Determines whether or not the specified <code>Object</code> is
     * equal to this <code>Arc2D</code>.  The specified
     * <code>Object</code> is equal to this <code>Arc2D</code>
     * if it is an instance of <code>Arc2D</code> and if its
     * location, size, arc extents and type are the same as this
     * <code>Arc2D</code>.
     * @param {*} obj  an <code>Object</code> to be compared with this
     * <code>Arc2D</code>.
     * @return  {boolean} <code>true</code> if <code>obj</code> is an instance
     * of <code>Arc2D</code> and has the same values;
     * <code>false</code> otherwise.
     * @since 1.6
     */
    Arc2D.prototype.equals = function (obj) {
        if (obj === this) {
            return true;
        }
        if (obj != null && obj instanceof Arc2D) {
            var a2d = obj;
            return ((this.getX() === a2d.getX()) && (this.getY() === a2d.getY()) && (this.getWidth() === a2d.getWidth()) && (this.getHeight() === a2d.getHeight()) && (this.getAngleStart() === a2d.getAngleStart()) && (this.getAngleExtent() === a2d.getAngleExtent()) && (this.getArcType() === a2d.getArcType()));
        }
        return false;
    };
    return Arc2D;
}(RectangularShape));
/**
 * The closure type for an open arc with no path segments
 * connecting the two ends of the arc segment.
 * @since 1.2
 */
Arc2D.OPEN = 0;
/**
 * The closure type for an arc closed by drawing a straight
 * line segment from the start of the arc segment to the end of the
 * arc segment.
 * @since 1.2
 */
Arc2D.CHORD = 1;
/**
 * The closure type for an arc closed by drawing straight line
 * segments from the start of the arc segment to the center
 * of the full ellipse and from that point to the end of the arc segment.
 * @since 1.2
 */
Arc2D.PIE = 2;
Arc2D["__class"] = "Arc2D";
Arc2D["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable"];
(function (Arc2D) {
    /**
     * Constructs a new arc, initialized to the specified location,
     * size, angular extents, and closure type.
     *
     * @param {number} x The X coordinate of the upper-left corner of
     * the arc's framing rectangle.
     * @param {number} y The Y coordinate of the upper-left corner of
     * the arc's framing rectangle.
     * @param {number} w The overall width of the full ellipse of which
     * this arc is a partial section.
     * @param {number} h The overall height of the full ellipse of which this
     * arc is a partial section.
     * @param {number} start The starting angle of the arc in degrees.
     * @param {number} extent The angular extent of the arc in degrees.
     * @param {number} type The closure type for the arc:
     * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.
     * @since 1.2
     * @class
     */
    var Float = (function (_super) {
        __extends(Float, _super);
        function Float(x, y, w, h, start, extent, type) {
            var _this = this;
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof start === 'number') || start === null) && ((typeof extent === 'number') || extent === null) && ((typeof type === 'number') || type === null)) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this, type) || this;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.start = 0;
                _this.extent = 0;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.start = 0;
                _this.extent = 0;
                (function () {
                    _this.x = x;
                    _this.y = y;
                    _this.width = w;
                    _this.height = h;
                    _this.start = start;
                    _this.extent = extent;
                })();
            }
            else if (((x != null && x instanceof Rectangle2D) || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && start === undefined && extent === undefined && type === undefined) {
                var __args = Array.prototype.slice.call(arguments);
                var ellipseBounds_1 = __args[0];
                var start_1 = __args[1];
                var extent_1 = __args[2];
                var type_2 = __args[3];
                _this = _super.call(this, type_2) || this;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.start = 0;
                _this.extent = 0;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.start = 0;
                _this.extent = 0;
                (function () {
                    _this.x = ellipseBounds_1.getX();
                    _this.y = ellipseBounds_1.getY();
                    _this.width = ellipseBounds_1.getWidth();
                    _this.height = ellipseBounds_1.getHeight();
                    _this.start = start_1;
                    _this.extent = extent_1;
                })();
            }
            else if (((typeof x === 'number') || x === null) && y === undefined && w === undefined && h === undefined && start === undefined && extent === undefined && type === undefined) {
                var __args = Array.prototype.slice.call(arguments);
                var type_3 = __args[0];
                _this = _super.call(this, type_3) || this;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.start = 0;
                _this.extent = 0;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.start = 0;
                _this.extent = 0;
            }
            else if (x === undefined && y === undefined && w === undefined && h === undefined && start === undefined && extent === undefined && type === undefined) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this, Arc2D.OPEN) || this;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.start = 0;
                _this.extent = 0;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.start = 0;
                _this.extent = 0;
            }
            else
                throw new Error('invalid overload');
            return _this;
        }
        /**
         * {@inheritDoc}
         * Note that the arc
         * <a href="Arc2D.html#inscribes">partially inscribes</a>
         * the framing rectangle of this {@code RectangularShape}.
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getX = function () {
            return this.x;
        };
        /**
         * {@inheritDoc}
         * Note that the arc
         * <a href="Arc2D.html#inscribes">partially inscribes</a>
         * the framing rectangle of this {@code RectangularShape}.
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getY = function () {
            return this.y;
        };
        /**
         * {@inheritDoc}
         * Note that the arc
         * <a href="Arc2D.html#inscribes">partially inscribes</a>
         * the framing rectangle of this {@code RectangularShape}.
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getWidth = function () {
            return this.width;
        };
        /**
         * {@inheritDoc}
         * Note that the arc
         * <a href="Arc2D.html#inscribes">partially inscribes</a>
         * the framing rectangle of this {@code RectangularShape}.
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getHeight = function () {
            return this.height;
        };
        /**
         * {@inheritDoc}
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getAngleStart = function () {
            return this.start;
        };
        /**
         * {@inheritDoc}
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getAngleExtent = function () {
            return this.extent;
        };
        /**
         * {@inheritDoc}
         * @since 1.2
         * @return {boolean}
         */
        Float.prototype.isEmpty = function () {
            return (this.width <= 0.0 || this.height <= 0.0);
        };
        /**
         * {@inheritDoc}
         * @since 1.2
         * @param {number} x
         * @param {number} y
         * @param {number} w
         * @param {number} h
         * @param {number} angSt
         * @param {number} angExt
         * @param {number} closure
         */
        Float.prototype.setArc$double$double$double$double$double$double$int = function (x, y, w, h, angSt, angExt, closure) {
            this.setArcType(closure);
            this.x = x;
            this.y = y;
            this.width = w;
            this.height = h;
            this.start = angSt;
            this.extent = angExt;
        };
        /**
         * {@inheritDoc}
         * @since 1.2
         * @param {number} x
         * @param {number} y
         * @param {number} w
         * @param {number} h
         * @param {number} angSt
         * @param {number} angExt
         * @param {number} closure
         */
        Float.prototype.setArc = function (x, y, w, h, angSt, angExt, closure) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof angSt === 'number') || angSt === null) && ((typeof angExt === 'number') || angExt === null) && ((typeof closure === 'number') || closure === null)) {
                return this.setArc$double$double$double$double$double$double$int(x, y, w, h, angSt, angExt, closure);
            }
            else if (((x != null && x instanceof Point2D) || x === null) && ((y != null && y instanceof Dimension2D) || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof angSt === 'number') || angSt === null) && angExt === undefined && closure === undefined) {
                return this.setArc$java_awt_geom_Point2D$java_awt_geom_Dimension2D$double$double$int(x, y, w, h, angSt);
            }
            else if (((x != null && x instanceof Rectangle2D) || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && angSt === undefined && angExt === undefined && closure === undefined) {
                return this.setArc$java_awt_geom_Rectangle2D$double$double$int(x, y, w, h);
            }
            else if (((x != null && x instanceof Arc2D) || x === null) && y === undefined && w === undefined && h === undefined && angSt === undefined && angExt === undefined && closure === undefined) {
                return this.setArc$java_awt_geom_Arc2D(x);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * Sets the starting angle of this arc to the angle that the
         * specified point defines relative to the center of this arc.
         * The angular extent of the arc will remain the same.
         *
         * @param {Point2D} p The <CODE>Point2D</CODE> that defines the starting angle.
         * @see #getAngleStart
         * @since 1.2
         */
        Float.prototype.setAngleStart = function (p) {
            if (((p != null && p instanceof Point2D) || p === null)) {
                _super.prototype.setAngleStart.call(this, p);
            }
            else if (((typeof p === 'number') || p === null)) {
                return this.setAngleStart$double(p);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * {@inheritDoc}
         * @since 1.2
         * @param {number} angSt
         */
        Float.prototype.setAngleStart$double = function (angSt) {
            this.start = angSt;
        };
        /**
         * {@inheritDoc}
         * @since 1.2
         * @param {number} angExt
         */
        Float.prototype.setAngleExtent = function (angExt) {
            this.extent = angExt;
        };
        /**
         * {@inheritDoc}
         * @since 1.2
         * @param {number} x
         * @param {number} y
         * @param {number} w
         * @param {number} h
         * @return {Rectangle2D}
         */
        Float.prototype.makeBounds = function (x, y, w, h) {
            return new Rectangle2D.Float(x, y, w, h);
        };
        return Float;
    }(Arc2D));
    Float.serialVersionUID = 9130893014586380278;
    Arc2D.Float = Float;
    Float["__class"] = "Arc2D.Float";
    Float["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
    /**
     * Constructs a new arc, initialized to the specified location,
     * size, angular extents, and closure type.
     *
     * @param {number} x The X coordinate of the upper-left corner
     * of the arc's framing rectangle.
     * @param {number} y The Y coordinate of the upper-left corner
     * of the arc's framing rectangle.
     * @param {number} w The overall width of the full ellipse of which this
     * arc is a partial section.
     * @param {number} h The overall height of the full ellipse of which this
     * arc is a partial section.
     * @param {number} start The starting angle of the arc in degrees.
     * @param {number} extent The angular extent of the arc in degrees.
     * @param {number} type The closure type for the arc:
     * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.
     * @since 1.2
     * @class
     */
    var Double = (function (_super) {
        __extends(Double, _super);
        function Double(x, y, w, h, start, extent, type) {
            var _this = this;
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof start === 'number') || start === null) && ((typeof extent === 'number') || extent === null) && ((typeof type === 'number') || type === null)) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this, type) || this;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.start = 0;
                _this.extent = 0;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.start = 0;
                _this.extent = 0;
                (function () {
                    _this.x = x;
                    _this.y = y;
                    _this.width = w;
                    _this.height = h;
                    _this.start = start;
                    _this.extent = extent;
                })();
            }
            else if (((x != null && x instanceof Rectangle2D) || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && start === undefined && extent === undefined && type === undefined) {
                var __args = Array.prototype.slice.call(arguments);
                var ellipseBounds_2 = __args[0];
                var start_2 = __args[1];
                var extent_2 = __args[2];
                var type_4 = __args[3];
                _this = _super.call(this, type_4) || this;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.start = 0;
                _this.extent = 0;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.start = 0;
                _this.extent = 0;
                (function () {
                    _this.x = ellipseBounds_2.getX();
                    _this.y = ellipseBounds_2.getY();
                    _this.width = ellipseBounds_2.getWidth();
                    _this.height = ellipseBounds_2.getHeight();
                    _this.start = start_2;
                    _this.extent = extent_2;
                })();
            }
            else if (((typeof x === 'number') || x === null) && y === undefined && w === undefined && h === undefined && start === undefined && extent === undefined && type === undefined) {
                var __args = Array.prototype.slice.call(arguments);
                var type_5 = __args[0];
                _this = _super.call(this, type_5) || this;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.start = 0;
                _this.extent = 0;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.start = 0;
                _this.extent = 0;
            }
            else if (x === undefined && y === undefined && w === undefined && h === undefined && start === undefined && extent === undefined && type === undefined) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this, Arc2D.OPEN) || this;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.start = 0;
                _this.extent = 0;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.start = 0;
                _this.extent = 0;
            }
            else
                throw new Error('invalid overload');
            return _this;
        }
        /**
         * {@inheritDoc}
         * Note that the arc
         * <a href="Arc2D.html#inscribes">partially inscribes</a>
         * the framing rectangle of this {@code RectangularShape}.
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getX = function () {
            return this.x;
        };
        /**
         * {@inheritDoc}
         * Note that the arc
         * <a href="Arc2D.html#inscribes">partially inscribes</a>
         * the framing rectangle of this {@code RectangularShape}.
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getY = function () {
            return this.y;
        };
        /**
         * {@inheritDoc}
         * Note that the arc
         * <a href="Arc2D.html#inscribes">partially inscribes</a>
         * the framing rectangle of this {@code RectangularShape}.
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getWidth = function () {
            return this.width;
        };
        /**
         * {@inheritDoc}
         * Note that the arc
         * <a href="Arc2D.html#inscribes">partially inscribes</a>
         * the framing rectangle of this {@code RectangularShape}.
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getHeight = function () {
            return this.height;
        };
        /**
         * {@inheritDoc}
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getAngleStart = function () {
            return this.start;
        };
        /**
         * {@inheritDoc}
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getAngleExtent = function () {
            return this.extent;
        };
        /**
         * {@inheritDoc}
         * @since 1.2
         * @return {boolean}
         */
        Double.prototype.isEmpty = function () {
            return (this.width <= 0.0 || this.height <= 0.0);
        };
        /**
         * {@inheritDoc}
         * @since 1.2
         * @param {number} x
         * @param {number} y
         * @param {number} w
         * @param {number} h
         * @param {number} angSt
         * @param {number} angExt
         * @param {number} closure
         */
        Double.prototype.setArc$double$double$double$double$double$double$int = function (x, y, w, h, angSt, angExt, closure) {
            this.setArcType(closure);
            this.x = x;
            this.y = y;
            this.width = w;
            this.height = h;
            this.start = angSt;
            this.extent = angExt;
        };
        /**
         * {@inheritDoc}
         * @since 1.2
         * @param {number} x
         * @param {number} y
         * @param {number} w
         * @param {number} h
         * @param {number} angSt
         * @param {number} angExt
         * @param {number} closure
         */
        Double.prototype.setArc = function (x, y, w, h, angSt, angExt, closure) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof angSt === 'number') || angSt === null) && ((typeof angExt === 'number') || angExt === null) && ((typeof closure === 'number') || closure === null)) {
                return this.setArc$double$double$double$double$double$double$int(x, y, w, h, angSt, angExt, closure);
            }
            else if (((x != null && x instanceof Point2D) || x === null) && ((y != null && y instanceof Dimension2D) || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof angSt === 'number') || angSt === null) && angExt === undefined && closure === undefined) {
                return this.setArc$java_awt_geom_Point2D$java_awt_geom_Dimension2D$double$double$int(x, y, w, h, angSt);
            }
            else if (((x != null && x instanceof Rectangle2D) || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && angSt === undefined && angExt === undefined && closure === undefined) {
                return this.setArc$java_awt_geom_Rectangle2D$double$double$int(x, y, w, h);
            }
            else if (((x != null && x instanceof Arc2D) || x === null) && y === undefined && w === undefined && h === undefined && angSt === undefined && angExt === undefined && closure === undefined) {
                return this.setArc$java_awt_geom_Arc2D(x);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * Sets the starting angle of this arc to the angle that the
         * specified point defines relative to the center of this arc.
         * The angular extent of the arc will remain the same.
         *
         * @param {Point2D} p The <CODE>Point2D</CODE> that defines the starting angle.
         * @see #getAngleStart
         * @since 1.2
         */
        Double.prototype.setAngleStart = function (p) {
            if (((p != null && p instanceof Point2D) || p === null)) {
                _super.prototype.setAngleStart.call(this, p);
            }
            else if (((typeof p === 'number') || p === null)) {
                return this.setAngleStart$double(p);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * {@inheritDoc}
         * @since 1.2
         * @param {number} angSt
         */
        Double.prototype.setAngleStart$double = function (angSt) {
            this.start = angSt;
        };
        /**
         * {@inheritDoc}
         * @since 1.2
         * @param {number} angExt
         */
        Double.prototype.setAngleExtent = function (angExt) {
            this.extent = angExt;
        };
        /**
         * {@inheritDoc}
         * @since 1.2
         * @param {number} x
         * @param {number} y
         * @param {number} w
         * @param {number} h
         * @return {Rectangle2D}
         */
        Double.prototype.makeBounds = function (x, y, w, h) {
            return new Rectangle2D.Double(x, y, w, h);
        };
        return Double;
    }(Arc2D));
    Double.serialVersionUID = 728264085846882001;
    Arc2D.Double = Double;
    Double["__class"] = "Arc2D.Double";
    Double["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
})(Arc2D || (Arc2D = {}));
/**
 * This is an abstract class that cannot be instantiated directly.
 * Type-specific implementation subclasses are available for instantiation
 * and provide a number of formats for storing the information necessary to
 * satisfy the various accessor methods below.
 *
 * @see java.awt.geom.Ellipse2D.Float
 * @see java.awt.geom.Ellipse2D.Double
 * @since 1.2
 * @class
 */
var Ellipse2D = (function (_super) {
    __extends(Ellipse2D, _super);
    function Ellipse2D() {
        return _super.call(this) || this;
    }
    Ellipse2D.prototype.contains = function (x, y, w, h, origrect) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && origrect === undefined) {
            return this.contains$double$double$double$double(x, y, w, h);
        }
        else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined && origrect === undefined) {
            return this.contains$double$double(x, y);
        }
        else if (((x != null && x instanceof Point2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
            return this.contains$java_awt_geom_Point2D(x);
        }
        else if (((x != null && x instanceof Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
            return this.contains$java_awt_geom_Rectangle2D(x);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @return {boolean}
     */
    Ellipse2D.prototype.contains$double$double = function (x, y) {
        var ellw = this.getWidth();
        if (ellw <= 0.0) {
            return false;
        }
        var normx = (x - this.getX()) / ellw - 0.5;
        var ellh = this.getHeight();
        if (ellh <= 0.0) {
            return false;
        }
        var normy = (y - this.getY()) / ellh - 0.5;
        return (normx * normx + normy * normy) < 0.25;
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @return {boolean}
     */
    Ellipse2D.prototype.intersects$double$double$double$double = function (x, y, w, h) {
        if (w <= 0.0 || h <= 0.0) {
            return false;
        }
        var ellw = this.getWidth();
        if (ellw <= 0.0) {
            return false;
        }
        var normx0 = (x - this.getX()) / ellw - 0.5;
        var normx1 = normx0 + w / ellw;
        var ellh = this.getHeight();
        if (ellh <= 0.0) {
            return false;
        }
        var normy0 = (y - this.getY()) / ellh - 0.5;
        var normy1 = normy0 + h / ellh;
        var nearx;
        var neary;
        if (normx0 > 0.0) {
            nearx = normx0;
        }
        else if (normx1 < 0.0) {
            nearx = normx1;
        }
        else {
            nearx = 0.0;
        }
        if (normy0 > 0.0) {
            neary = normy0;
        }
        else if (normy1 < 0.0) {
            neary = normy1;
        }
        else {
            neary = 0.0;
        }
        return (nearx * nearx + neary * neary) < 0.25;
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @return {boolean}
     */
    Ellipse2D.prototype.intersects = function (x, y, w, h) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
            return this.intersects$double$double$double$double(x, y, w, h);
        }
        else if (((x != null && x instanceof Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
            return this.intersects$java_awt_geom_Rectangle2D(x);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @return {boolean}
     */
    Ellipse2D.prototype.contains$double$double$double$double = function (x, y, w, h) {
        return (this.contains$double$double(x, y) && this.contains$double$double(x + w, y) && this.contains$double$double(x, y + h) && this.contains$double$double(x + w, y + h));
    };
    Ellipse2D.prototype.getPathIterator = function (at, flatness) {
        if (((at != null && at instanceof AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
            _super.prototype.getPathIterator.call(this, at, flatness);
        }
        else if (((at != null && at instanceof AffineTransform) || at === null) && flatness === undefined) {
            return this.getPathIterator$java_awt_geom_AffineTransform(at);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Returns an iteration object that defines the boundary of this
     * <code>Ellipse2D</code>. The iterator for this class is multi-threaded
     * safe, which means that this <code>Ellipse2D</code> class guarantees that
     * modifications to the geometry of this <code>Ellipse2D</code> object do
     * not affect any iterations of that geometry that are already in process.
     *
     * @param {AffineTransform} at
     * an optional <code>AffineTransform</code> to be applied to the
     * coordinates as they are returned in the iteration, or
     * <code>null</code> if untransformed coordinates are desired
     * @return {PathIterator} the <code>PathIterator</code> object that returns the geometry of
     * the outline of this <code>Ellipse2D</code>, one segment at a
     * time.
     * @since 1.2
     */
    Ellipse2D.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
        return new EllipseIterator(this, at);
    };
    /**
     * Determines whether or not the specified <code>Object</code> is equal to
     * this <code>Ellipse2D</code>. The specified <code>Object</code> is equal
     * to this <code>Ellipse2D</code> if it is an instance of
     * <code>Ellipse2D</code> and if its location and size are the same as this
     * <code>Ellipse2D</code>.
     *
     * @param {*} obj
     * an <code>Object</code> to be compared with this
     * <code>Ellipse2D</code>.
     * @return {boolean} <code>true</code> if <code>obj</code> is an instance of
     * <code>Ellipse2D</code> and has the same values;
     * <code>false</code> otherwise.
     * @since 1.6
     */
    Ellipse2D.prototype.equals = function (obj) {
        if (obj === this) {
            return true;
        }
        if (obj != null && obj instanceof Ellipse2D) {
            var e2d = obj;
            return ((this.getX() === e2d.getX()) && (this.getY() === e2d.getY()) && (this.getWidth() === e2d.getWidth()) && (this.getHeight() === e2d.getHeight()));
        }
        return false;
    };
    return Ellipse2D;
}(RectangularShape));
Ellipse2D["__class"] = "Ellipse2D";
Ellipse2D["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable"];
(function (Ellipse2D) {
    /**
     * Constructs and initializes an <code>Ellipse2D</code> from the
     * specified coordinates.
     *
     * @param {number} x
     * the X coordinate of the upper-left corner of the framing
     * rectangle
     * @param {number} y
     * the Y coordinate of the upper-left corner of the framing
     * rectangle
     * @param {number} w
     * the width of the framing rectangle
     * @param {number} h
     * the height of the framing rectangle
     * @since 1.2
     * @class
     */
    var Float = (function (_super) {
        __extends(Float, _super);
        function Float(x, y, w, h) {
            var _this = this;
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this) || this;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                (function () {
                    _this.setFrame$float$float$float$float(x, y, w, h);
                })();
            }
            else if (x === undefined && y === undefined && w === undefined && h === undefined) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this) || this;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
            }
            else
                throw new Error('invalid overload');
            return _this;
        }
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getX = function () {
            return this.x;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getY = function () {
            return this.y;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getWidth = function () {
            return this.width;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getHeight = function () {
            return this.height;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {boolean}
         */
        Float.prototype.isEmpty = function () {
            return (this.width <= 0.0 || this.height <= 0.0);
        };
        /**
         * Sets the location and size of the framing rectangle of this
         * <code>Shape</code> to the specified rectangular values.
         *
         * @param {number} x
         * the X coordinate of the upper-left corner of the specified
         * rectangular shape
         * @param {number} y
         * the Y coordinate of the upper-left corner of the specified
         * rectangular shape
         * @param {number} w
         * the width of the specified rectangular shape
         * @param {number} h
         * the height of the specified rectangular shape
         * @since 1.2
         */
        Float.prototype.setFrame$float$float$float$float = function (x, y, w, h) {
            this.x = x;
            this.y = y;
            this.width = w;
            this.height = h;
        };
        /**
         * Sets the location and size of the framing rectangle of this
         * <code>Shape</code> to the specified rectangular values.
         *
         * @param {number} x
         * the X coordinate of the upper-left corner of the specified
         * rectangular shape
         * @param {number} y
         * the Y coordinate of the upper-left corner of the specified
         * rectangular shape
         * @param {number} w
         * the width of the specified rectangular shape
         * @param {number} h
         * the height of the specified rectangular shape
         * @since 1.2
         */
        Float.prototype.setFrame = function (x, y, w, h) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                return this.setFrame$float$float$float$float(x, y, w, h);
            }
            else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                return this.setFrame$double$double$double$double(x, y, w, h);
            }
            else if (((x != null && x instanceof Point2D) || x === null) && ((y != null && y instanceof Dimension2D) || y === null) && w === undefined && h === undefined) {
                return this.setFrame$java_awt_geom_Point2D$java_awt_geom_Dimension2D(x, y);
            }
            else if (((x != null && x instanceof Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                return this.setFrame$java_awt_geom_Rectangle2D(x);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @param {number} x
         * @param {number} y
         * @param {number} w
         * @param {number} h
         */
        Float.prototype.setFrame$double$double$double$double = function (x, y, w, h) {
            this.x = x;
            this.y = y;
            this.width = w;
            this.height = h;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {Rectangle2D}
         */
        Float.prototype.getBounds2D = function () {
            return new Rectangle2D.Float(this.x, this.y, this.width, this.height);
        };
        return Float;
    }(Ellipse2D));
    Float.serialVersionUID = -6633761252372475977;
    Ellipse2D.Float = Float;
    Float["__class"] = "Ellipse2D.Float";
    Float["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
    /**
     * Constructs and initializes an <code>Ellipse2D</code> from the
     * specified coordinates.
     *
     * @param {number} x
     * the X coordinate of the upper-left corner of the framing
     * rectangle
     * @param {number} y
     * the Y coordinate of the upper-left corner of the framing
     * rectangle
     * @param {number} w
     * the width of the framing rectangle
     * @param {number} h
     * the height of the framing rectangle
     * @since 1.2
     * @class
     */
    var Double = (function (_super) {
        __extends(Double, _super);
        function Double(x, y, w, h) {
            var _this = this;
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this) || this;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                (function () {
                    _this.setFrame$double$double$double$double(x, y, w, h);
                })();
            }
            else if (x === undefined && y === undefined && w === undefined && h === undefined) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this) || this;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
            }
            else
                throw new Error('invalid overload');
            return _this;
        }
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getX = function () {
            return this.x;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getY = function () {
            return this.y;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getWidth = function () {
            return this.width;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getHeight = function () {
            return this.height;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {boolean}
         */
        Double.prototype.isEmpty = function () {
            return (this.width <= 0.0 || this.height <= 0.0);
        };
        /**
         * Sets the location and size of the framing rectangle of this
         * <code>Shape</code> to the specified rectangular values.
         *
         * @param {number} x
         * the X coordinate of the upper-left corner of the specified
         * rectangular shape
         * @param {number} y
         * the Y coordinate of the upper-left corner of the specified
         * rectangular shape
         * @param {number} w
         * the width of the specified rectangular shape
         * @param {number} h
         * the height of the specified rectangular shape
         * @since 1.2
         */
        Double.prototype.setFrame = function (x, y, w, h) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                return this.setFrame$double$double$double$double(x, y, w, h);
            }
            else if (((x != null && x instanceof Point2D) || x === null) && ((y != null && y instanceof Dimension2D) || y === null) && w === undefined && h === undefined) {
                return this.setFrame$java_awt_geom_Point2D$java_awt_geom_Dimension2D(x, y);
            }
            else if (((x != null && x instanceof Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                return this.setFrame$java_awt_geom_Rectangle2D(x);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @param {number} x
         * @param {number} y
         * @param {number} w
         * @param {number} h
         */
        Double.prototype.setFrame$double$double$double$double = function (x, y, w, h) {
            this.x = x;
            this.y = y;
            this.width = w;
            this.height = h;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {Rectangle2D}
         */
        Double.prototype.getBounds2D = function () {
            return new Rectangle2D.Double(this.x, this.y, this.width, this.height);
        };
        return Double;
    }(Ellipse2D));
    Double.serialVersionUID = 5555464816372320683;
    Ellipse2D.Double = Double;
    Double["__class"] = "Ellipse2D.Double";
    Double["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
})(Ellipse2D || (Ellipse2D = {}));
/**
 * This is an abstract class that cannot be instantiated directly.
 * Type-specific implementation subclasses are available for instantiation
 * and provide a number of formats for storing the information necessary to
 * satisfy the various accessor methods below.
 *
 * @see java.awt.geom.Rectangle2D.Float
 * @see java.awt.geom.Rectangle2D.Double
 * @see java.awt.Rectangle
 * @since 1.2
 * @class
 */
var Rectangle2D = (function (_super) {
    __extends(Rectangle2D, _super);
    function Rectangle2D() {
        return _super.call(this) || this;
    }
    /**
     * Sets the location and size of this <code>Rectangle2D</code> to the
     * specified <code>float</code> values.
     *
     * @param {number} x
     * the X coordinate of the upper-left corner of this
     * <code>Rectangle2D</code>
     * @param {number} y
     * the Y coordinate of the upper-left corner of this
     * <code>Rectangle2D</code>
     * @param {number} w
     * the width of this <code>Rectangle2D</code>
     * @param {number} h
     * the height of this <code>Rectangle2D</code>
     * @since 1.2
     */
    Rectangle2D.prototype.setRect = function (x, y, w, h) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
            return this.setRect$double$double$double$double(x, y, w, h);
        }
        else if (((x != null && x instanceof Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
            return this.setRect$java_awt_geom_Rectangle2D(x);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Sets the location and size of this <code>Rectangle2D</code> to the
     * specified <code>double</code> values.
     *
     * @param {number} x
     * the X coordinate of the upper-left corner of this
     * <code>Rectangle2D</code>
     * @param {number} y
     * the Y coordinate of the upper-left corner of this
     * <code>Rectangle2D</code>
     * @param {number} w
     * the width of this <code>Rectangle2D</code>
     * @param {number} h
     * the height of this <code>Rectangle2D</code>
     * @since 1.2
     */
    Rectangle2D.prototype.setRect$double$double$double$double = function (x, y, w, h) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
    /**
     * Sets this <code>Rectangle2D</code> to be the same as the specified
     * <code>Rectangle2D</code>.
     *
     * @param {Rectangle2D} r
     * the specified <code>Rectangle2D</code>
     * @since 1.2
     */
    Rectangle2D.prototype.setRect$java_awt_geom_Rectangle2D = function (r) {
        this.setRect$double$double$double$double(r.getX(), r.getY(), r.getWidth(), r.getHeight());
    };
    /**
     * Tests if the specified line segment intersects the interior of this
     * <code>Rectangle2D</code>.
     *
     * @param {number} x1
     * the X coordinate of the start point of the specified line
     * segment
     * @param {number} y1
     * the Y coordinate of the start point of the specified line
     * segment
     * @param {number} x2
     * the X coordinate of the end point of the specified line
     * segment
     * @param {number} y2
     * the Y coordinate of the end point of the specified line
     * segment
     * @return {boolean} <code>true</code> if the specified line segment intersects the
     * interior of this <code>Rectangle2D</code>; <code>false</code>
     * otherwise.
     * @since 1.2
     */
    Rectangle2D.prototype.intersectsLine$double$double$double$double = function (x1, y1, x2, y2) {
        var out1;
        var out2;
        if ((out2 = this.outcode$double$double(x2, y2)) === 0) {
            return true;
        }
        while (((out1 = this.outcode$double$double(x1, y1)) !== 0)) {
            if ((out1 & out2) !== 0) {
                return false;
            }
            if ((out1 & (Rectangle2D.OUT_LEFT | Rectangle2D.OUT_RIGHT)) !== 0) {
                var x = this.getX();
                if ((out1 & Rectangle2D.OUT_RIGHT) !== 0) {
                    x += this.getWidth();
                }
                y1 = y1 + (x - x1) * (y2 - y1) / (x2 - x1);
                x1 = x;
            }
            else {
                var y = this.getY();
                if ((out1 & Rectangle2D.OUT_BOTTOM) !== 0) {
                    y += this.getHeight();
                }
                x1 = x1 + (y - y1) * (x2 - x1) / (y2 - y1);
                y1 = y;
            }
        }
        ;
        return true;
    };
    /**
     * Tests if the specified line segment intersects the interior of this
     * <code>Rectangle2D</code>.
     *
     * @param {number} x1
     * the X coordinate of the start point of the specified line
     * segment
     * @param {number} y1
     * the Y coordinate of the start point of the specified line
     * segment
     * @param {number} x2
     * the X coordinate of the end point of the specified line
     * segment
     * @param {number} y2
     * the Y coordinate of the end point of the specified line
     * segment
     * @return {boolean} <code>true</code> if the specified line segment intersects the
     * interior of this <code>Rectangle2D</code>; <code>false</code>
     * otherwise.
     * @since 1.2
     */
    Rectangle2D.prototype.intersectsLine = function (x1, y1, x2, y2) {
        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
            return this.intersectsLine$double$double$double$double(x1, y1, x2, y2);
        }
        else if (((x1 != null && x1 instanceof Line2D) || x1 === null) && y1 === undefined && x2 === undefined && y2 === undefined) {
            return this.intersectsLine$java_awt_geom_Line2D(x1);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Tests if the specified line segment intersects the interior of this
     * <code>Rectangle2D</code>.
     *
     * @param {Line2D} l
     * the specified {@link Line2D} to test for intersection with the
     * interior of this <code>Rectangle2D</code>
     * @return {boolean} <code>true</code> if the specified <code>Line2D</code> intersects
     * the interior of this <code>Rectangle2D</code>; <code>false</code>
     * otherwise.
     * @since 1.2
     */
    Rectangle2D.prototype.intersectsLine$java_awt_geom_Line2D = function (l) {
        return this.intersectsLine$double$double$double$double(l.getX1(), l.getY1(), l.getX2(), l.getY2());
    };
    /**
     * Determines where the specified coordinates lie with respect to this
     * <code>Rectangle2D</code>. This method computes a binary OR of the
     * appropriate mask values indicating, for each side of this
     * <code>Rectangle2D</code>, whether or not the specified coordinates are on
     * the same side of the edge as the rest of this <code>Rectangle2D</code>.
     *
     * @param {number} x
     * the specified X coordinate
     * @param {number} y
     * the specified Y coordinate
     * @return {number} the logical OR of all appropriate out codes.
     * @see #OUT_LEFT
     * @see #OUT_TOP
     * @see #OUT_RIGHT
     * @see #OUT_BOTTOM
     * @since 1.2
     */
    Rectangle2D.prototype.outcode$double$double = function (x, y) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
    /**
     * Determines where the specified coordinates lie with respect to this
     * <code>Rectangle2D</code>. This method computes a binary OR of the
     * appropriate mask values indicating, for each side of this
     * <code>Rectangle2D</code>, whether or not the specified coordinates are on
     * the same side of the edge as the rest of this <code>Rectangle2D</code>.
     *
     * @param {number} x
     * the specified X coordinate
     * @param {number} y
     * the specified Y coordinate
     * @return {number} the logical OR of all appropriate out codes.
     * @see #OUT_LEFT
     * @see #OUT_TOP
     * @see #OUT_RIGHT
     * @see #OUT_BOTTOM
     * @since 1.2
     */
    Rectangle2D.prototype.outcode = function (x, y) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
            return this.outcode$double$double(x, y);
        }
        else if (((x != null && x instanceof Point2D) || x === null) && y === undefined) {
            return this.outcode$java_awt_geom_Point2D(x);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Determines where the specified {@link Point2D} lies with respect to this
     * <code>Rectangle2D</code>. This method computes a binary OR of the
     * appropriate mask values indicating, for each side of this
     * <code>Rectangle2D</code>, whether or not the specified
     * <code>Point2D</code> is on the same side of the edge as the rest of this
     * <code>Rectangle2D</code>.
     *
     * @param {Point2D} p
     * the specified <code>Point2D</code>
     * @return {number} the logical OR of all appropriate out codes.
     * @see #OUT_LEFT
     * @see #OUT_TOP
     * @see #OUT_RIGHT
     * @see #OUT_BOTTOM
     * @since 1.2
     */
    Rectangle2D.prototype.outcode$java_awt_geom_Point2D = function (p) {
        return this.outcode$double$double(p.getX(), p.getY());
    };
    Rectangle2D.prototype.setFrame = function (x, y, w, h) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
            return this.setFrame$double$double$double$double(x, y, w, h);
        }
        else if (((x != null && x instanceof Point2D) || x === null) && ((y != null && y instanceof Dimension2D) || y === null) && w === undefined && h === undefined) {
            return this.setFrame$java_awt_geom_Point2D$java_awt_geom_Dimension2D(x, y);
        }
        else if (((x != null && x instanceof Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
            return this.setFrame$java_awt_geom_Rectangle2D(x);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Sets the location and size of the outer bounds of this
     * <code>Rectangle2D</code> to the specified rectangular values.
     *
     * @param {number} x
     * the X coordinate of the upper-left corner of this
     * <code>Rectangle2D</code>
     * @param {number} y
     * the Y coordinate of the upper-left corner of this
     * <code>Rectangle2D</code>
     * @param {number} w
     * the width of this <code>Rectangle2D</code>
     * @param {number} h
     * the height of this <code>Rectangle2D</code>
     * @since 1.2
     */
    Rectangle2D.prototype.setFrame$double$double$double$double = function (x, y, w, h) {
        this.setRect$double$double$double$double(x, y, w, h);
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @return {Rectangle2D}
     */
    Rectangle2D.prototype.getBounds2D = function () {
        return this.clone();
    };
    Rectangle2D.prototype.contains = function (x, y, w, h, origrect) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && origrect === undefined) {
            return this.contains$double$double$double$double(x, y, w, h);
        }
        else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined && origrect === undefined) {
            return this.contains$double$double(x, y);
        }
        else if (((x != null && x instanceof Point2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
            return this.contains$java_awt_geom_Point2D(x);
        }
        else if (((x != null && x instanceof Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
            return this.contains$java_awt_geom_Rectangle2D(x);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @return {boolean}
     */
    Rectangle2D.prototype.contains$double$double = function (x, y) {
        var x0 = this.getX();
        var y0 = this.getY();
        return (x >= x0 && y >= y0 && x < x0 + this.getWidth() && y < y0 + this.getHeight());
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @return {boolean}
     */
    Rectangle2D.prototype.intersects$double$double$double$double = function (x, y, w, h) {
        if (this.isEmpty() || w <= 0 || h <= 0) {
            return false;
        }
        var x0 = this.getX();
        var y0 = this.getY();
        return (x + w > x0 && y + h > y0 && x < x0 + this.getWidth() && y < y0 + this.getHeight());
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @return {boolean}
     */
    Rectangle2D.prototype.intersects = function (x, y, w, h) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
            return this.intersects$double$double$double$double(x, y, w, h);
        }
        else if (((x != null && x instanceof Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
            return this.intersects$java_awt_geom_Rectangle2D(x);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @return {boolean}
     */
    Rectangle2D.prototype.contains$double$double$double$double = function (x, y, w, h) {
        if (this.isEmpty() || w <= 0 || h <= 0) {
            return false;
        }
        var x0 = this.getX();
        var y0 = this.getY();
        return (x >= x0 && y >= y0 && (x + w) <= x0 + this.getWidth() && (y + h) <= y0 + this.getHeight());
    };
    /**
     * Intersects the pair of specified source <code>Rectangle2D</code> objects
     * and puts the result into the specified destination
     * <code>Rectangle2D</code> object. One of the source rectangles can also be
     * the destination to avoid creating a third Rectangle2D object, but in this
     * case the original points of this source rectangle will be overwritten by
     * this method.
     *
     * @param {Rectangle2D} src1
     * the first of a pair of <code>Rectangle2D</code> objects to be
     * intersected with each other
     * @param {Rectangle2D} src2
     * the second of a pair of <code>Rectangle2D</code> objects to be
     * intersected with each other
     * @param {Rectangle2D} dest
     * the <code>Rectangle2D</code> that holds the results of the
     * intersection of <code>src1</code> and <code>src2</code>
     * @since 1.2
     */
    Rectangle2D.intersect = function (src1, src2, dest) {
        var x1 = Math.max(src1.getMinX(), src2.getMinX());
        var y1 = Math.max(src1.getMinY(), src2.getMinY());
        var x2 = Math.min(src1.getMaxX(), src2.getMaxX());
        var y2 = Math.min(src1.getMaxY(), src2.getMaxY());
        dest.setFrame$double$double$double$double(x1, y1, x2 - x1, y2 - y1);
    };
    /**
     * Unions the pair of source <code>Rectangle2D</code> objects and puts the
     * result into the specified destination <code>Rectangle2D</code> object.
     * One of the source rectangles can also be the destination to avoid
     * creating a third Rectangle2D object, but in this case the original points
     * of this source rectangle will be overwritten by this method.
     *
     * @param {Rectangle2D} src1
     * the first of a pair of <code>Rectangle2D</code> objects to be
     * combined with each other
     * @param {Rectangle2D} src2
     * the second of a pair of <code>Rectangle2D</code> objects to be
     * combined with each other
     * @param {Rectangle2D} dest
     * the <code>Rectangle2D</code> that holds the results of the
     * union of <code>src1</code> and <code>src2</code>
     * @since 1.2
     */
    Rectangle2D.union = function (src1, src2, dest) {
        var x1 = Math.min(src1.getMinX(), src2.getMinX());
        var y1 = Math.min(src1.getMinY(), src2.getMinY());
        var x2 = Math.max(src1.getMaxX(), src2.getMaxX());
        var y2 = Math.max(src1.getMaxY(), src2.getMaxY());
        dest.setFrameFromDiagonal$double$double$double$double(x1, y1, x2, y2);
    };
    /**
     * Adds a point, specified by the double precision arguments
     * <code>newx</code> and <code>newy</code>, to this <code>Rectangle2D</code>
     * . The resulting <code>Rectangle2D</code> is the smallest
     * <code>Rectangle2D</code> that contains both the original
     * <code>Rectangle2D</code> and the specified point.
     * <p>
     * After adding a point, a call to <code>contains</code> with the added
     * point as an argument does not necessarily return <code>true</code>. The
     * <code>contains</code> method does not return <code>true</code> for points
     * on the right or bottom edges of a rectangle. Therefore, if the added
     * point falls on the left or bottom edge of the enlarged rectangle,
     * <code>contains</code> returns <code>false</code> for that point.
     *
     * @param {number} newx
     * the X coordinate of the new point
     * @param {number} newy
     * the Y coordinate of the new point
     * @since 1.2
     */
    Rectangle2D.prototype.add$double$double = function (newx, newy) {
        var x1 = Math.min(this.getMinX(), newx);
        var x2 = Math.max(this.getMaxX(), newx);
        var y1 = Math.min(this.getMinY(), newy);
        var y2 = Math.max(this.getMaxY(), newy);
        this.setRect$double$double$double$double(x1, y1, x2 - x1, y2 - y1);
    };
    /**
     * Adds a point, specified by the double precision arguments
     * <code>newx</code> and <code>newy</code>, to this <code>Rectangle2D</code>
     * . The resulting <code>Rectangle2D</code> is the smallest
     * <code>Rectangle2D</code> that contains both the original
     * <code>Rectangle2D</code> and the specified point.
     * <p>
     * After adding a point, a call to <code>contains</code> with the added
     * point as an argument does not necessarily return <code>true</code>. The
     * <code>contains</code> method does not return <code>true</code> for points
     * on the right or bottom edges of a rectangle. Therefore, if the added
     * point falls on the left or bottom edge of the enlarged rectangle,
     * <code>contains</code> returns <code>false</code> for that point.
     *
     * @param {number} newx
     * the X coordinate of the new point
     * @param {number} newy
     * the Y coordinate of the new point
     * @since 1.2
     */
    Rectangle2D.prototype.add = function (newx, newy) {
        if (((typeof newx === 'number') || newx === null) && ((typeof newy === 'number') || newy === null)) {
            return this.add$double$double(newx, newy);
        }
        else if (((newx != null && newx instanceof Point2D) || newx === null) && newy === undefined) {
            return this.add$java_awt_geom_Point2D(newx);
        }
        else if (((newx != null && newx instanceof Rectangle2D) || newx === null) && newy === undefined) {
            return this.add$java_awt_geom_Rectangle2D(newx);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Adds the <code>Point2D</code> object <code>pt</code> to this
     * <code>Rectangle2D</code>. The resulting <code>Rectangle2D</code> is the
     * smallest <code>Rectangle2D</code> that contains both the original
     * <code>Rectangle2D</code> and the specified <code>Point2D</code>.
     * <p>
     * After adding a point, a call to <code>contains</code> with the added
     * point as an argument does not necessarily return <code>true</code>. The
     * <code>contains</code> method does not return <code>true</code> for points
     * on the right or bottom edges of a rectangle. Therefore, if the added
     * point falls on the left or bottom edge of the enlarged rectangle,
     * <code>contains</code> returns <code>false</code> for that point.
     *
     * @param {Point2D} pt
     * the new <code>Point2D</code> to add to this
     * <code>Rectangle2D</code>.
     * @since 1.2
     */
    Rectangle2D.prototype.add$java_awt_geom_Point2D = function (pt) {
        this.add$double$double(pt.getX(), pt.getY());
    };
    /**
     * Adds a <code>Rectangle2D</code> object to this <code>Rectangle2D</code>.
     * The resulting <code>Rectangle2D</code> is the union of the two
     * <code>Rectangle2D</code> objects.
     *
     * @param {Rectangle2D} r
     * the <code>Rectangle2D</code> to add to this
     * <code>Rectangle2D</code>.
     * @since 1.2
     */
    Rectangle2D.prototype.add$java_awt_geom_Rectangle2D = function (r) {
        var x1 = Math.min(this.getMinX(), r.getMinX());
        var x2 = Math.max(this.getMaxX(), r.getMaxX());
        var y1 = Math.min(this.getMinY(), r.getMinY());
        var y2 = Math.max(this.getMaxY(), r.getMaxY());
        this.setRect$double$double$double$double(x1, y1, x2 - x1, y2 - y1);
    };
    /**
     * Returns an iteration object that defines the boundary of this
     * <code>Rectangle2D</code>. The iterator for this class is multi-threaded
     * safe, which means that this <code>Rectangle2D</code> class guarantees
     * that modifications to the geometry of this <code>Rectangle2D</code>
     * object do not affect any iterations of that geometry that are already in
     * process.
     *
     * @param {AffineTransform} at
     * an optional <code>AffineTransform</code> to be applied to the
     * coordinates as they are returned in the iteration, or
     * <code>null</code> if untransformed coordinates are desired
     * @return {PathIterator} the <code>PathIterator</code> object that returns the geometry of
     * the outline of this <code>Rectangle2D</code>, one segment at a
     * time.
     * @since 1.2
     */
    Rectangle2D.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
        return new RectIterator(this, at);
    };
    /**
     * Returns an iteration object that defines the boundary of the flattened
     * <code>Rectangle2D</code>. Since rectangles are already flat, the
     * <code>flatness</code> parameter is ignored. The iterator for this class
     * is multi-threaded safe, which means that this <code>Rectangle2D</code>
     * class guarantees that modifications to the geometry of this
     * <code>Rectangle2D</code> object do not affect any iterations of that
     * geometry that are already in process.
     *
     * @param {AffineTransform} at
     * an optional <code>AffineTransform</code> to be applied to the
     * coordinates as they are returned in the iteration, or
     * <code>null</code> if untransformed coordinates are desired
     * @param {number} flatness
     * the maximum distance that the line segments used to
     * approximate the curved segments are allowed to deviate from
     * any point on the original curve. Since rectangles are already
     * flat, the <code>flatness</code> parameter is ignored.
     * @return {PathIterator} the <code>PathIterator</code> object that returns the geometry of
     * the outline of this <code>Rectangle2D</code>, one segment at a
     * time.
     * @since 1.2
     */
    Rectangle2D.prototype.getPathIterator$java_awt_geom_AffineTransform$double = function (at, flatness) {
        return new RectIterator(this, at);
    };
    /**
     * Returns an iteration object that defines the boundary of the flattened
     * <code>Rectangle2D</code>. Since rectangles are already flat, the
     * <code>flatness</code> parameter is ignored. The iterator for this class
     * is multi-threaded safe, which means that this <code>Rectangle2D</code>
     * class guarantees that modifications to the geometry of this
     * <code>Rectangle2D</code> object do not affect any iterations of that
     * geometry that are already in process.
     *
     * @param {AffineTransform} at
     * an optional <code>AffineTransform</code> to be applied to the
     * coordinates as they are returned in the iteration, or
     * <code>null</code> if untransformed coordinates are desired
     * @param {number} flatness
     * the maximum distance that the line segments used to
     * approximate the curved segments are allowed to deviate from
     * any point on the original curve. Since rectangles are already
     * flat, the <code>flatness</code> parameter is ignored.
     * @return {PathIterator} the <code>PathIterator</code> object that returns the geometry of
     * the outline of this <code>Rectangle2D</code>, one segment at a
     * time.
     * @since 1.2
     */
    Rectangle2D.prototype.getPathIterator = function (at, flatness) {
        if (((at != null && at instanceof AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
            return this.getPathIterator$java_awt_geom_AffineTransform$double(at, flatness);
        }
        else if (((at != null && at instanceof AffineTransform) || at === null) && flatness === undefined) {
            return this.getPathIterator$java_awt_geom_AffineTransform(at);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Determines whether or not the specified <code>Object</code> is equal to
     * this <code>Rectangle2D</code>. The specified <code>Object</code> is equal
     * to this <code>Rectangle2D</code> if it is an instance of
     * <code>Rectangle2D</code> and if its location and size are the same as
     * this <code>Rectangle2D</code>.
     *
     * @param {*} obj
     * an <code>Object</code> to be compared with this
     * <code>Rectangle2D</code>.
     * @return {boolean} <code>true</code> if <code>obj</code> is an instance of
     * <code>Rectangle2D</code> and has the same values;
     * <code>false</code> otherwise.
     * @since 1.2
     */
    Rectangle2D.prototype.equals = function (obj) {
        if (obj === this) {
            return true;
        }
        if (obj != null && obj instanceof Rectangle2D) {
            var r2d = obj;
            return ((this.getX() === r2d.getX()) && (this.getY() === r2d.getY()) && (this.getWidth() === r2d.getWidth()) && (this.getHeight() === r2d.getHeight()));
        }
        return false;
    };
    return Rectangle2D;
}(RectangularShape));
/**
 * The bitmask that indicates that a point lies to the left of this
 * <code>Rectangle2D</code>.
 *
 * @since 1.2
 */
Rectangle2D.OUT_LEFT = 1;
/**
 * The bitmask that indicates that a point lies above this
 * <code>Rectangle2D</code>.
 *
 * @since 1.2
 */
Rectangle2D.OUT_TOP = 2;
/**
 * The bitmask that indicates that a point lies to the right of this
 * <code>Rectangle2D</code>.
 *
 * @since 1.2
 */
Rectangle2D.OUT_RIGHT = 4;
/**
 * The bitmask that indicates that a point lies below this
 * <code>Rectangle2D</code>.
 *
 * @since 1.2
 */
Rectangle2D.OUT_BOTTOM = 8;
Rectangle2D["__class"] = "Rectangle2D";
Rectangle2D["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable"];
(function (Rectangle2D) {
    /**
     * Constructs and initializes a <code>Rectangle2D</code> from the
     * specified <code>float</code> coordinates.
     *
     * @param {number} x
     * the X coordinate of the upper-left corner of the newly
     * constructed <code>Rectangle2D</code>
     * @param {number} y
     * the Y coordinate of the upper-left corner of the newly
     * constructed <code>Rectangle2D</code>
     * @param {number} w
     * the width of the newly constructed
     * <code>Rectangle2D</code>
     * @param {number} h
     * the height of the newly constructed
     * <code>Rectangle2D</code>
     * @since 1.2
     * @class
     */
    var Float = (function (_super) {
        __extends(Float, _super);
        function Float(x, y, w, h) {
            var _this = this;
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this) || this;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                (function () {
                    _this.setRect$float$float$float$float(x, y, w, h);
                })();
            }
            else if (x === undefined && y === undefined && w === undefined && h === undefined) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this) || this;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
            }
            else
                throw new Error('invalid overload');
            return _this;
        }
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getX = function () {
            return this.x;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getY = function () {
            return this.y;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getWidth = function () {
            return this.width;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getHeight = function () {
            return this.height;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {boolean}
         */
        Float.prototype.isEmpty = function () {
            return (this.width <= 0.0) || (this.height <= 0.0);
        };
        /**
         * Sets the location and size of this <code>Rectangle2D</code> to the
         * specified <code>float</code> values.
         *
         * @param {number} x
         * the X coordinate of the upper-left corner of this
         * <code>Rectangle2D</code>
         * @param {number} y
         * the Y coordinate of the upper-left corner of this
         * <code>Rectangle2D</code>
         * @param {number} w
         * the width of this <code>Rectangle2D</code>
         * @param {number} h
         * the height of this <code>Rectangle2D</code>
         * @since 1.2
         */
        Float.prototype.setRect$float$float$float$float = function (x, y, w, h) {
            this.x = x;
            this.y = y;
            this.width = w;
            this.height = h;
        };
        /**
         * Sets the location and size of this <code>Rectangle2D</code> to the
         * specified <code>float</code> values.
         *
         * @param {number} x
         * the X coordinate of the upper-left corner of this
         * <code>Rectangle2D</code>
         * @param {number} y
         * the Y coordinate of the upper-left corner of this
         * <code>Rectangle2D</code>
         * @param {number} w
         * the width of this <code>Rectangle2D</code>
         * @param {number} h
         * the height of this <code>Rectangle2D</code>
         * @since 1.2
         */
        Float.prototype.setRect = function (x, y, w, h) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                return this.setRect$float$float$float$float(x, y, w, h);
            }
            else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                return this.setRect$double$double$double$double(x, y, w, h);
            }
            else if (((x != null && x instanceof Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                return this.setRect$java_awt_geom_Rectangle2D(x);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @param {number} x
         * @param {number} y
         * @param {number} w
         * @param {number} h
         */
        Float.prototype.setRect$double$double$double$double = function (x, y, w, h) {
            this.x = x;
            this.y = y;
            this.width = w;
            this.height = h;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @param {Rectangle2D} r
         */
        Float.prototype.setRect$java_awt_geom_Rectangle2D = function (r) {
            this.x = r.getX();
            this.y = r.getY();
            this.width = r.getWidth();
            this.height = r.getHeight();
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @param {number} x
         * @param {number} y
         * @return {number}
         */
        Float.prototype.outcode$double$double = function (x, y) {
            var out = 0;
            if (this.width <= 0) {
                out |= Rectangle2D.OUT_LEFT | Rectangle2D.OUT_RIGHT;
            }
            else if (x < this.x) {
                out |= Rectangle2D.OUT_LEFT;
            }
            else if (x > this.x + this.width) {
                out |= Rectangle2D.OUT_RIGHT;
            }
            if (this.height <= 0) {
                out |= Rectangle2D.OUT_TOP | Rectangle2D.OUT_BOTTOM;
            }
            else if (y < this.y) {
                out |= Rectangle2D.OUT_TOP;
            }
            else if (y > this.y + this.height) {
                out |= Rectangle2D.OUT_BOTTOM;
            }
            return out;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @param {number} x
         * @param {number} y
         * @return {number}
         */
        Float.prototype.outcode = function (x, y) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.outcode$double$double(x, y);
            }
            else if (((x != null && x instanceof Point2D) || x === null) && y === undefined) {
                return this.outcode$java_awt_geom_Point2D(x);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {Rectangle2D}
         */
        Float.prototype.getBounds2D = function () {
            return new Rectangle2D.Float(this.x, this.y, this.width, this.height);
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @param {Rectangle2D} r
         * @return {Rectangle2D}
         */
        Float.prototype.createIntersection = function (r) {
            var dest;
            if (r != null && r instanceof Rectangle2D.Float) {
                dest = new Rectangle2D.Float();
            }
            else {
                dest = new Rectangle2D.Double();
            }
            Rectangle2D.intersect(this, r, dest);
            return dest;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @param {Rectangle2D} r
         * @return {Rectangle2D}
         */
        Float.prototype.createUnion = function (r) {
            var dest;
            if (r != null && r instanceof Rectangle2D.Float) {
                dest = new Rectangle2D.Float();
            }
            else {
                dest = new Rectangle2D.Double();
            }
            Rectangle2D.union(this, r, dest);
            return dest;
        };
        /**
         * Returns the <code>String</code> representation of this
         * <code>Rectangle2D</code>.
         *
         * @return {string} a <code>String</code> representing this
         * <code>Rectangle2D</code>.
         * @since 1.2
         */
        Float.prototype.toString = function () {
            return (function (c) { return c["__class"] ? c["__class"] : c["name"]; })(Rectangle2D.Float) + "[x=" + this.x + ",y=" + this.y + ",w=" + this.width + ",h=" + this.height + "]";
        };
        return Float;
    }(Rectangle2D));
    Float.serialVersionUID = 3798716824173675777;
    Rectangle2D.Float = Float;
    Float["__class"] = "Rectangle2D.Float";
    Float["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
    /**
     * Constructs and initializes a <code>Rectangle2D</code> from the
     * specified <code>double</code> coordinates.
     *
     * @param {number} x
     * the X coordinate of the upper-left corner of the newly
     * constructed <code>Rectangle2D</code>
     * @param {number} y
     * the Y coordinate of the upper-left corner of the newly
     * constructed <code>Rectangle2D</code>
     * @param {number} w
     * the width of the newly constructed
     * <code>Rectangle2D</code>
     * @param {number} h
     * the height of the newly constructed
     * <code>Rectangle2D</code>
     * @since 1.2
     * @class
     */
    var Double = (function (_super) {
        __extends(Double, _super);
        function Double(x, y, w, h) {
            var _this = this;
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this) || this;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                (function () {
                    _this.setRect$double$double$double$double(x, y, w, h);
                })();
            }
            else if (x === undefined && y === undefined && w === undefined && h === undefined) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this) || this;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
            }
            else
                throw new Error('invalid overload');
            return _this;
        }
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getX = function () {
            return this.x;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getY = function () {
            return this.y;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getWidth = function () {
            return this.width;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getHeight = function () {
            return this.height;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {boolean}
         */
        Double.prototype.isEmpty = function () {
            return (this.width <= 0.0) || (this.height <= 0.0);
        };
        /**
         * Sets the location and size of this <code>Rectangle2D</code> to the
         * specified <code>float</code> values.
         *
         * @param {number} x
         * the X coordinate of the upper-left corner of this
         * <code>Rectangle2D</code>
         * @param {number} y
         * the Y coordinate of the upper-left corner of this
         * <code>Rectangle2D</code>
         * @param {number} w
         * the width of this <code>Rectangle2D</code>
         * @param {number} h
         * the height of this <code>Rectangle2D</code>
         * @since 1.2
         */
        Double.prototype.setRect = function (x, y, w, h) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                return this.setRect$double$double$double$double(x, y, w, h);
            }
            else if (((x != null && x instanceof Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                return this.setRect$java_awt_geom_Rectangle2D(x);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @param {number} x
         * @param {number} y
         * @param {number} w
         * @param {number} h
         */
        Double.prototype.setRect$double$double$double$double = function (x, y, w, h) {
            this.x = x;
            this.y = y;
            this.width = w;
            this.height = h;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @param {Rectangle2D} r
         */
        Double.prototype.setRect$java_awt_geom_Rectangle2D = function (r) {
            this.x = r.getX();
            this.y = r.getY();
            this.width = r.getWidth();
            this.height = r.getHeight();
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @param {number} x
         * @param {number} y
         * @return {number}
         */
        Double.prototype.outcode$double$double = function (x, y) {
            var out = 0;
            if (this.width <= 0) {
                out |= Rectangle2D.OUT_LEFT | Rectangle2D.OUT_RIGHT;
            }
            else if (x < this.x) {
                out |= Rectangle2D.OUT_LEFT;
            }
            else if (x > this.x + this.width) {
                out |= Rectangle2D.OUT_RIGHT;
            }
            if (this.height <= 0) {
                out |= Rectangle2D.OUT_TOP | Rectangle2D.OUT_BOTTOM;
            }
            else if (y < this.y) {
                out |= Rectangle2D.OUT_TOP;
            }
            else if (y > this.y + this.height) {
                out |= Rectangle2D.OUT_BOTTOM;
            }
            return out;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @param {number} x
         * @param {number} y
         * @return {number}
         */
        Double.prototype.outcode = function (x, y) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                return this.outcode$double$double(x, y);
            }
            else if (((x != null && x instanceof Point2D) || x === null) && y === undefined) {
                return this.outcode$java_awt_geom_Point2D(x);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {Rectangle2D}
         */
        Double.prototype.getBounds2D = function () {
            return new Rectangle2D.Double(this.x, this.y, this.width, this.height);
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @param {Rectangle2D} r
         * @return {Rectangle2D}
         */
        Double.prototype.createIntersection = function (r) {
            var dest = new Rectangle2D.Double();
            Rectangle2D.intersect(this, r, dest);
            return dest;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @param {Rectangle2D} r
         * @return {Rectangle2D}
         */
        Double.prototype.createUnion = function (r) {
            var dest = new Rectangle2D.Double();
            Rectangle2D.union(this, r, dest);
            return dest;
        };
        /**
         * Returns the <code>String</code> representation of this
         * <code>Rectangle2D</code>.
         *
         * @return {string} a <code>String</code> representing this
         * <code>Rectangle2D</code>.
         * @since 1.2
         */
        Double.prototype.toString = function () {
            return (function (c) { return c["__class"] ? c["__class"] : c["name"]; })(Rectangle2D.Double) + "[x=" + this.x + ",y=" + this.y + ",w=" + this.width + ",h=" + this.height + "]";
        };
        return Double;
    }(Rectangle2D));
    Double.serialVersionUID = 7771313791441850493;
    Rectangle2D.Double = Double;
    Double["__class"] = "Rectangle2D.Double";
    Double["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
})(Rectangle2D || (Rectangle2D = {}));
/**
 * This is an abstract class that cannot be instantiated directly.
 * Type-specific implementation subclasses are available for instantiation
 * and provide a number of formats for storing the information necessary to
 * satisfy the various accessor methods below.
 *
 * @see java.awt.geom.RoundRectangle2D.Float
 * @see java.awt.geom.RoundRectangle2D.Double
 * @since 1.2
 * @class
 */
var RoundRectangle2D = (function (_super) {
    __extends(RoundRectangle2D, _super);
    function RoundRectangle2D() {
        return _super.call(this) || this;
    }
    /**
     * Sets the location, size, and corner radii of this
     * <code>RoundRectangle2D</code> to the specified <code>float</code>
     * values.
     *
     * @param {number} x
     * the X coordinate to which to set the location of this
     * <code>RoundRectangle2D</code>
     * @param {number} y
     * the Y coordinate to which to set the location of this
     * <code>RoundRectangle2D</code>
     * @param {number} w
     * the width to which to set this
     * <code>RoundRectangle2D</code>
     * @param {number} h
     * the height to which to set this
     * <code>RoundRectangle2D</code>
     * @param {number} arcw
     * the width to which to set the arc of this
     * <code>RoundRectangle2D</code>
     * @param {number} arch
     * the height to which to set the arc of this
     * <code>RoundRectangle2D</code>
     * @since 1.2
     */
    RoundRectangle2D.prototype.setRoundRect = function (x, y, w, h, arcw, arch) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof arcw === 'number') || arcw === null) && ((typeof arch === 'number') || arch === null)) {
            return this.setRoundRect$double$double$double$double$double$double(x, y, w, h, arcw, arch);
        }
        else if (((x != null && x instanceof RoundRectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && arcw === undefined && arch === undefined) {
            return this.setRoundRect$java_awt_geom_RoundRectangle2D(x);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Sets the location, size, and corner radii of this
     * <code>RoundRectangle2D</code> to the specified <code>double</code>
     * values.
     *
     * @param {number} x
     * the X coordinate to which to set the location of this
     * <code>RoundRectangle2D</code>
     * @param {number} y
     * the Y coordinate to which to set the location of this
     * <code>RoundRectangle2D</code>
     * @param {number} w
     * the width to which to set this <code>RoundRectangle2D</code>
     * @param {number} h
     * the height to which to set this <code>RoundRectangle2D</code>
     * @param {number} arcWidth
     * the width to which to set the arc of this
     * <code>RoundRectangle2D</code>
     * @param {number} arcHeight
     * the height to which to set the arc of this
     * <code>RoundRectangle2D</code>
     * @since 1.2
     */
    RoundRectangle2D.prototype.setRoundRect$double$double$double$double$double$double = function (x, y, w, h, arcWidth, arcHeight) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
    /**
     * Sets this <code>RoundRectangle2D</code> to be the same as the specified
     * <code>RoundRectangle2D</code>.
     *
     * @param {RoundRectangle2D} rr
     * the specified <code>RoundRectangle2D</code>
     * @since 1.2
     */
    RoundRectangle2D.prototype.setRoundRect$java_awt_geom_RoundRectangle2D = function (rr) {
        this.setRoundRect$double$double$double$double$double$double(rr.getX(), rr.getY(), rr.getWidth(), rr.getHeight(), rr.getArcWidth(), rr.getArcHeight());
    };
    RoundRectangle2D.prototype.setFrame = function (x, y, w, h) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
            return this.setFrame$double$double$double$double(x, y, w, h);
        }
        else if (((x != null && x instanceof Point2D) || x === null) && ((y != null && y instanceof Dimension2D) || y === null) && w === undefined && h === undefined) {
            return this.setFrame$java_awt_geom_Point2D$java_awt_geom_Dimension2D(x, y);
        }
        else if (((x != null && x instanceof Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
            return this.setFrame$java_awt_geom_Rectangle2D(x);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     */
    RoundRectangle2D.prototype.setFrame$double$double$double$double = function (x, y, w, h) {
        this.setRoundRect$double$double$double$double$double$double(x, y, w, h, this.getArcWidth(), this.getArcHeight());
    };
    RoundRectangle2D.prototype.contains = function (x, y, w, h, origrect) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && origrect === undefined) {
            return this.contains$double$double$double$double(x, y, w, h);
        }
        else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined && origrect === undefined) {
            return this.contains$double$double(x, y);
        }
        else if (((x != null && x instanceof Point2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
            return this.contains$java_awt_geom_Point2D(x);
        }
        else if (((x != null && x instanceof Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
            return this.contains$java_awt_geom_Rectangle2D(x);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @return {boolean}
     */
    RoundRectangle2D.prototype.contains$double$double = function (x, y) {
        if (this.isEmpty()) {
            return false;
        }
        var rrx0 = this.getX();
        var rry0 = this.getY();
        var rrx1 = rrx0 + this.getWidth();
        var rry1 = rry0 + this.getHeight();
        if (x < rrx0 || y < rry0 || x >= rrx1 || y >= rry1) {
            return false;
        }
        var aw = Math.min(this.getWidth(), Math.abs(this.getArcWidth())) / 2.0;
        var ah = Math.min(this.getHeight(), Math.abs(this.getArcHeight())) / 2.0;
        if (x >= (rrx0 += aw) && x < (rrx0 = rrx1 - aw)) {
            return true;
        }
        if (y >= (rry0 += ah) && y < (rry0 = rry1 - ah)) {
            return true;
        }
        x = (x - rrx0) / aw;
        y = (y - rry0) / ah;
        return (x * x + y * y <= 1.0);
    };
    RoundRectangle2D.prototype.classify = function (coord, left, right, arcsize) {
        if (coord < left) {
            return 0;
        }
        else if (coord < left + arcsize) {
            return 1;
        }
        else if (coord < right - arcsize) {
            return 2;
        }
        else if (coord < right) {
            return 3;
        }
        else {
            return 4;
        }
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @return {boolean}
     */
    RoundRectangle2D.prototype.intersects$double$double$double$double = function (x, y, w, h) {
        if (this.isEmpty() || w <= 0 || h <= 0) {
            return false;
        }
        var rrx0 = this.getX();
        var rry0 = this.getY();
        var rrx1 = rrx0 + this.getWidth();
        var rry1 = rry0 + this.getHeight();
        if (x + w <= rrx0 || x >= rrx1 || y + h <= rry0 || y >= rry1) {
            return false;
        }
        var aw = Math.min(this.getWidth(), Math.abs(this.getArcWidth())) / 2.0;
        var ah = Math.min(this.getHeight(), Math.abs(this.getArcHeight())) / 2.0;
        var x0class = this.classify(x, rrx0, rrx1, aw);
        var x1class = this.classify(x + w, rrx0, rrx1, aw);
        var y0class = this.classify(y, rry0, rry1, ah);
        var y1class = this.classify(y + h, rry0, rry1, ah);
        if (x0class === 2 || x1class === 2 || y0class === 2 || y1class === 2) {
            return true;
        }
        if ((x0class < 2 && x1class > 2) || (y0class < 2 && y1class > 2)) {
            return true;
        }
        x = (x1class === 1) ? (x = x + w - (rrx0 + aw)) : (x = x - (rrx1 - aw));
        y = (y1class === 1) ? (y = y + h - (rry0 + ah)) : (y = y - (rry1 - ah));
        x = x / aw;
        y = y / ah;
        return (x * x + y * y <= 1.0);
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @return {boolean}
     */
    RoundRectangle2D.prototype.intersects = function (x, y, w, h) {
        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
            return this.intersects$double$double$double$double(x, y, w, h);
        }
        else if (((x != null && x instanceof Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
            return this.intersects$java_awt_geom_Rectangle2D(x);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * {@inheritDoc}
     *
     * @since 1.2
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @return {boolean}
     */
    RoundRectangle2D.prototype.contains$double$double$double$double = function (x, y, w, h) {
        if (this.isEmpty() || w <= 0 || h <= 0) {
            return false;
        }
        return (this.contains$double$double(x, y) && this.contains$double$double(x + w, y) && this.contains$double$double(x, y + h) && this.contains$double$double(x + w, y + h));
    };
    RoundRectangle2D.prototype.getPathIterator = function (at, flatness) {
        if (((at != null && at instanceof AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
            _super.prototype.getPathIterator.call(this, at, flatness);
        }
        else if (((at != null && at instanceof AffineTransform) || at === null) && flatness === undefined) {
            return this.getPathIterator$java_awt_geom_AffineTransform(at);
        }
        else
            throw new Error('invalid overload');
    };
    /**
     * Returns an iteration object that defines the boundary of this
     * <code>RoundRectangle2D</code>. The iterator for this class is
     * multi-threaded safe, which means that this <code>RoundRectangle2D</code>
     * class guarantees that modifications to the geometry of this
     * <code>RoundRectangle2D</code> object do not affect any iterations of that
     * geometry that are already in process.
     *
     * @param {AffineTransform} at
     * an optional <code>AffineTransform</code> to be applied to the
     * coordinates as they are returned in the iteration, or
     * <code>null</code> if untransformed coordinates are desired
     * @return {PathIterator} the <code>PathIterator</code> object that returns the geometry of
     * the outline of this <code>RoundRectangle2D</code>, one segment at
     * a time.
     * @since 1.2
     */
    RoundRectangle2D.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
        return new RoundRectIterator(this, at);
    };
    /**
     * Determines whether or not the specified <code>Object</code> is equal to
     * this <code>RoundRectangle2D</code>. The specified <code>Object</code> is
     * equal to this <code>RoundRectangle2D</code> if it is an instance of
     * <code>RoundRectangle2D</code> and if its location, size, and corner arc
     * dimensions are the same as this <code>RoundRectangle2D</code>.
     *
     * @param {*} obj
     * an <code>Object</code> to be compared with this
     * <code>RoundRectangle2D</code>.
     * @return {boolean} <code>true</code> if <code>obj</code> is an instance of
     * <code>RoundRectangle2D</code> and has the same values;
     * <code>false</code> otherwise.
     * @since 1.6
     */
    RoundRectangle2D.prototype.equals = function (obj) {
        if (obj === this) {
            return true;
        }
        if (obj != null && obj instanceof RoundRectangle2D) {
            var rr2d = obj;
            return ((this.getX() === rr2d.getX()) && (this.getY() === rr2d.getY()) && (this.getWidth() === rr2d.getWidth()) && (this.getHeight() === rr2d.getHeight()) && (this.getArcWidth() === rr2d.getArcWidth()) && (this.getArcHeight() === rr2d.getArcHeight()));
        }
        return false;
    };
    return RoundRectangle2D;
}(RectangularShape));
RoundRectangle2D["__class"] = "RoundRectangle2D";
RoundRectangle2D["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable"];
(function (RoundRectangle2D) {
    /**
     * Constructs and initializes a <code>RoundRectangle2D</code> from the
     * specified <code>float</code> coordinates.
     *
     * @param {number} x
     * the X coordinate of the newly constructed
     * <code>RoundRectangle2D</code>
     * @param {number} y
     * the Y coordinate of the newly constructed
     * <code>RoundRectangle2D</code>
     * @param {number} w
     * the width to which to set the newly constructed
     * <code>RoundRectangle2D</code>
     * @param {number} h
     * the height to which to set the newly constructed
     * <code>RoundRectangle2D</code>
     * @param {number} arcw
     * the width of the arc to use to round off the corners of
     * the newly constructed <code>RoundRectangle2D</code>
     * @param {number} arch
     * the height of the arc to use to round off the corners of
     * the newly constructed <code>RoundRectangle2D</code>
     * @since 1.2
     * @class
     */
    var Float = (function (_super) {
        __extends(Float, _super);
        function Float(x, y, w, h, arcw, arch) {
            var _this = this;
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof arcw === 'number') || arcw === null) && ((typeof arch === 'number') || arch === null)) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this) || this;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.arcwidth = 0;
                _this.archeight = 0;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.arcwidth = 0;
                _this.archeight = 0;
                (function () {
                    _this.setRoundRect$float$float$float$float$float$float(x, y, w, h, arcw, arch);
                })();
            }
            else if (x === undefined && y === undefined && w === undefined && h === undefined && arcw === undefined && arch === undefined) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this) || this;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.arcwidth = 0;
                _this.archeight = 0;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.arcwidth = 0;
                _this.archeight = 0;
            }
            else
                throw new Error('invalid overload');
            return _this;
        }
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getX = function () {
            return this.x;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getY = function () {
            return this.y;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getWidth = function () {
            return this.width;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getHeight = function () {
            return this.height;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getArcWidth = function () {
            return this.arcwidth;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Float.prototype.getArcHeight = function () {
            return this.archeight;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {boolean}
         */
        Float.prototype.isEmpty = function () {
            return (this.width <= 0.0) || (this.height <= 0.0);
        };
        /**
         * Sets the location, size, and corner radii of this
         * <code>RoundRectangle2D</code> to the specified <code>float</code>
         * values.
         *
         * @param {number} x
         * the X coordinate to which to set the location of this
         * <code>RoundRectangle2D</code>
         * @param {number} y
         * the Y coordinate to which to set the location of this
         * <code>RoundRectangle2D</code>
         * @param {number} w
         * the width to which to set this
         * <code>RoundRectangle2D</code>
         * @param {number} h
         * the height to which to set this
         * <code>RoundRectangle2D</code>
         * @param {number} arcw
         * the width to which to set the arc of this
         * <code>RoundRectangle2D</code>
         * @param {number} arch
         * the height to which to set the arc of this
         * <code>RoundRectangle2D</code>
         * @since 1.2
         */
        Float.prototype.setRoundRect$float$float$float$float$float$float = function (x, y, w, h, arcw, arch) {
            this.x = x;
            this.y = y;
            this.width = w;
            this.height = h;
            this.arcwidth = arcw;
            this.archeight = arch;
        };
        /**
         * Sets the location, size, and corner radii of this
         * <code>RoundRectangle2D</code> to the specified <code>float</code>
         * values.
         *
         * @param {number} x
         * the X coordinate to which to set the location of this
         * <code>RoundRectangle2D</code>
         * @param {number} y
         * the Y coordinate to which to set the location of this
         * <code>RoundRectangle2D</code>
         * @param {number} w
         * the width to which to set this
         * <code>RoundRectangle2D</code>
         * @param {number} h
         * the height to which to set this
         * <code>RoundRectangle2D</code>
         * @param {number} arcw
         * the width to which to set the arc of this
         * <code>RoundRectangle2D</code>
         * @param {number} arch
         * the height to which to set the arc of this
         * <code>RoundRectangle2D</code>
         * @since 1.2
         */
        Float.prototype.setRoundRect = function (x, y, w, h, arcw, arch) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof arcw === 'number') || arcw === null) && ((typeof arch === 'number') || arch === null)) {
                return this.setRoundRect$float$float$float$float$float$float(x, y, w, h, arcw, arch);
            }
            else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof arcw === 'number') || arcw === null) && ((typeof arch === 'number') || arch === null)) {
                return this.setRoundRect$double$double$double$double$double$double(x, y, w, h, arcw, arch);
            }
            else if (((x != null && x instanceof RoundRectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && arcw === undefined && arch === undefined) {
                return this.setRoundRect$java_awt_geom_RoundRectangle2D(x);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @param {number} x
         * @param {number} y
         * @param {number} w
         * @param {number} h
         * @param {number} arcw
         * @param {number} arch
         */
        Float.prototype.setRoundRect$double$double$double$double$double$double = function (x, y, w, h, arcw, arch) {
            this.x = x;
            this.y = y;
            this.width = w;
            this.height = h;
            this.arcwidth = arcw;
            this.archeight = arch;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @param {RoundRectangle2D} rr
         */
        Float.prototype.setRoundRect$java_awt_geom_RoundRectangle2D = function (rr) {
            this.x = rr.getX();
            this.y = rr.getY();
            this.width = rr.getWidth();
            this.height = rr.getHeight();
            this.arcwidth = rr.getArcWidth();
            this.archeight = rr.getArcHeight();
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {Rectangle2D}
         */
        Float.prototype.getBounds2D = function () {
            return new Rectangle2D.Float(this.x, this.y, this.width, this.height);
        };
        return Float;
    }(RoundRectangle2D));
    Float.serialVersionUID = -3423150618393866922;
    RoundRectangle2D.Float = Float;
    Float["__class"] = "RoundRectangle2D.Float";
    Float["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
    /**
     * Constructs and initializes a <code>RoundRectangle2D</code> from the
     * specified <code>double</code> coordinates.
     *
     * @param {number} x
     * the X coordinate of the newly constructed
     * <code>RoundRectangle2D</code>
     * @param {number} y
     * the Y coordinate of the newly constructed
     * <code>RoundRectangle2D</code>
     * @param {number} w
     * the width to which to set the newly constructed
     * <code>RoundRectangle2D</code>
     * @param {number} h
     * the height to which to set the newly constructed
     * <code>RoundRectangle2D</code>
     * @param {number} arcw
     * the width of the arc to use to round off the corners of
     * the newly constructed <code>RoundRectangle2D</code>
     * @param {number} arch
     * the height of the arc to use to round off the corners of
     * the newly constructed <code>RoundRectangle2D</code>
     * @since 1.2
     * @class
     */
    var Double = (function (_super) {
        __extends(Double, _super);
        function Double(x, y, w, h, arcw, arch) {
            var _this = this;
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof arcw === 'number') || arcw === null) && ((typeof arch === 'number') || arch === null)) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this) || this;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.arcwidth = 0;
                _this.archeight = 0;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.arcwidth = 0;
                _this.archeight = 0;
                (function () {
                    _this.setRoundRect$double$double$double$double$double$double(x, y, w, h, arcw, arch);
                })();
            }
            else if (x === undefined && y === undefined && w === undefined && h === undefined && arcw === undefined && arch === undefined) {
                var __args = Array.prototype.slice.call(arguments);
                _this = _super.call(this) || this;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.arcwidth = 0;
                _this.archeight = 0;
                _this.x = 0;
                _this.y = 0;
                _this.width = 0;
                _this.height = 0;
                _this.arcwidth = 0;
                _this.archeight = 0;
            }
            else
                throw new Error('invalid overload');
            return _this;
        }
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getX = function () {
            return this.x;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getY = function () {
            return this.y;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getWidth = function () {
            return this.width;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getHeight = function () {
            return this.height;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getArcWidth = function () {
            return this.arcwidth;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {number}
         */
        Double.prototype.getArcHeight = function () {
            return this.archeight;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {boolean}
         */
        Double.prototype.isEmpty = function () {
            return (this.width <= 0.0) || (this.height <= 0.0);
        };
        /**
         * Sets the location, size, and corner radii of this
         * <code>RoundRectangle2D</code> to the specified <code>float</code>
         * values.
         *
         * @param {number} x
         * the X coordinate to which to set the location of this
         * <code>RoundRectangle2D</code>
         * @param {number} y
         * the Y coordinate to which to set the location of this
         * <code>RoundRectangle2D</code>
         * @param {number} w
         * the width to which to set this
         * <code>RoundRectangle2D</code>
         * @param {number} h
         * the height to which to set this
         * <code>RoundRectangle2D</code>
         * @param {number} arcw
         * the width to which to set the arc of this
         * <code>RoundRectangle2D</code>
         * @param {number} arch
         * the height to which to set the arc of this
         * <code>RoundRectangle2D</code>
         * @since 1.2
         */
        Double.prototype.setRoundRect = function (x, y, w, h, arcw, arch) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof arcw === 'number') || arcw === null) && ((typeof arch === 'number') || arch === null)) {
                return this.setRoundRect$double$double$double$double$double$double(x, y, w, h, arcw, arch);
            }
            else if (((x != null && x instanceof RoundRectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && arcw === undefined && arch === undefined) {
                return this.setRoundRect$java_awt_geom_RoundRectangle2D(x);
            }
            else
                throw new Error('invalid overload');
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @param {number} x
         * @param {number} y
         * @param {number} w
         * @param {number} h
         * @param {number} arcw
         * @param {number} arch
         */
        Double.prototype.setRoundRect$double$double$double$double$double$double = function (x, y, w, h, arcw, arch) {
            this.x = x;
            this.y = y;
            this.width = w;
            this.height = h;
            this.arcwidth = arcw;
            this.archeight = arch;
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @param {RoundRectangle2D} rr
         */
        Double.prototype.setRoundRect$java_awt_geom_RoundRectangle2D = function (rr) {
            this.x = rr.getX();
            this.y = rr.getY();
            this.width = rr.getWidth();
            this.height = rr.getHeight();
            this.arcwidth = rr.getArcWidth();
            this.archeight = rr.getArcHeight();
        };
        /**
         * {@inheritDoc}
         *
         * @since 1.2
         * @return {Rectangle2D}
         */
        Double.prototype.getBounds2D = function () {
            return new Rectangle2D.Double(this.x, this.y, this.width, this.height);
        };
        return Double;
    }(RoundRectangle2D));
    Double.serialVersionUID = 1048939333485206117;
    RoundRectangle2D.Double = Double;
    Double["__class"] = "RoundRectangle2D.Double";
    Double["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
})(RoundRectangle2D || (RoundRectangle2D = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Wraps a primitive <code>double</code> as an object.
         * @extends javaemul.internal.NumberHelper
         */
        var DoubleHelper = (function (_super) {
            __extends(DoubleHelper, _super);
            function DoubleHelper() {
                return _super.call(this) || this;
            }
            DoubleHelper.NaN_$LI$ = function () { if (DoubleHelper.NaN == null)
                DoubleHelper.NaN = 0.0 / 0.0; return DoubleHelper.NaN; };
            ;
            DoubleHelper.NEGATIVE_INFINITY_$LI$ = function () { if (DoubleHelper.NEGATIVE_INFINITY == null)
                DoubleHelper.NEGATIVE_INFINITY = -1.0 / 0.0; return DoubleHelper.NEGATIVE_INFINITY; };
            ;
            DoubleHelper.POSITIVE_INFINITY_$LI$ = function () { if (DoubleHelper.POSITIVE_INFINITY == null)
                DoubleHelper.POSITIVE_INFINITY = 1.0 / 0.0; return DoubleHelper.POSITIVE_INFINITY; };
            ;
            DoubleHelper.compare = function (x, y) {
                if (x < y) {
                    return -1;
                }
                if (x > y) {
                    return 1;
                }
                if (x === y) {
                    return 0;
                }
                if (DoubleHelper.isNaN(x)) {
                    if (DoubleHelper.isNaN(y)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                else {
                    return -1;
                }
            };
            DoubleHelper.doubleToLongBits = function (value) {
                if (DoubleHelper.isNaN(value)) {
                    return 9221120237041090560;
                }
                var negative = false;
                if (value === 0.0) {
                    if (1.0 / value === DoubleHelper.NEGATIVE_INFINITY_$LI$()) {
                        return -9223372036854775808;
                    }
                    else {
                        return 0;
                    }
                }
                if (value < 0.0) {
                    negative = true;
                    value = -value;
                }
                if (DoubleHelper.isInfinite(value)) {
                    if (negative) {
                        return -4503599627370496;
                    }
                    else {
                        return 9218868437227405312;
                    }
                }
                var exp = 0;
                if (value < 1.0) {
                    var bit = 512;
                    for (var i = 0; i < 10; i++, bit >>= 1) {
                        if (value < DoubleHelper.PowersTable.invPowers_$LI$()[i] && exp - bit >= -1023) {
                            value *= DoubleHelper.PowersTable.powers_$LI$()[i];
                            exp -= bit;
                        }
                    }
                    if (value < 1.0 && exp - 1 >= -1023) {
                        value *= 2.0;
                        exp--;
                    }
                }
                else if (value >= 2.0) {
                    var bit = 512;
                    for (var i = 0; i < 10; i++, bit >>= 1) {
                        if (value >= DoubleHelper.PowersTable.powers_$LI$()[i]) {
                            value *= DoubleHelper.PowersTable.invPowers_$LI$()[i];
                            exp += bit;
                        }
                    }
                }
                if (exp > -1023) {
                    value -= 1.0;
                }
                else {
                    value *= 0.5;
                }
                var ihi = Math.floor((value * DoubleHelper.POWER_20));
                value -= ihi * DoubleHelper.POWER_MINUS_20;
                var ilo = Math.floor((value * DoubleHelper.POWER_52));
                ihi |= (exp + 1023) << 20;
                if (negative) {
                    ihi |= 2147483648;
                }
                return (ihi << 32) | ilo;
            };
            /**
             * @skip Here for shared implementation with Arrays.hashCode
             * @param {number} d
             * @return {number}
             */
            DoubleHelper.hashCode = function (d) {
                return (d | 0);
            };
            DoubleHelper.isInfinite = function (x) {
                return x === Infinity || x === -Infinity;
            };
            DoubleHelper.isNaN = function (x) {
                return isNaN(x);
            };
            DoubleHelper.longBitsToDouble = function (bits) {
                var ihi = Math.floor((bits >> 32));
                var ilo = Math.floor((bits & 4294967295));
                if (ihi < 0) {
                    ihi += 4294967296;
                }
                if (ilo < 0) {
                    ilo += 4294967296;
                }
                var negative = (ihi & -2147483648) !== 0;
                var exp = (((ihi >> 20) & 2047) | 0);
                ihi &= 1048575;
                if (exp === 0) {
                    var d_1 = (ihi * DoubleHelper.POWER_MINUS_20) + (ilo * DoubleHelper.POWER_MINUS_52);
                    d_1 *= DoubleHelper.POWER_MINUS_1022;
                    return negative ? (d_1 === 0.0 ? -0.0 : -d_1) : d_1;
                }
                else if (exp === 2047) {
                    if (ihi === 0 && ilo === 0) {
                        return negative ? DoubleHelper.NEGATIVE_INFINITY_$LI$() : DoubleHelper.POSITIVE_INFINITY_$LI$();
                    }
                    else {
                        return DoubleHelper.NaN_$LI$();
                    }
                }
                exp -= 1023;
                var d = 1.0 + (ihi * DoubleHelper.POWER_MINUS_20) + (ilo * DoubleHelper.POWER_MINUS_52);
                if (exp > 0) {
                    var bit = 512;
                    for (var i = 0; i < 10; i++, bit >>= 1) {
                        if (exp >= bit) {
                            d *= DoubleHelper.PowersTable.powers_$LI$()[i];
                            exp -= bit;
                        }
                    }
                }
                else if (exp < 0) {
                    while ((exp < 0)) {
                        var bit = 512;
                        for (var i = 0; i < 10; i++, bit >>= 1) {
                            if (exp <= -bit) {
                                d *= DoubleHelper.PowersTable.invPowers_$LI$()[i];
                                exp += bit;
                            }
                        }
                    }
                    ;
                }
                return negative ? -d : d;
            };
            DoubleHelper.parseDouble = function (s) {
                return internal.NumberHelper.__parseAndValidateDouble(s);
            };
            DoubleHelper.toString = function (b) {
                return new String(b).toString();
            };
            return DoubleHelper;
        }(javaemul.internal.NumberHelper));
        DoubleHelper.MAX_VALUE = 1.7976931348623157E308;
        DoubleHelper.MIN_VALUE = 4.9E-324;
        DoubleHelper.MIN_NORMAL = 2.2250738585072014E-308;
        DoubleHelper.MAX_EXPONENT = 1023;
        DoubleHelper.MIN_EXPONENT = -1022;
        DoubleHelper.SIZE = 64;
        DoubleHelper.POWER_512 = 1.3407807929942597E154;
        DoubleHelper.POWER_MINUS_512 = 7.458340731200207E-155;
        DoubleHelper.POWER_256 = 1.157920892373162E77;
        DoubleHelper.POWER_MINUS_256 = 8.636168555094445E-78;
        DoubleHelper.POWER_128 = 3.4028236692093846E38;
        DoubleHelper.POWER_MINUS_128 = 2.9387358770557188E-39;
        DoubleHelper.POWER_64 = 1.8446744073709552E19;
        DoubleHelper.POWER_MINUS_64 = 5.421010862427522E-20;
        DoubleHelper.POWER_52 = 4.503599627370496E15;
        DoubleHelper.POWER_MINUS_52 = 2.220446049250313E-16;
        DoubleHelper.POWER_32 = 4.294967296E9;
        DoubleHelper.POWER_MINUS_32 = 2.3283064365386963E-10;
        DoubleHelper.POWER_31 = 2.147483648E9;
        DoubleHelper.POWER_20 = 1048576.0;
        DoubleHelper.POWER_MINUS_20 = 9.5367431640625E-7;
        DoubleHelper.POWER_16 = 65536.0;
        DoubleHelper.POWER_MINUS_16 = 1.52587890625E-5;
        DoubleHelper.POWER_8 = 256.0;
        DoubleHelper.POWER_MINUS_8 = 0.00390625;
        DoubleHelper.POWER_4 = 16.0;
        DoubleHelper.POWER_MINUS_4 = 0.0625;
        DoubleHelper.POWER_2 = 4.0;
        DoubleHelper.POWER_MINUS_2 = 0.25;
        DoubleHelper.POWER_1 = 2.0;
        DoubleHelper.POWER_MINUS_1 = 0.5;
        DoubleHelper.POWER_MINUS_1022 = 2.2250738585072014E-308;
        internal.DoubleHelper = DoubleHelper;
        DoubleHelper["__class"] = "javaemul.internal.DoubleHelper";
        DoubleHelper["__interfaces"] = ["java.io.Serializable"];
        (function (DoubleHelper) {
            var PowersTable = (function () {
                function PowersTable() {
                }
                PowersTable.powers_$LI$ = function () { if (PowersTable.powers == null)
                    PowersTable.powers = [javaemul.internal.DoubleHelper.POWER_512, javaemul.internal.DoubleHelper.POWER_256, javaemul.internal.DoubleHelper.POWER_128, javaemul.internal.DoubleHelper.POWER_64, javaemul.internal.DoubleHelper.POWER_32, javaemul.internal.DoubleHelper.POWER_16, javaemul.internal.DoubleHelper.POWER_8, javaemul.internal.DoubleHelper.POWER_4, javaemul.internal.DoubleHelper.POWER_2, javaemul.internal.DoubleHelper.POWER_1]; return PowersTable.powers; };
                ;
                PowersTable.invPowers_$LI$ = function () { if (PowersTable.invPowers == null)
                    PowersTable.invPowers = [javaemul.internal.DoubleHelper.POWER_MINUS_512, javaemul.internal.DoubleHelper.POWER_MINUS_256, javaemul.internal.DoubleHelper.POWER_MINUS_128, javaemul.internal.DoubleHelper.POWER_MINUS_64, javaemul.internal.DoubleHelper.POWER_MINUS_32, javaemul.internal.DoubleHelper.POWER_MINUS_16, javaemul.internal.DoubleHelper.POWER_MINUS_8, javaemul.internal.DoubleHelper.POWER_MINUS_4, javaemul.internal.DoubleHelper.POWER_MINUS_2, javaemul.internal.DoubleHelper.POWER_MINUS_1]; return PowersTable.invPowers; };
                ;
                return PowersTable;
            }());
            DoubleHelper.PowersTable = PowersTable;
            PowersTable["__class"] = "javaemul.internal.DoubleHelper.PowersTable";
        })(DoubleHelper = internal.DoubleHelper || (internal.DoubleHelper = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var Order0 = (function (_super) {
                __extends(Order0, _super);
                function Order0(x, y) {
                    var _this = _super.call(this, sun.awt.geom.Curve.INCREASING) || this;
                    _this.x = 0;
                    _this.y = 0;
                    _this.x = x;
                    _this.y = y;
                    return _this;
                }
                Order0.prototype.getOrder = function () {
                    return 0;
                };
                Order0.prototype.getXTop = function () {
                    return this.x;
                };
                Order0.prototype.getYTop = function () {
                    return this.y;
                };
                Order0.prototype.getXBot = function () {
                    return this.x;
                };
                Order0.prototype.getYBot = function () {
                    return this.y;
                };
                Order0.prototype.getXMin = function () {
                    return this.x;
                };
                Order0.prototype.getXMax = function () {
                    return this.x;
                };
                Order0.prototype.getX0 = function () {
                    return this.x;
                };
                Order0.prototype.getY0 = function () {
                    return this.y;
                };
                Order0.prototype.getX1 = function () {
                    return this.x;
                };
                Order0.prototype.getY1 = function () {
                    return this.y;
                };
                Order0.prototype.XforY = function (y) {
                    return y;
                };
                Order0.prototype.TforY = function (y) {
                    return 0;
                };
                Order0.prototype.XforT = function (t) {
                    return this.x;
                };
                Order0.prototype.YforT = function (t) {
                    return this.y;
                };
                Order0.prototype.dXforT = function (t, deriv) {
                    return 0;
                };
                Order0.prototype.dYforT = function (t, deriv) {
                    return 0;
                };
                Order0.prototype.nextVertical = function (t0, t1) {
                    return t1;
                };
                Order0.prototype.crossingsFor = function (x, y) {
                    return 0;
                };
                Order0.prototype.accumulateCrossings = function (c) {
                    return (this.x > c.getXLo() && this.x < c.getXHi() && this.y > c.getYLo() && this.y < c.getYHi());
                };
                Order0.prototype.enlarge = function (r) {
                    r.add$double$double(this.x, this.y);
                };
                Order0.prototype.getSubCurve$double$double$int = function (ystart, yend, dir) {
                    return this;
                };
                Order0.prototype.getSubCurve = function (ystart, yend, dir) {
                    if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && ((typeof dir === 'number') || dir === null)) {
                        return this.getSubCurve$double$double$int(ystart, yend, dir);
                    }
                    else if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && dir === undefined) {
                        return this.getSubCurve$double$double(ystart, yend);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Order0.prototype.getReversedCurve = function () {
                    return this;
                };
                Order0.prototype.getSegment = function (coords) {
                    coords[0] = this.x;
                    coords[1] = this.y;
                    return PathIterator.SEG_MOVETO;
                };
                return Order0;
            }(sun.awt.geom.Curve));
            geom.Order0 = Order0;
            Order0["__class"] = "sun.awt.geom.Order0";
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var Order1 = (function (_super) {
                __extends(Order1, _super);
                function Order1(x0, y0, x1, y1, direction) {
                    var _this = _super.call(this, direction) || this;
                    _this.x0 = 0;
                    _this.y0 = 0;
                    _this.x1 = 0;
                    _this.y1 = 0;
                    _this.xmin = 0;
                    _this.xmax = 0;
                    _this.x0 = x0;
                    _this.y0 = y0;
                    _this.x1 = x1;
                    _this.y1 = y1;
                    if (x0 < x1) {
                        _this.xmin = x0;
                        _this.xmax = x1;
                    }
                    else {
                        _this.xmin = x1;
                        _this.xmax = x0;
                    }
                    return _this;
                }
                Order1.prototype.getOrder = function () {
                    return 1;
                };
                Order1.prototype.getXTop = function () {
                    return this.x0;
                };
                Order1.prototype.getYTop = function () {
                    return this.y0;
                };
                Order1.prototype.getXBot = function () {
                    return this.x1;
                };
                Order1.prototype.getYBot = function () {
                    return this.y1;
                };
                Order1.prototype.getXMin = function () {
                    return this.xmin;
                };
                Order1.prototype.getXMax = function () {
                    return this.xmax;
                };
                Order1.prototype.getX0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.x0 : this.x1;
                };
                Order1.prototype.getY0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.y0 : this.y1;
                };
                Order1.prototype.getX1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.x0 : this.x1;
                };
                Order1.prototype.getY1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.y0 : this.y1;
                };
                Order1.prototype.XforY = function (y) {
                    if (this.x0 === this.x1 || y <= this.y0) {
                        return this.x0;
                    }
                    if (y >= this.y1) {
                        return this.x1;
                    }
                    return (this.x0 + (y - this.y0) * (this.x1 - this.x0) / (this.y1 - this.y0));
                };
                Order1.prototype.TforY = function (y) {
                    if (y <= this.y0) {
                        return 0;
                    }
                    if (y >= this.y1) {
                        return 1;
                    }
                    return (y - this.y0) / (this.y1 - this.y0);
                };
                Order1.prototype.XforT = function (t) {
                    return this.x0 + t * (this.x1 - this.x0);
                };
                Order1.prototype.YforT = function (t) {
                    return this.y0 + t * (this.y1 - this.y0);
                };
                Order1.prototype.dXforT = function (t, deriv) {
                    switch ((deriv)) {
                        case 0:
                            return this.x0 + t * (this.x1 - this.x0);
                        case 1:
                            return (this.x1 - this.x0);
                        default:
                            return 0;
                    }
                };
                Order1.prototype.dYforT = function (t, deriv) {
                    switch ((deriv)) {
                        case 0:
                            return this.y0 + t * (this.y1 - this.y0);
                        case 1:
                            return (this.y1 - this.y0);
                        default:
                            return 0;
                    }
                };
                Order1.prototype.nextVertical = function (t0, t1) {
                    return t1;
                };
                Order1.prototype.accumulateCrossings = function (c) {
                    var xlo = c.getXLo();
                    var ylo = c.getYLo();
                    var xhi = c.getXHi();
                    var yhi = c.getYHi();
                    if (this.xmin >= xhi) {
                        return false;
                    }
                    var xstart;
                    var ystart;
                    var xend;
                    var yend;
                    if (this.y0 < ylo) {
                        if (this.y1 <= ylo) {
                            return false;
                        }
                        ystart = ylo;
                        xstart = this.XforY(ylo);
                    }
                    else {
                        if (this.y0 >= yhi) {
                            return false;
                        }
                        ystart = this.y0;
                        xstart = this.x0;
                    }
                    if (this.y1 > yhi) {
                        yend = yhi;
                        xend = this.XforY(yhi);
                    }
                    else {
                        yend = this.y1;
                        xend = this.x1;
                    }
                    if (xstart >= xhi && xend >= xhi) {
                        return false;
                    }
                    if (xstart > xlo || xend > xlo) {
                        return true;
                    }
                    c.record(ystart, yend, this.direction);
                    return false;
                };
                Order1.prototype.enlarge = function (r) {
                    r.add$double$double(this.x0, this.y0);
                    r.add$double$double(this.x1, this.y1);
                };
                Order1.prototype.getSubCurve$double$double$int = function (ystart, yend, dir) {
                    if (ystart === this.y0 && yend === this.y1) {
                        return this.getWithDirection(dir);
                    }
                    if (this.x0 === this.x1) {
                        return new Order1(this.x0, ystart, this.x1, yend, dir);
                    }
                    var num = this.x0 - this.x1;
                    var denom = this.y0 - this.y1;
                    var xstart = (this.x0 + (ystart - this.y0) * num / denom);
                    var xend = (this.x0 + (yend - this.y0) * num / denom);
                    return new Order1(xstart, ystart, xend, yend, dir);
                };
                Order1.prototype.getSubCurve = function (ystart, yend, dir) {
                    if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && ((typeof dir === 'number') || dir === null)) {
                        return this.getSubCurve$double$double$int(ystart, yend, dir);
                    }
                    else if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && dir === undefined) {
                        return this.getSubCurve$double$double(ystart, yend);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Order1.prototype.getReversedCurve = function () {
                    return new Order1(this.x0, this.y0, this.x1, this.y1, -this.direction);
                };
                Order1.prototype.compareTo = function (other, yrange) {
                    if (!(other != null && other instanceof sun.awt.geom.Order1)) {
                        return _super.prototype.compareTo.call(this, other, yrange);
                    }
                    var c1 = other;
                    if (yrange[1] <= yrange[0]) {
                        throw Object.defineProperty(new Error("yrange already screwed up..."), '__class', { configurable: true, value: 'java.lang.InternalError' });
                    }
                    yrange[1] = Math.min(Math.min(yrange[1], this.y1), c1.y1);
                    if (yrange[1] <= yrange[0]) {
                        throw Object.defineProperty(new Error("backstepping from " + yrange[0] + " to " + yrange[1]), '__class', { configurable: true, value: 'java.lang.InternalError' });
                    }
                    if (this.xmax <= c1.xmin) {
                        return (this.xmin === c1.xmax) ? 0 : -1;
                    }
                    if (this.xmin >= c1.xmax) {
                        return 1;
                    }
                    var dxa = this.x1 - this.x0;
                    var dya = this.y1 - this.y0;
                    var dxb = c1.x1 - c1.x0;
                    var dyb = c1.y1 - c1.y0;
                    var denom = dxb * dya - dxa * dyb;
                    var y;
                    if (denom !== 0) {
                        var num = ((this.x0 - c1.x0) * dya * dyb - this.y0 * dxa * dyb + c1.y0 * dxb * dya);
                        y = num / denom;
                        if (y <= yrange[0]) {
                            y = Math.min(this.y1, c1.y1);
                        }
                        else {
                            if (y < yrange[1]) {
                                yrange[1] = y;
                            }
                            y = Math.max(this.y0, c1.y0);
                        }
                    }
                    else {
                        y = Math.max(this.y0, c1.y0);
                    }
                    return geom.Curve.orderof(this.XforY(y), c1.XforY(y));
                };
                Order1.prototype.getSegment = function (coords) {
                    if (this.direction === sun.awt.geom.Curve.INCREASING) {
                        coords[0] = this.x1;
                        coords[1] = this.y1;
                    }
                    else {
                        coords[0] = this.x0;
                        coords[1] = this.y0;
                    }
                    return PathIterator.SEG_LINETO;
                };
                return Order1;
            }(sun.awt.geom.Curve));
            geom.Order1 = Order1;
            Order1["__class"] = "sun.awt.geom.Order1";
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var Order2 = (function (_super) {
                __extends(Order2, _super);
                function Order2(x0, y0, cx0, cy0, x1, y1, direction) {
                    var _this = _super.call(this, direction) || this;
                    _this.x0 = 0;
                    _this.y0 = 0;
                    _this.cx0 = 0;
                    _this.cy0 = 0;
                    _this.x1 = 0;
                    _this.y1 = 0;
                    _this.xmin = 0;
                    _this.xmax = 0;
                    _this.xcoeff0 = 0;
                    _this.xcoeff1 = 0;
                    _this.xcoeff2 = 0;
                    _this.ycoeff0 = 0;
                    _this.ycoeff1 = 0;
                    _this.ycoeff2 = 0;
                    if (cy0 < y0) {
                        cy0 = y0;
                    }
                    else if (cy0 > y1) {
                        cy0 = y1;
                    }
                    _this.x0 = x0;
                    _this.y0 = y0;
                    _this.cx0 = cx0;
                    _this.cy0 = cy0;
                    _this.x1 = x1;
                    _this.y1 = y1;
                    _this.xmin = Math.min(Math.min(x0, x1), cx0);
                    _this.xmax = Math.max(Math.max(x0, x1), cx0);
                    _this.xcoeff0 = x0;
                    _this.xcoeff1 = cx0 + cx0 - x0 - x0;
                    _this.xcoeff2 = x0 - cx0 - cx0 + x1;
                    _this.ycoeff0 = y0;
                    _this.ycoeff1 = cy0 + cy0 - y0 - y0;
                    _this.ycoeff2 = y0 - cy0 - cy0 + y1;
                    return _this;
                }
                Order2.insert = function (curves, tmp, x0, y0, cx0, cy0, x1, y1, direction) {
                    var numparams = Order2.getHorizontalParams(y0, cy0, y1, tmp);
                    if (numparams === 0) {
                        Order2.addInstance(curves, x0, y0, cx0, cy0, x1, y1, direction);
                        return;
                    }
                    var t = tmp[0];
                    tmp[0] = x0;
                    tmp[1] = y0;
                    tmp[2] = cx0;
                    tmp[3] = cy0;
                    tmp[4] = x1;
                    tmp[5] = y1;
                    Order2.split(tmp, 0, t);
                    var i0 = (direction === sun.awt.geom.Curve.INCREASING) ? 0 : 4;
                    var i1 = 4 - i0;
                    Order2.addInstance(curves, tmp[i0], tmp[i0 + 1], tmp[i0 + 2], tmp[i0 + 3], tmp[i0 + 4], tmp[i0 + 5], direction);
                    Order2.addInstance(curves, tmp[i1], tmp[i1 + 1], tmp[i1 + 2], tmp[i1 + 3], tmp[i1 + 4], tmp[i1 + 5], direction);
                };
                Order2.addInstance = function (curves, x0, y0, cx0, cy0, x1, y1, direction) {
                    if (y0 > y1) {
                        /* add */ curves.push(new Order2(x1, y1, cx0, cy0, x0, y0, -direction));
                    }
                    else if (y1 > y0) {
                        /* add */ curves.push(new Order2(x0, y0, cx0, cy0, x1, y1, direction));
                    }
                };
                Order2.getHorizontalParams = function (c0, cp, c1, ret) {
                    if (c0 <= cp && cp <= c1) {
                        return 0;
                    }
                    c0 -= cp;
                    c1 -= cp;
                    var denom = c0 + c1;
                    if (denom === 0) {
                        return 0;
                    }
                    var t = c0 / denom;
                    if (t <= 0 || t >= 1) {
                        return 0;
                    }
                    ret[0] = t;
                    return 1;
                };
                Order2.split = function (coords, pos, t) {
                    var x0;
                    var y0;
                    var cx;
                    var cy;
                    var x1;
                    var y1;
                    coords[pos + 8] = x1 = coords[pos + 4];
                    coords[pos + 9] = y1 = coords[pos + 5];
                    cx = coords[pos + 2];
                    cy = coords[pos + 3];
                    x1 = cx + (x1 - cx) * t;
                    y1 = cy + (y1 - cy) * t;
                    x0 = coords[pos + 0];
                    y0 = coords[pos + 1];
                    x0 = x0 + (cx - x0) * t;
                    y0 = y0 + (cy - y0) * t;
                    cx = x0 + (x1 - x0) * t;
                    cy = y0 + (y1 - y0) * t;
                    coords[pos + 2] = x0;
                    coords[pos + 3] = y0;
                    coords[pos + 4] = cx;
                    coords[pos + 5] = cy;
                    coords[pos + 6] = x1;
                    coords[pos + 7] = y1;
                };
                Order2.prototype.getOrder = function () {
                    return 2;
                };
                Order2.prototype.getXTop = function () {
                    return this.x0;
                };
                Order2.prototype.getYTop = function () {
                    return this.y0;
                };
                Order2.prototype.getXBot = function () {
                    return this.x1;
                };
                Order2.prototype.getYBot = function () {
                    return this.y1;
                };
                Order2.prototype.getXMin = function () {
                    return this.xmin;
                };
                Order2.prototype.getXMax = function () {
                    return this.xmax;
                };
                Order2.prototype.getX0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.x0 : this.x1;
                };
                Order2.prototype.getY0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.y0 : this.y1;
                };
                Order2.prototype.getCX0 = function () {
                    return this.cx0;
                };
                Order2.prototype.getCY0 = function () {
                    return this.cy0;
                };
                Order2.prototype.getX1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.x0 : this.x1;
                };
                Order2.prototype.getY1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.y0 : this.y1;
                };
                Order2.prototype.XforY = function (y) {
                    if (y <= this.y0) {
                        return this.x0;
                    }
                    if (y >= this.y1) {
                        return this.x1;
                    }
                    return this.XforT(this.TforY(y));
                };
                Order2.prototype.TforY = function (y) {
                    if (y <= this.y0) {
                        return 0;
                    }
                    if (y >= this.y1) {
                        return 1;
                    }
                    return Order2.TforY(y, this.ycoeff0, this.ycoeff1, this.ycoeff2);
                };
                Order2.TforY = function (y, ycoeff0, ycoeff1, ycoeff2) {
                    ycoeff0 -= y;
                    if (ycoeff2 === 0.0) {
                        var root = -ycoeff0 / ycoeff1;
                        if (root >= 0 && root <= 1) {
                            return root;
                        }
                    }
                    else {
                        var d = ycoeff1 * ycoeff1 - 4.0 * ycoeff2 * ycoeff0;
                        if (d >= 0.0) {
                            d = Math.sqrt(d);
                            if (ycoeff1 < 0.0) {
                                d = -d;
                            }
                            var q = (ycoeff1 + d) / -2.0;
                            var root = q / ycoeff2;
                            if (root >= 0 && root <= 1) {
                                return root;
                            }
                            if (q !== 0.0) {
                                root = ycoeff0 / q;
                                if (root >= 0 && root <= 1) {
                                    return root;
                                }
                            }
                        }
                    }
                    var y0 = ycoeff0;
                    var y1 = ycoeff0 + ycoeff1 + ycoeff2;
                    return (0 < (y0 + y1) / 2) ? 0.0 : 1.0;
                };
                Order2.prototype.XforT = function (t) {
                    return (this.xcoeff2 * t + this.xcoeff1) * t + this.xcoeff0;
                };
                Order2.prototype.YforT = function (t) {
                    return (this.ycoeff2 * t + this.ycoeff1) * t + this.ycoeff0;
                };
                Order2.prototype.dXforT = function (t, deriv) {
                    switch ((deriv)) {
                        case 0:
                            return (this.xcoeff2 * t + this.xcoeff1) * t + this.xcoeff0;
                        case 1:
                            return 2 * this.xcoeff2 * t + this.xcoeff1;
                        case 2:
                            return 2 * this.xcoeff2;
                        default:
                            return 0;
                    }
                };
                Order2.prototype.dYforT = function (t, deriv) {
                    switch ((deriv)) {
                        case 0:
                            return (this.ycoeff2 * t + this.ycoeff1) * t + this.ycoeff0;
                        case 1:
                            return 2 * this.ycoeff2 * t + this.ycoeff1;
                        case 2:
                            return 2 * this.ycoeff2;
                        default:
                            return 0;
                    }
                };
                Order2.prototype.nextVertical = function (t0, t1) {
                    var t = -this.xcoeff1 / (2 * this.xcoeff2);
                    if (t > t0 && t < t1) {
                        return t;
                    }
                    return t1;
                };
                Order2.prototype.enlarge = function (r) {
                    r.add$double$double(this.x0, this.y0);
                    var t = -this.xcoeff1 / (2 * this.xcoeff2);
                    if (t > 0 && t < 1) {
                        r.add$double$double(this.XforT(t), this.YforT(t));
                    }
                    r.add$double$double(this.x1, this.y1);
                };
                Order2.prototype.getSubCurve$double$double$int = function (ystart, yend, dir) {
                    var t0;
                    var t1;
                    if (ystart <= this.y0) {
                        if (yend >= this.y1) {
                            return this.getWithDirection(dir);
                        }
                        t0 = 0;
                    }
                    else {
                        t0 = Order2.TforY(ystart, this.ycoeff0, this.ycoeff1, this.ycoeff2);
                    }
                    if (yend >= this.y1) {
                        t1 = 1;
                    }
                    else {
                        t1 = Order2.TforY(yend, this.ycoeff0, this.ycoeff1, this.ycoeff2);
                    }
                    var eqn = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                    eqn[0] = this.x0;
                    eqn[1] = this.y0;
                    eqn[2] = this.cx0;
                    eqn[3] = this.cy0;
                    eqn[4] = this.x1;
                    eqn[5] = this.y1;
                    if (t1 < 1) {
                        Order2.split(eqn, 0, t1);
                    }
                    var i;
                    if (t0 <= 0) {
                        i = 0;
                    }
                    else {
                        Order2.split(eqn, 0, t0 / t1);
                        i = 4;
                    }
                    return new Order2(eqn[i + 0], ystart, eqn[i + 2], eqn[i + 3], eqn[i + 4], yend, dir);
                };
                Order2.prototype.getSubCurve = function (ystart, yend, dir) {
                    if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && ((typeof dir === 'number') || dir === null)) {
                        return this.getSubCurve$double$double$int(ystart, yend, dir);
                    }
                    else if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && dir === undefined) {
                        return this.getSubCurve$double$double(ystart, yend);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Order2.prototype.getReversedCurve = function () {
                    return new Order2(this.x0, this.y0, this.cx0, this.cy0, this.x1, this.y1, -this.direction);
                };
                Order2.prototype.getSegment = function (coords) {
                    coords[0] = this.cx0;
                    coords[1] = this.cy0;
                    if (this.direction === sun.awt.geom.Curve.INCREASING) {
                        coords[2] = this.x1;
                        coords[3] = this.y1;
                    }
                    else {
                        coords[2] = this.x0;
                        coords[3] = this.y0;
                    }
                    return PathIterator.SEG_QUADTO;
                };
                Order2.prototype.controlPointString = function () {
                    return ("(" + geom.Curve.round(this.cx0) + ", " + geom.Curve.round(this.cy0) + "), ");
                };
                return Order2;
            }(sun.awt.geom.Curve));
            geom.Order2 = Order2;
            Order2["__class"] = "sun.awt.geom.Order2";
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var Order3 = (function (_super) {
                __extends(Order3, _super);
                function Order3(x0, y0, cx0, cy0, cx1, cy1, x1, y1, direction) {
                    var _this = _super.call(this, direction) || this;
                    _this.x0 = 0;
                    _this.y0 = 0;
                    _this.cx0 = 0;
                    _this.cy0 = 0;
                    _this.cx1 = 0;
                    _this.cy1 = 0;
                    _this.x1 = 0;
                    _this.y1 = 0;
                    _this.xmin = 0;
                    _this.xmax = 0;
                    _this.xcoeff0 = 0;
                    _this.xcoeff1 = 0;
                    _this.xcoeff2 = 0;
                    _this.xcoeff3 = 0;
                    _this.ycoeff0 = 0;
                    _this.ycoeff1 = 0;
                    _this.ycoeff2 = 0;
                    _this.ycoeff3 = 0;
                    _this.TforY1 = 0;
                    _this.YforT1 = 0;
                    _this.TforY2 = 0;
                    _this.YforT2 = 0;
                    _this.TforY3 = 0;
                    _this.YforT3 = 0;
                    if (cy0 < y0)
                        cy0 = y0;
                    if (cy1 > y1)
                        cy1 = y1;
                    _this.x0 = x0;
                    _this.y0 = y0;
                    _this.cx0 = cx0;
                    _this.cy0 = cy0;
                    _this.cx1 = cx1;
                    _this.cy1 = cy1;
                    _this.x1 = x1;
                    _this.y1 = y1;
                    _this.xmin = Math.min(Math.min(x0, x1), Math.min(cx0, cx1));
                    _this.xmax = Math.max(Math.max(x0, x1), Math.max(cx0, cx1));
                    _this.xcoeff0 = x0;
                    _this.xcoeff1 = (cx0 - x0) * 3.0;
                    _this.xcoeff2 = (cx1 - cx0 - cx0 + x0) * 3.0;
                    _this.xcoeff3 = x1 - (cx1 - cx0) * 3.0 - x0;
                    _this.ycoeff0 = y0;
                    _this.ycoeff1 = (cy0 - y0) * 3.0;
                    _this.ycoeff2 = (cy1 - cy0 - cy0 + y0) * 3.0;
                    _this.ycoeff3 = y1 - (cy1 - cy0) * 3.0 - y0;
                    _this.YforT1 = _this.YforT2 = _this.YforT3 = y0;
                    return _this;
                }
                Order3.insert = function (curves, tmp, x0, y0, cx0, cy0, cx1, cy1, x1, y1, direction) {
                    var numparams = Order3.getHorizontalParams(y0, cy0, cy1, y1, tmp);
                    if (numparams === 0) {
                        Order3.addInstance(curves, x0, y0, cx0, cy0, cx1, cy1, x1, y1, direction);
                        return;
                    }
                    tmp[3] = x0;
                    tmp[4] = y0;
                    tmp[5] = cx0;
                    tmp[6] = cy0;
                    tmp[7] = cx1;
                    tmp[8] = cy1;
                    tmp[9] = x1;
                    tmp[10] = y1;
                    var t = tmp[0];
                    if (numparams > 1 && t > tmp[1]) {
                        tmp[0] = tmp[1];
                        tmp[1] = t;
                        t = tmp[0];
                    }
                    Order3.split(tmp, 3, t);
                    if (numparams > 1) {
                        t = (tmp[1] - t) / (1 - t);
                        Order3.split(tmp, 9, t);
                    }
                    var index = 3;
                    if (direction === sun.awt.geom.Curve.DECREASING) {
                        index += numparams * 6;
                    }
                    while ((numparams >= 0)) {
                        Order3.addInstance(curves, tmp[index + 0], tmp[index + 1], tmp[index + 2], tmp[index + 3], tmp[index + 4], tmp[index + 5], tmp[index + 6], tmp[index + 7], direction);
                        numparams--;
                        if (direction === sun.awt.geom.Curve.INCREASING) {
                            index += 6;
                        }
                        else {
                            index -= 6;
                        }
                    }
                    ;
                };
                Order3.addInstance = function (curves, x0, y0, cx0, cy0, cx1, cy1, x1, y1, direction) {
                    if (y0 > y1) {
                        /* add */ curves.push(new Order3(x1, y1, cx1, cy1, cx0, cy0, x0, y0, -direction));
                    }
                    else if (y1 > y0) {
                        /* add */ curves.push(new Order3(x0, y0, cx0, cy0, cx1, cy1, x1, y1, direction));
                    }
                };
                Order3.getHorizontalParams = function (c0, cp0, cp1, c1, ret) {
                    if (c0 <= cp0 && cp0 <= cp1 && cp1 <= c1) {
                        return 0;
                    }
                    c1 -= cp1;
                    cp1 -= cp0;
                    cp0 -= c0;
                    ret[0] = cp0;
                    ret[1] = (cp1 - cp0) * 2;
                    ret[2] = (c1 - cp1 - cp1 + cp0);
                    var numroots = QuadCurve2D.solveQuadratic$double_A$double_A(ret, ret);
                    var j = 0;
                    for (var i = 0; i < numroots; i++) {
                        var t = ret[i];
                        if (t > 0 && t < 1) {
                            if (j < i) {
                                ret[j] = t;
                            }
                            j++;
                        }
                    }
                    return j;
                };
                Order3.split = function (coords, pos, t) {
                    var x0;
                    var y0;
                    var cx0;
                    var cy0;
                    var cx1;
                    var cy1;
                    var x1;
                    var y1;
                    coords[pos + 12] = x1 = coords[pos + 6];
                    coords[pos + 13] = y1 = coords[pos + 7];
                    cx1 = coords[pos + 4];
                    cy1 = coords[pos + 5];
                    x1 = cx1 + (x1 - cx1) * t;
                    y1 = cy1 + (y1 - cy1) * t;
                    x0 = coords[pos + 0];
                    y0 = coords[pos + 1];
                    cx0 = coords[pos + 2];
                    cy0 = coords[pos + 3];
                    x0 = x0 + (cx0 - x0) * t;
                    y0 = y0 + (cy0 - y0) * t;
                    cx0 = cx0 + (cx1 - cx0) * t;
                    cy0 = cy0 + (cy1 - cy0) * t;
                    cx1 = cx0 + (x1 - cx0) * t;
                    cy1 = cy0 + (y1 - cy0) * t;
                    cx0 = x0 + (cx0 - x0) * t;
                    cy0 = y0 + (cy0 - y0) * t;
                    coords[pos + 2] = x0;
                    coords[pos + 3] = y0;
                    coords[pos + 4] = cx0;
                    coords[pos + 5] = cy0;
                    coords[pos + 6] = cx0 + (cx1 - cx0) * t;
                    coords[pos + 7] = cy0 + (cy1 - cy0) * t;
                    coords[pos + 8] = cx1;
                    coords[pos + 9] = cy1;
                    coords[pos + 10] = x1;
                    coords[pos + 11] = y1;
                };
                Order3.prototype.getOrder = function () {
                    return 3;
                };
                Order3.prototype.getXTop = function () {
                    return this.x0;
                };
                Order3.prototype.getYTop = function () {
                    return this.y0;
                };
                Order3.prototype.getXBot = function () {
                    return this.x1;
                };
                Order3.prototype.getYBot = function () {
                    return this.y1;
                };
                Order3.prototype.getXMin = function () {
                    return this.xmin;
                };
                Order3.prototype.getXMax = function () {
                    return this.xmax;
                };
                Order3.prototype.getX0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.x0 : this.x1;
                };
                Order3.prototype.getY0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.y0 : this.y1;
                };
                Order3.prototype.getCX0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.cx0 : this.cx1;
                };
                Order3.prototype.getCY0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.cy0 : this.cy1;
                };
                Order3.prototype.getCX1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.cx0 : this.cx1;
                };
                Order3.prototype.getCY1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.cy0 : this.cy1;
                };
                Order3.prototype.getX1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.x0 : this.x1;
                };
                Order3.prototype.getY1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.y0 : this.y1;
                };
                Order3.prototype.TforY = function (y) {
                    if (y <= this.y0)
                        return 0;
                    if (y >= this.y1)
                        return 1;
                    if (y === this.YforT1)
                        return this.TforY1;
                    if (y === this.YforT2)
                        return this.TforY2;
                    if (y === this.YforT3)
                        return this.TforY3;
                    if (this.ycoeff3 === 0.0) {
                        return sun.awt.geom.Order2.TforY(y, this.ycoeff0, this.ycoeff1, this.ycoeff2);
                    }
                    var a = this.ycoeff2 / this.ycoeff3;
                    var b = this.ycoeff1 / this.ycoeff3;
                    var c = (this.ycoeff0 - y) / this.ycoeff3;
                    var roots = 0;
                    var Q = (a * a - 3.0 * b) / 9.0;
                    var R = (2.0 * a * a * a - 9.0 * a * b + 27.0 * c) / 54.0;
                    var R2 = R * R;
                    var Q3 = Q * Q * Q;
                    var a_3 = a / 3.0;
                    var t;
                    if (R2 < Q3) {
                        var theta = Math.acos(R / Math.sqrt(Q3));
                        Q = -2.0 * Math.sqrt(Q);
                        t = this.refine(a, b, c, y, Q * Math.cos(theta / 3.0) - a_3);
                        if (t < 0) {
                            t = this.refine(a, b, c, y, Q * Math.cos((theta + Math.PI * 2.0) / 3.0) - a_3);
                        }
                        if (t < 0) {
                            t = this.refine(a, b, c, y, Q * Math.cos((theta - Math.PI * 2.0) / 3.0) - a_3);
                        }
                    }
                    else {
                        var neg = (R < 0.0);
                        var S = Math.sqrt(R2 - Q3);
                        if (neg) {
                            R = -R;
                        }
                        var A = Math.pow(R + S, 1.0 / 3.0);
                        if (!neg) {
                            A = -A;
                        }
                        var B = (A === 0.0) ? 0.0 : (Q / A);
                        t = this.refine(a, b, c, y, (A + B) - a_3);
                    }
                    if (t < 0) {
                        var t0 = 0;
                        var t1 = 1;
                        while ((true)) {
                            t = (t0 + t1) / 2;
                            if (t === t0 || t === t1) {
                                break;
                            }
                            var yt = this.YforT(t);
                            if (yt < y) {
                                t0 = t;
                            }
                            else if (yt > y) {
                                t1 = t;
                            }
                            else {
                                break;
                            }
                        }
                        ;
                    }
                    if (t >= 0) {
                        this.TforY3 = this.TforY2;
                        this.YforT3 = this.YforT2;
                        this.TforY2 = this.TforY1;
                        this.YforT2 = this.YforT1;
                        this.TforY1 = t;
                        this.YforT1 = y;
                    }
                    return t;
                };
                Order3.prototype.refine = function (a, b, c, target, t) {
                    if (t < -0.1 || t > 1.1) {
                        return -1;
                    }
                    var y = this.YforT(t);
                    var t0;
                    var t1;
                    if (y < target) {
                        t0 = t;
                        t1 = 1;
                    }
                    else {
                        t0 = 0;
                        t1 = t;
                    }
                    var origt = t;
                    var origy = y;
                    var useslope = true;
                    while ((y !== target)) {
                        if (!useslope) {
                            var t2 = (t0 + t1) / 2;
                            if (t2 === t0 || t2 === t1) {
                                break;
                            }
                            t = t2;
                        }
                        else {
                            var slope = this.dYforT(t, 1);
                            if (slope === 0) {
                                useslope = false;
                                continue;
                            }
                            var t2 = t + ((target - y) / slope);
                            if (t2 === t || t2 <= t0 || t2 >= t1) {
                                useslope = false;
                                continue;
                            }
                            t = t2;
                        }
                        y = this.YforT(t);
                        if (y < target) {
                            t0 = t;
                        }
                        else if (y > target) {
                            t1 = t;
                        }
                        else {
                            break;
                        }
                    }
                    ;
                    return (t > 1) ? -1 : t;
                };
                Order3.prototype.XforY = function (y) {
                    if (y <= this.y0) {
                        return this.x0;
                    }
                    if (y >= this.y1) {
                        return this.x1;
                    }
                    return this.XforT(this.TforY(y));
                };
                Order3.prototype.XforT = function (t) {
                    return (((this.xcoeff3 * t) + this.xcoeff2) * t + this.xcoeff1) * t + this.xcoeff0;
                };
                Order3.prototype.YforT = function (t) {
                    return (((this.ycoeff3 * t) + this.ycoeff2) * t + this.ycoeff1) * t + this.ycoeff0;
                };
                Order3.prototype.dXforT = function (t, deriv) {
                    switch ((deriv)) {
                        case 0:
                            return (((this.xcoeff3 * t) + this.xcoeff2) * t + this.xcoeff1) * t + this.xcoeff0;
                        case 1:
                            return ((3 * this.xcoeff3 * t) + 2 * this.xcoeff2) * t + this.xcoeff1;
                        case 2:
                            return (6 * this.xcoeff3 * t) + 2 * this.xcoeff2;
                        case 3:
                            return 6 * this.xcoeff3;
                        default:
                            return 0;
                    }
                };
                Order3.prototype.dYforT = function (t, deriv) {
                    switch ((deriv)) {
                        case 0:
                            return (((this.ycoeff3 * t) + this.ycoeff2) * t + this.ycoeff1) * t + this.ycoeff0;
                        case 1:
                            return ((3 * this.ycoeff3 * t) + 2 * this.ycoeff2) * t + this.ycoeff1;
                        case 2:
                            return (6 * this.ycoeff3 * t) + 2 * this.ycoeff2;
                        case 3:
                            return 6 * this.ycoeff3;
                        default:
                            return 0;
                    }
                };
                Order3.prototype.nextVertical = function (t0, t1) {
                    var eqn = [this.xcoeff1, 2 * this.xcoeff2, 3 * this.xcoeff3];
                    var numroots = QuadCurve2D.solveQuadratic$double_A$double_A(eqn, eqn);
                    for (var i = 0; i < numroots; i++) {
                        if (eqn[i] > t0 && eqn[i] < t1) {
                            t1 = eqn[i];
                        }
                    }
                    return t1;
                };
                Order3.prototype.enlarge = function (r) {
                    r.add$double$double(this.x0, this.y0);
                    var eqn = [this.xcoeff1, 2 * this.xcoeff2, 3 * this.xcoeff3];
                    var numroots = QuadCurve2D.solveQuadratic$double_A$double_A(eqn, eqn);
                    for (var i = 0; i < numroots; i++) {
                        var t = eqn[i];
                        if (t > 0 && t < 1) {
                            r.add$double$double(this.XforT(t), this.YforT(t));
                        }
                    }
                    r.add$double$double(this.x1, this.y1);
                };
                Order3.prototype.getSubCurve$double$double$int = function (ystart, yend, dir) {
                    if (ystart <= this.y0 && yend >= this.y1) {
                        return this.getWithDirection(dir);
                    }
                    var eqn = (function (s) { var a = []; while (s-- > 0)
                        a.push(0); return a; })(14);
                    var t0;
                    var t1;
                    t0 = this.TforY(ystart);
                    t1 = this.TforY(yend);
                    eqn[0] = this.x0;
                    eqn[1] = this.y0;
                    eqn[2] = this.cx0;
                    eqn[3] = this.cy0;
                    eqn[4] = this.cx1;
                    eqn[5] = this.cy1;
                    eqn[6] = this.x1;
                    eqn[7] = this.y1;
                    if (t0 > t1) {
                        var t = t0;
                        t0 = t1;
                        t1 = t;
                    }
                    if (t1 < 1) {
                        Order3.split(eqn, 0, t1);
                    }
                    var i;
                    if (t0 <= 0) {
                        i = 0;
                    }
                    else {
                        Order3.split(eqn, 0, t0 / t1);
                        i = 6;
                    }
                    return new Order3(eqn[i + 0], ystart, eqn[i + 2], eqn[i + 3], eqn[i + 4], eqn[i + 5], eqn[i + 6], yend, dir);
                };
                Order3.prototype.getSubCurve = function (ystart, yend, dir) {
                    if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && ((typeof dir === 'number') || dir === null)) {
                        return this.getSubCurve$double$double$int(ystart, yend, dir);
                    }
                    else if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && dir === undefined) {
                        return this.getSubCurve$double$double(ystart, yend);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Order3.prototype.getReversedCurve = function () {
                    return new Order3(this.x0, this.y0, this.cx0, this.cy0, this.cx1, this.cy1, this.x1, this.y1, -this.direction);
                };
                Order3.prototype.getSegment = function (coords) {
                    if (this.direction === sun.awt.geom.Curve.INCREASING) {
                        coords[0] = this.cx0;
                        coords[1] = this.cy0;
                        coords[2] = this.cx1;
                        coords[3] = this.cy1;
                        coords[4] = this.x1;
                        coords[5] = this.y1;
                    }
                    else {
                        coords[0] = this.cx1;
                        coords[1] = this.cy1;
                        coords[2] = this.cx0;
                        coords[3] = this.cy0;
                        coords[4] = this.x0;
                        coords[5] = this.y0;
                    }
                    return PathIterator.SEG_CUBICTO;
                };
                Order3.prototype.controlPointString = function () {
                    return (("(" + geom.Curve.round(this.getCX0()) + ", " + geom.Curve.round(this.getCY0()) + "), ") + ("(" + geom.Curve.round(this.getCX1()) + ", " + geom.Curve.round(this.getCY1()) + "), "));
                };
                return Order3;
            }(sun.awt.geom.Curve));
            geom.Order3 = Order3;
            Order3["__class"] = "sun.awt.geom.Order3";
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var AreaOp = (function () {
                function AreaOp() {
                    /*private*/ this.verbose = false;
                }
                AreaOp.prototype.calculate = function (left, right) {
                    var edges = ([]);
                    AreaOp.addEdges(edges, left, AreaOp.CTAG_LEFT);
                    AreaOp.addEdges(edges, right, AreaOp.CTAG_RIGHT);
                    edges = this.pruneEdges(edges);
                    if (this.verbose) {
                        console.info("result: ");
                        var numcurves = edges.length;
                        var curvelist = (function (a1, a2) { if (a1.length >= a2.length) {
                            a1.length = 0;
                            a1.push.apply(a1, a2);
                            return a1;
                        }
                        else {
                            return a2.slice(0);
                        } })(new Array(numcurves), edges);
                        for (var i = 0; i < numcurves; i++) {
                            console.info("curvelist[" + i + "] = " + curvelist[i]);
                        }
                    }
                    return edges;
                };
                AreaOp.addEdges = function (edges, curves, curvetag) {
                    for (var index121 = 0; index121 < curves.length; index121++) {
                        var c = curves[index121];
                        {
                            if (c.getOrder() > 0) {
                                /* add */ edges.push(new sun.awt.geom.Edge(c, curvetag));
                            }
                        }
                    }
                };
                AreaOp.YXTopComparator_$LI$ = function () {
                    if (AreaOp.YXTopComparator == null)
                        AreaOp.YXTopComparator = function (o1, o2) {
                            var c1 = o1.getCurve();
                            var c2 = o2.getCurve();
                            var v1;
                            var v2;
                            if ((v1 = c1.getYTop()) === (v2 = c2.getYTop())) {
                                if ((v1 = c1.getXTop()) === (v2 = c2.getXTop())) {
                                    return 0;
                                }
                            }
                            if (v1 < v2) {
                                return -1;
                            }
                            return 1;
                        };
                    return AreaOp.YXTopComparator;
                };
                ;
                AreaOp.prototype.pruneEdges = function (edges) {
                    var numedges = edges.length;
                    if (numedges < 2) {
                        return edges;
                    }
                    var edgelist = (function (a1, a2) { if (a1.length >= a2.length) {
                        a1.length = 0;
                        a1.push.apply(a1, a2);
                        return a1;
                    }
                    else {
                        return a2.slice(0);
                    } })(new Array(numedges), edges);
                    /* sort */ edgelist.sort(AreaOp.YXTopComparator_$LI$());
                    if (this.verbose) {
                        console.info("pruning: ");
                        for (var i = 0; i < numedges; i++) {
                            console.info("edgelist[" + i + "] = " + edgelist[i]);
                        }
                    }
                    var e;
                    var left = 0;
                    var right = 0;
                    var cur = 0;
                    var next = 0;
                    var yrange = [0, 0];
                    var subcurves = ([]);
                    var chains = ([]);
                    var links = ([]);
                    while ((left < numedges)) {
                        var y = yrange[0];
                        for (cur = next = right - 1; cur >= left; cur--) {
                            e = edgelist[cur];
                            if (e.getCurve().getYBot() > y) {
                                if (next > cur) {
                                    edgelist[next] = e;
                                }
                                next--;
                            }
                        }
                        left = next + 1;
                        if (left >= right) {
                            if (right >= numedges) {
                                break;
                            }
                            y = edgelist[right].getCurve().getYTop();
                            if (y > yrange[0]) {
                                AreaOp.finalizeSubCurves(subcurves, chains);
                            }
                            yrange[0] = y;
                        }
                        while ((right < numedges)) {
                            e = edgelist[right];
                            if (e.getCurve().getYTop() > y) {
                                break;
                            }
                            right++;
                        }
                        ;
                        yrange[1] = edgelist[left].getCurve().getYBot();
                        if (right < numedges) {
                            y = edgelist[right].getCurve().getYTop();
                            if (yrange[1] > y) {
                                yrange[1] = y;
                            }
                        }
                        if (this.verbose) {
                            console.info("current line: y = [" + yrange[0] + ", " + yrange[1] + "]");
                            for (cur = left; cur < right; cur++) {
                                console.info("  " + edgelist[cur]);
                            }
                        }
                        var nexteq = 1;
                        for (cur = left; cur < right; cur++) {
                            e = edgelist[cur];
                            e.setEquivalence(0);
                            for (next = cur; next > left; next--) {
                                var prevedge = edgelist[next - 1];
                                var ordering = e.compareTo(prevedge, yrange);
                                if (yrange[1] <= yrange[0]) {
                                    throw Object.defineProperty(new Error("backstepping to " + yrange[1] + " from " + yrange[0]), '__class', { configurable: true, value: 'java.lang.InternalError' });
                                }
                                if (ordering >= 0) {
                                    if (ordering === 0) {
                                        var eq = prevedge.getEquivalence();
                                        if (eq === 0) {
                                            eq = nexteq++;
                                            prevedge.setEquivalence(eq);
                                        }
                                        e.setEquivalence(eq);
                                    }
                                    break;
                                }
                                edgelist[next] = prevedge;
                            }
                            edgelist[next] = e;
                        }
                        if (this.verbose) {
                            console.info("current sorted line: y = [" + yrange[0] + ", " + yrange[1] + "]");
                            for (cur = left; cur < right; cur++) {
                                console.info("  " + edgelist[cur]);
                            }
                        }
                        this.newRow();
                        var ystart = yrange[0];
                        var yend = yrange[1];
                        for (cur = left; cur < right; cur++) {
                            e = edgelist[cur];
                            var etag = void 0;
                            var eq = e.getEquivalence();
                            if (eq !== 0) {
                                var origstate = this.getState();
                                etag = (origstate === AreaOp.RSTAG_INSIDE ? AreaOp.ETAG_EXIT : AreaOp.ETAG_ENTER);
                                var activematch = null;
                                var longestmatch = e;
                                var furthesty = yend;
                                do {
                                    this.classify(e);
                                    if (activematch == null && e.isActiveFor(ystart, etag)) {
                                        activematch = e;
                                    }
                                    y = e.getCurve().getYBot();
                                    if (y > furthesty) {
                                        longestmatch = e;
                                        furthesty = y;
                                    }
                                } while ((++cur < right && (e = edgelist[cur]).getEquivalence() === eq));
                                --cur;
                                if (this.getState() === origstate) {
                                    etag = AreaOp.ETAG_IGNORE;
                                }
                                else {
                                    e = (activematch != null ? activematch : longestmatch);
                                }
                            }
                            else {
                                etag = this.classify(e);
                            }
                            if (etag !== AreaOp.ETAG_IGNORE) {
                                e.record(yend, etag);
                                /* add */ links.push(new sun.awt.geom.CurveLink(e.getCurve(), ystart, yend, etag));
                            }
                        }
                        if (this.getState() !== AreaOp.RSTAG_OUTSIDE) {
                            console.info("Still inside at end of active edge list!");
                            console.info("num curves = " + (right - left));
                            console.info("num links = " + links.length);
                            console.info("y top = " + yrange[0]);
                            if (right < numedges) {
                                console.info("y top of next curve = " + edgelist[right].getCurve().getYTop());
                            }
                            else {
                                console.info("no more curves");
                            }
                            for (cur = left; cur < right; cur++) {
                                e = edgelist[cur];
                                console.info(e);
                                var eq = e.getEquivalence();
                                if (eq !== 0) {
                                    console.info("  was equal to " + eq + "...");
                                }
                            }
                        }
                        if (this.verbose) {
                            console.info("new links:");
                            for (var i = 0; i < links.length; i++) {
                                var link = links[i];
                                console.info("  " + link.getSubCurve());
                            }
                        }
                        AreaOp.resolveLinks(subcurves, chains, links);
                        /* clear */ (links.length = 0);
                        yrange[0] = yend;
                    }
                    ;
                    AreaOp.finalizeSubCurves(subcurves, chains);
                    var ret = ([]);
                    var enum_ = (function (a) { var i = 0; return { nextElement: function () { return i < a.length ? a[i++] : null; }, hasMoreElements: function () { return i < a.length; } }; })(subcurves);
                    while ((enum_.hasMoreElements())) {
                        var link = enum_.nextElement();
                        /* add */ ret.push(link.getMoveto());
                        var nextlink = link;
                        while (((nextlink = nextlink.getNext()) != null)) {
                            if (!link.absorb$sun_awt_geom_CurveLink(nextlink)) {
                                /* add */ ret.push(link.getSubCurve());
                                link = nextlink;
                            }
                        }
                        ;
                        /* add */ ret.push(link.getSubCurve());
                    }
                    ;
                    return ret;
                };
                AreaOp.finalizeSubCurves = function (subcurves, chains) {
                    var numchains = chains.length;
                    if (numchains === 0) {
                        return;
                    }
                    if ((numchains & 1) !== 0) {
                        throw Object.defineProperty(new Error("Odd number of chains!"), '__class', { configurable: true, value: 'java.lang.InternalError' });
                    }
                    var endlist = new Array(numchains);
                    /* toArray */ (function (a1, a2) { if (a1.length >= a2.length) {
                        a1.length = 0;
                        a1.push.apply(a1, a2);
                        return a1;
                    }
                    else {
                        return a2.slice(0);
                    } })(endlist, chains);
                    for (var i = 1; i < numchains; i += 2) {
                        var open_1 = endlist[i - 1];
                        var close_1 = endlist[i];
                        var subcurve = open_1.linkTo(close_1);
                        if (subcurve != null) {
                            /* add */ subcurves.push(subcurve);
                        }
                    }
                    /* clear */ (chains.length = 0);
                };
                AreaOp.EmptyLinkList_$LI$ = function () { if (AreaOp.EmptyLinkList == null)
                    AreaOp.EmptyLinkList = new Array(2); return AreaOp.EmptyLinkList; };
                ;
                AreaOp.EmptyChainList_$LI$ = function () { if (AreaOp.EmptyChainList == null)
                    AreaOp.EmptyChainList = new Array(2); return AreaOp.EmptyChainList; };
                ;
                AreaOp.resolveLinks = function (subcurves, chains, links) {
                    var numlinks = links.length;
                    var linklist;
                    if (numlinks === 0) {
                        linklist = AreaOp.EmptyLinkList_$LI$();
                    }
                    else {
                        if ((numlinks & 1) !== 0) {
                            throw Object.defineProperty(new Error("Odd number of new curves!"), '__class', { configurable: true, value: 'java.lang.InternalError' });
                        }
                        linklist = new Array(numlinks + 2);
                        /* toArray */ (function (a1, a2) { if (a1.length >= a2.length) {
                            a1.length = 0;
                            a1.push.apply(a1, a2);
                            return a1;
                        }
                        else {
                            return a2.slice(0);
                        } })(linklist, links);
                    }
                    var numchains = chains.length;
                    var endlist;
                    if (numchains === 0) {
                        endlist = AreaOp.EmptyChainList_$LI$();
                    }
                    else {
                        if ((numchains & 1) !== 0) {
                            throw Object.defineProperty(new Error("Odd number of chains!"), '__class', { configurable: true, value: 'java.lang.InternalError' });
                        }
                        endlist = new Array(numchains + 2);
                        /* toArray */ (function (a1, a2) { if (a1.length >= a2.length) {
                            a1.length = 0;
                            a1.push.apply(a1, a2);
                            return a1;
                        }
                        else {
                            return a2.slice(0);
                        } })(endlist, chains);
                    }
                    var curchain = 0;
                    var curlink = 0;
                    /* clear */ (chains.length = 0);
                    var chain = endlist[0];
                    var nextchain = endlist[1];
                    var link = linklist[0];
                    var nextlink = linklist[1];
                    while ((chain != null || link != null)) {
                        var connectchains = (link == null);
                        var connectlinks = (chain == null);
                        if (!connectchains && !connectlinks) {
                            connectchains = ((curchain & 1) === 0 && chain.getX() === nextchain.getX());
                            connectlinks = ((curlink & 1) === 0 && link.getX() === nextlink.getX());
                            if (!connectchains && !connectlinks) {
                                var cx = chain.getX();
                                var lx = link.getX();
                                connectchains = (nextchain != null && cx < lx && AreaOp.obstructs(nextchain.getX(), lx, curchain));
                                connectlinks = (nextlink != null && lx < cx && AreaOp.obstructs(nextlink.getX(), cx, curlink));
                            }
                        }
                        if (connectchains) {
                            var subcurve = chain.linkTo(nextchain);
                            if (subcurve != null) {
                                /* add */ subcurves.push(subcurve);
                            }
                            curchain += 2;
                            chain = endlist[curchain];
                            nextchain = endlist[curchain + 1];
                        }
                        if (connectlinks) {
                            var openend = new sun.awt.geom.ChainEnd(link, null);
                            var closeend = new sun.awt.geom.ChainEnd(nextlink, openend);
                            openend.setOtherEnd(closeend);
                            /* add */ chains.push(openend);
                            /* add */ chains.push(closeend);
                            curlink += 2;
                            link = linklist[curlink];
                            nextlink = linklist[curlink + 1];
                        }
                        if (!connectchains && !connectlinks) {
                            chain.addLink(link);
                            /* add */ chains.push(chain);
                            curchain++;
                            chain = nextchain;
                            nextchain = endlist[curchain + 1];
                            curlink++;
                            link = nextlink;
                            nextlink = linklist[curlink + 1];
                        }
                    }
                    ;
                    if ((chains.length & 1) !== 0) {
                        console.info("Odd number of chains!");
                    }
                };
                AreaOp.obstructs = function (v1, v2, phase) {
                    return (((phase & 1) === 0) ? (v1 <= v2) : (v1 < v2));
                };
                return AreaOp;
            }());
            AreaOp.CTAG_LEFT = 0;
            AreaOp.CTAG_RIGHT = 1;
            AreaOp.ETAG_IGNORE = 0;
            AreaOp.ETAG_ENTER = 1;
            AreaOp.ETAG_EXIT = -1;
            AreaOp.RSTAG_INSIDE = 1;
            AreaOp.RSTAG_OUTSIDE = -1;
            geom.AreaOp = AreaOp;
            AreaOp["__class"] = "sun.awt.geom.AreaOp";
            (function (AreaOp) {
                var CAGOp = (function (_super) {
                    __extends(CAGOp, _super);
                    function CAGOp() {
                        var _this = _super.call(this) || this;
                        _this.inLeft = false;
                        _this.inRight = false;
                        _this.inResult = false;
                        return _this;
                    }
                    CAGOp.prototype.newRow = function () {
                        this.inLeft = false;
                        this.inRight = false;
                        this.inResult = false;
                    };
                    CAGOp.prototype.classify = function (e) {
                        if (e.getCurveTag() === sun.awt.geom.AreaOp.CTAG_LEFT) {
                            this.inLeft = !this.inLeft;
                        }
                        else {
                            this.inRight = !this.inRight;
                        }
                        var newClass = this.newClassification(this.inLeft, this.inRight);
                        if (this.inResult === newClass) {
                            return sun.awt.geom.AreaOp.ETAG_IGNORE;
                        }
                        this.inResult = newClass;
                        return (newClass ? sun.awt.geom.AreaOp.ETAG_ENTER : sun.awt.geom.AreaOp.ETAG_EXIT);
                    };
                    CAGOp.prototype.getState = function () {
                        return (this.inResult ? sun.awt.geom.AreaOp.RSTAG_INSIDE : sun.awt.geom.AreaOp.RSTAG_OUTSIDE);
                    };
                    return CAGOp;
                }(sun.awt.geom.AreaOp));
                AreaOp.CAGOp = CAGOp;
                CAGOp["__class"] = "sun.awt.geom.AreaOp.CAGOp";
                var AddOp = (function (_super) {
                    __extends(AddOp, _super);
                    function AddOp() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    AddOp.prototype.newClassification = function (inLeft, inRight) {
                        return (inLeft || inRight);
                    };
                    return AddOp;
                }(AreaOp.CAGOp));
                AreaOp.AddOp = AddOp;
                AddOp["__class"] = "sun.awt.geom.AreaOp.AddOp";
                var SubOp = (function (_super) {
                    __extends(SubOp, _super);
                    function SubOp() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    SubOp.prototype.newClassification = function (inLeft, inRight) {
                        return (inLeft && !inRight);
                    };
                    return SubOp;
                }(AreaOp.CAGOp));
                AreaOp.SubOp = SubOp;
                SubOp["__class"] = "sun.awt.geom.AreaOp.SubOp";
                var IntOp = (function (_super) {
                    __extends(IntOp, _super);
                    function IntOp() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    IntOp.prototype.newClassification = function (inLeft, inRight) {
                        return (inLeft && inRight);
                    };
                    return IntOp;
                }(AreaOp.CAGOp));
                AreaOp.IntOp = IntOp;
                IntOp["__class"] = "sun.awt.geom.AreaOp.IntOp";
                var XorOp = (function (_super) {
                    __extends(XorOp, _super);
                    function XorOp() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    XorOp.prototype.newClassification = function (inLeft, inRight) {
                        return (inLeft !== inRight);
                    };
                    return XorOp;
                }(AreaOp.CAGOp));
                AreaOp.XorOp = XorOp;
                XorOp["__class"] = "sun.awt.geom.AreaOp.XorOp";
                var NZWindOp = (function (_super) {
                    __extends(NZWindOp, _super);
                    function NZWindOp() {
                        var _this = _super.call(this) || this;
                        _this.count = 0;
                        return _this;
                    }
                    NZWindOp.prototype.newRow = function () {
                        this.count = 0;
                    };
                    NZWindOp.prototype.classify = function (e) {
                        var newCount = this.count;
                        var type = (newCount === 0 ? sun.awt.geom.AreaOp.ETAG_ENTER : sun.awt.geom.AreaOp.ETAG_IGNORE);
                        newCount += e.getCurve().getDirection();
                        this.count = newCount;
                        return (newCount === 0 ? sun.awt.geom.AreaOp.ETAG_EXIT : type);
                    };
                    NZWindOp.prototype.getState = function () {
                        return ((this.count === 0) ? sun.awt.geom.AreaOp.RSTAG_OUTSIDE : sun.awt.geom.AreaOp.RSTAG_INSIDE);
                    };
                    return NZWindOp;
                }(sun.awt.geom.AreaOp));
                AreaOp.NZWindOp = NZWindOp;
                NZWindOp["__class"] = "sun.awt.geom.AreaOp.NZWindOp";
                var EOWindOp = (function (_super) {
                    __extends(EOWindOp, _super);
                    function EOWindOp() {
                        var _this = _super.call(this) || this;
                        _this.inside = false;
                        return _this;
                    }
                    EOWindOp.prototype.newRow = function () {
                        this.inside = false;
                    };
                    EOWindOp.prototype.classify = function (e) {
                        var newInside = !this.inside;
                        this.inside = newInside;
                        return (newInside ? sun.awt.geom.AreaOp.ETAG_ENTER : sun.awt.geom.AreaOp.ETAG_EXIT);
                    };
                    EOWindOp.prototype.getState = function () {
                        return (this.inside ? sun.awt.geom.AreaOp.RSTAG_INSIDE : sun.awt.geom.AreaOp.RSTAG_OUTSIDE);
                    };
                    return EOWindOp;
                }(sun.awt.geom.AreaOp));
                AreaOp.EOWindOp = EOWindOp;
                EOWindOp["__class"] = "sun.awt.geom.AreaOp.EOWindOp";
            })(AreaOp = geom.AreaOp || (geom.AreaOp = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
/**
 * The {@code GeneralPath} class represents a geometric path constructed from
 * straight lines, and quadratic and cubic (B&eacute;zier) curves. It can
 * contain multiple subpaths.
 * <p>
 * {@code GeneralPath} is a legacy final class which exactly implements the
 * behavior of its superclass {@link Path2D.Float}. Together with
 * {@link Path2D.Double}, the {@link Path2D} classes provide full
 * implementations of a general geometric path that support all of the
 * functionality of the {@link Shape} and {@link PathIterator} interfaces with
 * the ability to explicitly select different levels of internal coordinate
 * precision.
 * <p>
 * Use {@code Path2D.Float} (or this legacy {@code GeneralPath} subclass) when
 * dealing with data that can be represented and used with floating point
 * precision. Use {@code Path2D.Double} for data that requires the accuracy or
 * range of double precision.
 *
 * @author Jim Graham
 * @since 1.2
 * @extends Path2D.Float
 */
var GeneralPath = (function (_super) {
    __extends(GeneralPath, _super);
    function GeneralPath(windingRule, pointTypes, numTypes, pointCoords, numCoords) {
        var _this = this;
        if (((typeof windingRule === 'number') || windingRule === null) && ((pointTypes != null && pointTypes instanceof Array && (pointTypes.length == 0 || pointTypes[0] == null || (typeof pointTypes[0] === 'number'))) || pointTypes === null) && ((typeof numTypes === 'number') || numTypes === null) && ((pointCoords != null && pointCoords instanceof Array && (pointCoords.length == 0 || pointCoords[0] == null || (typeof pointCoords[0] === 'number'))) || pointCoords === null) && ((typeof numCoords === 'number') || numCoords === null)) {
            var __args = Array.prototype.slice.call(arguments);
            _this = _super.call(this) || this;
            (function () {
                _this.windingRule = windingRule;
                _this.pointTypes = pointTypes;
                _this.numTypes = numTypes;
                _this.floatCoords = pointCoords;
                _this.numCoords = numCoords;
            })();
        }
        else if (((typeof windingRule === 'number') || windingRule === null) && ((typeof pointTypes === 'number') || pointTypes === null) && numTypes === undefined && pointCoords === undefined && numCoords === undefined) {
            var __args = Array.prototype.slice.call(arguments);
            var rule = __args[0];
            var initialCapacity = __args[1];
            _this = _super.call(this, rule, initialCapacity) || this;
        }
        else if (((windingRule != null && (windingRule["__interfaces"] != null && windingRule["__interfaces"].indexOf("java.awt.Shape") >= 0 || windingRule.constructor != null && windingRule.constructor["__interfaces"] != null && windingRule.constructor["__interfaces"].indexOf("java.awt.Shape") >= 0)) || windingRule === null) && pointTypes === undefined && numTypes === undefined && pointCoords === undefined && numCoords === undefined) {
            var __args = Array.prototype.slice.call(arguments);
            var s = __args[0];
            _this = _super.call(this, s, null) || this;
        }
        else if (((typeof windingRule === 'number') || windingRule === null) && pointTypes === undefined && numTypes === undefined && pointCoords === undefined && numCoords === undefined) {
            var __args = Array.prototype.slice.call(arguments);
            var rule = __args[0];
            _this = _super.call(this, rule, Path2D.INIT_SIZE) || this;
        }
        else if (windingRule === undefined && pointTypes === undefined && numTypes === undefined && pointCoords === undefined && numCoords === undefined) {
            var __args = Array.prototype.slice.call(arguments);
            _this = _super.call(this, Path2D.WIND_NON_ZERO_$LI$(), Path2D.INIT_SIZE) || this;
        }
        else
            throw new Error('invalid overload');
        return _this;
    }
    return GeneralPath;
}(Path2D.Float));
GeneralPath.serialVersionUID = -8327096662768731142;
GeneralPath["__class"] = "GeneralPath";
GeneralPath["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
sun.awt.geom.AreaOp.EmptyChainList_$LI$();
sun.awt.geom.AreaOp.EmptyLinkList_$LI$();
sun.awt.geom.AreaOp.YXTopComparator_$LI$();
javaemul.internal.DoubleHelper.PowersTable.invPowers_$LI$();
javaemul.internal.DoubleHelper.PowersTable.powers_$LI$();
javaemul.internal.DoubleHelper.POSITIVE_INFINITY_$LI$();
javaemul.internal.DoubleHelper.NEGATIVE_INFINITY_$LI$();
javaemul.internal.DoubleHelper.NaN_$LI$();
Path2D.Iterator.curvecoords_$LI$();
Path2D.SEG_CLOSE_$LI$();
Path2D.SEG_CUBICTO_$LI$();
Path2D.SEG_QUADTO_$LI$();
Path2D.SEG_LINETO_$LI$();
Path2D.SEG_MOVETO_$LI$();
Path2D.WIND_NON_ZERO_$LI$();
Path2D.WIND_EVEN_ODD_$LI$();
javaemul.internal.NumberHelper.__ParseLong.maxValueForRadix_$LI$();
javaemul.internal.NumberHelper.__ParseLong.maxLengthForRadix_$LI$();
javaemul.internal.NumberHelper.__ParseLong.maxDigitsRadixPower_$LI$();
javaemul.internal.NumberHelper.__ParseLong.maxDigitsForRadix_$LI$();
javaemul.internal.NumberHelper.__ParseLong.__static_initialize();
javaemul.internal.MathHelper.PI_UNDER_180_$LI$();
javaemul.internal.MathHelper.PI_OVER_180_$LI$();
javaemul.internal.MathHelper.MIN_VALUE_$LI$();
javaemul.internal.MathHelper.MAX_VALUE_$LI$();
javaemul.internal.MathHelper.EPSILON_$LI$();
javaemul.internal.CharacterHelper.BoxedValues.boxedValues_$LI$();
javaemul.internal.CharacterHelper.TYPE_$LI$();
RoundRectIterator.types_$LI$();
RoundRectIterator.ctrlpts_$LI$();
RoundRectIterator.acv_$LI$();
RoundRectIterator.cv_$LI$();
RoundRectIterator.c_$LI$();
RoundRectIterator.b_$LI$();
RoundRectIterator.a_$LI$();
RoundRectIterator.angle_$LI$();
EllipseIterator.ctrlpts_$LI$();
EllipseIterator.ncv_$LI$();
EllipseIterator.pcv_$LI$();
Area.EmptyCurves_$LI$();
AffineTransform.rot90conversion_$LI$();
AffineTransform.HI_SHEAR_$LI$();
AffineTransform.HI_SCALE_$LI$();
AffineTransform.HI_TRANSLATE_$LI$();
AffineTransform.HI_IDENTITY_$LI$();
AffineTransform.TYPE_MASK_ROTATION_$LI$();
AffineTransform.TYPE_MASK_SCALE_$LI$();
